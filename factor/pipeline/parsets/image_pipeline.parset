pipeline.steps = [update_mapfile_hosts, create_sector_files_map, create_timestep_map, create_freqstep_map, expand_h5parm_map, prepare_imaging_data, create_compressed_mapfile, premask, wsclean_image_full, create_imagebase_map, sector_image_mapfile]

pipeline.pluginpath = {{ pipeline_dir }}/plugins

# update host entries in all mapfiles
update_mapfile_hosts.control.kind        = plugin
update_mapfile_hosts.control.type        = updateHosts
update_mapfile_hosts.control.mapfile_dir = input.output.mapfile_dir
update_mapfile_hosts.control.hosts       = {{ hosts }}

# create a mapfile with input data from supplied list, length = nobs
create_sector_files_map.control.kind        = plugin
create_sector_files_map.control.type        = addListMapfile
create_sector_files_map.control.hosts       = {{ hosts }}
create_sector_files_map.control.files       = {{ sector_filename }}
create_sector_files_map.control.mapfile_dir = input.output.mapfile_dir
create_sector_files_map.control.filename    = sectorfiles.mapfile

# create a mapfile with each observation's timestep value, length = nobs
create_timestep_map.control.kind        = plugin
create_timestep_map.control.type        = addListMapfile
create_timestep_map.control.hosts       = {{ hosts }}
create_timestep_map.control.files       = {{ image_timestep }}
create_timestep_map.control.mapfile_dir = input.output.mapfile_dir
create_timestep_map.control.filename    = timestep.mapfile

# create a mapfile with each observation's freqstep value, length = nobs
create_freqstep_map.control.kind        = plugin
create_freqstep_map.control.type        = addListMapfile
create_freqstep_map.control.hosts       = {{ hosts }}
create_freqstep_map.control.files       = {{ image_freqstep }}
create_freqstep_map.control.mapfile_dir = input.output.mapfile_dir
create_freqstep_map.control.filename    = freqstep.mapfile

# expand mapfile of the dir-dependent parmDB to all obs, length = nobs
expand_h5parm_map.control.kind             = plugin
expand_h5parm_map.control.type             = expandMapfile
expand_h5parm_map.control.mapfile_in       = {{ h5parm_mapfile }}
expand_h5parm_map.control.mapfile_to_match = create_sector_files_map.output.mapfile
expand_h5parm_map.control.mapfile_dir      = input.output.mapfile_dir
expand_h5parm_map.control.filename         = expand_h5parms.mapfile

# phase shift, apply the direction-dependent solutions, and average, length = nobs
# note: the apply steps will not be necessary once we can use screens in WSClean
prepare_imaging_data.control.type                                 = dppp
prepare_imaging_data.control.mapfiles_in                          = [subtract_models.output.mapfile,expand_h5parm_map.output.mapfile,create_timestep_map.output.mapfile,create_freqstep_map.output.mapfile]
prepare_imaging_data.control.inputkeys                            = [msin,h5parm,timestep,freqstep]
prepare_imaging_data.argument.numthreads                          = {{ max_cpus_per_proc_single }}
prepare_imaging_data.argument.msin.datacolumn                     = DATA
prepare_imaging_data.argument.msout.overwrite                     = True
prepare_imaging_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
prepare_imaging_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}

{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}

{% if solve_tecandphase %}
{% if apply_slowgains %}
prepare_imaging_data.argument.steps                               = [flag,shift,tec,scphase,amp,phase,flagzero,avg]
{% else %}
prepare_imaging_data.argument.steps                               = [flag,shift,tec,scphase,flagzero,avg]
{% endif %}
{% else %}
{% if apply_slowgains %}
prepare_imaging_data.argument.steps                               = [flag,shift,tec,amp,phase,flagzero,avg]
{% else %}
prepare_imaging_data.argument.steps                               = [flag,shift,tec,flagzero,avg]
{% endif %}
{% endif %}

{% else %}

{% if solve_tecandphase %}
{% if apply_slowgains %}
prepare_imaging_data.argument.steps                               = [shift,tec,scphase,amp,phase,flagzero,avg]
{% else %}
prepare_imaging_data.argument.steps                               = [shift,tec,scphase,flagzero,avg]
{% endif %}
{% else %}
{% if apply_slowgains %}
prepare_imaging_data.argument.steps                               = [shift,tec,amp,phase,flagzero,avg]
{% else %}
prepare_imaging_data.argument.steps                               = [shift,tec,flagzero,avg]
{% endif %}
{% endif %}

{% endif %}

{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
prepare_imaging_data.argument.flag.type                           = preflagger
prepare_imaging_data.argument.flag.expr                           = {{ flag_expr }}
{% endif %}
{% if flag_abstime is not none %}
prepare_imaging_data.argument.flag.flag_abstime.abstime           = {{ flag_abstime }}
{% endif %}
{% if flag_baseline is not none %}
prepare_imaging_data.argument.flag.flag_baseline.baseline         = {{ flag_baseline }}
{% endif %}
{% if flag_freqrange is not none %}
prepare_imaging_data.argument.flag.flag_freqrange.freqrange       = {{ flag_freqrange }}
{% endif %}
prepare_imaging_data.argument.shift.type                          = phaseshifter
prepare_imaging_data.argument.shift.phasecenter                   = [{{ ra }}deg, {{ dec }}deg]
prepare_imaging_data.argument.tec.type                            = applycal
prepare_imaging_data.argument.tec.parmdb                          = h5parm
prepare_imaging_data.argument.tec.correction                      = screentec000
prepare_imaging_data.argument.tec.direction                       = [{{ central_patch }}]
{% if solve_tecandphase %}
prepare_imaging_data.argument.scphase.type                        = applycal
prepare_imaging_data.argument.scphase.parmdb                      = h5parm
prepare_imaging_data.argument.scphase.correction                  = screenphase000
prepare_imaging_data.argument.scphase.direction                   = [{{ central_patch }}]
{% endif %}
{% if apply_slowgains %}
prepare_imaging_data.argument.amp.type                            = applycal
prepare_imaging_data.argument.amp.parmdb                          = h5parm
prepare_imaging_data.argument.amp.correction                      = amplitude000
prepare_imaging_data.argument.amp.direction                       = [{{ central_patch }}]
prepare_imaging_data.argument.phase.type                          = applycal
prepare_imaging_data.argument.phase.parmdb                        = h5parm
prepare_imaging_data.argument.phase.correction                    = phase000
prepare_imaging_data.argument.phase.direction                     = [{{ central_patch }}]
{% endif %}
prepare_imaging_data.argument.flagzero.type                       = preflagger
prepare_imaging_data.argument.flagzero.amplmin                    = 1e-20
prepare_imaging_data.argument.avg.type                            = squash
prepare_imaging_data.argument.avg.freqstep                        = freqstep
prepare_imaging_data.argument.avg.timestep                        = timestep
{% if use_compression %}
prepare_imaging_data.argument.msout.storagemanager                = "Dysco"
prepare_imaging_data.argument.msout.storagemanager.databitrate    = 0
prepare_imaging_data.argument.msout.storagemanager.weightbitrate  = 12
prepare_imaging_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
prepare_imaging_data.argument.msout.storagemanager.disttruncation = 1.5
prepare_imaging_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make the compressed mapfile, length = 1
create_compressed_mapfile.control.kind        = plugin
create_compressed_mapfile.control.type        = compressMapfile
create_compressed_mapfile.control.mapfile_in  = prepare_imaging_data.output.mapfile
create_compressed_mapfile.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile.control.filename    = imaging_input.mapfile

# make a preliminary clean mask from the sector region, length = 1
premask.control.type                   = make_clean_mask
premask.control.mapfile_in             = create_compressed_mapfile.output.mapfile_dir
premask.control.inputkey               = imagefile
premask.control.outputkey              = maskfile
premask.argument.flags                 = [imagefile,maskfile]
premask.argument.img_format            = fits
premask.argument.pad_to_size           = {{ imsize }}
premask.argument.skip_source_detection = True
premask.argument.vertices_file         = {{ vertices_file }}
premask.argument.reference_ra_deg      = {{ ra }}
premask.argument.reference_dec_deg     = {{ dec }}
premask.argument.cellsize_deg          = {{ cellsize_deg }}
premask.argument.region_file           = {{ region_file }}
premask.argument.make_blank_image      = True

# do the imaging, length = 1
wsclean_image_full.control.type                   = wsclean
wsclean_image_full.control.mapfiles_in            = [prepare_imaging_data.output.mapfile,premask.output.mapfile]
wsclean_image_full.control.inputkeys              = [msfile,fitsmask]
{% if use_idg %}
wsclean_image_full.argument.flags                 = [-no-update-model-required,{{ wsclean_multiscale }}-fitbeam,-reorder,-save-source-list,-local-rms,-joinchannels,-use-idg,msfile]
{% else %}
wsclean_image_full.argument.flags                 = [-no-update-model-required,{{ wsclean_multiscale }}-fitbeam,-reorder,-save-source-list,-local-rms,-joinchannels,msfile]
{% endif %}
wsclean_image_full.argument.channelsout           = {{ wsclean_nchannels }}
wsclean_image_full.argument.fitsmask              = fitsmask
wsclean_image_full.argument.size                  = {{ imsize }} {{ imsize }}
wsclean_image_full.argument.niter                 = 100000
wsclean_image_full.argument.pol                   = I
wsclean_image_full.argument.weight                = briggs {{ robust }}
wsclean_image_full.argument.mgain                 = 0.8
wsclean_image_full.argument.minuv-l               = {{ min_uv_lambda }}
wsclean_image_full.argument.scale                 = {{ cellsize_deg }}
wsclean_image_full.argument.mem                   = {{ max_percent_memory_per_proc_single }}
wsclean_image_full.argument.j                     = {{ max_cpus_per_proc_single }}
{% if mscale_do and multiscale_scales_pixel is not none %}
wsclean_image_full.argument.multiscale-scales     = {{ multiscale_scales_pixel }}
{% endif %}
{% if local_dir is not none %}
wsclean_image_full.argument.tempdir               = {{ local_dir_parent }}
{% endif %}
wsclean_image_full.argument.multiscale-shape      = gaussian
wsclean_image_full.argument.weighting-rank-filter = 3
{% if taper_arcsec > 0.0 %}
wsclean_image_full.argument.taper-gaussian        = {{ taper_arcsec }}
{% endif %}
{% if wsclean_nwavelengths > 0.0 and not use_idg %}
wsclean_image_full.argument.baseline-averaging    = {{ wsclean_nwavelengths }}
{% endif %}
{% if region_field != "[]" %}
wsclean_image_full.argument.auto-mask             = 2
{% else %}
wsclean_image_full.argument.auto-mask             = 3
{% endif %}
wsclean_image_full.argument.auto-threshold        = 0.3
wsclean_image_full.argument.local-rms-window      = 50
wsclean_image_full.argument.local-rms-method      = rms-with-min
{% if use_idg %}
wsclean_image_full.argument.idg-mode              = {{ idg_mode }}
{% endif %}

# make a mapfile with the root-name of the WSClean images, length = 1
create_imagebase_map.control.kind        = plugin
create_imagebase_map.control.type        = trimMapfile
create_imagebase_map.control.mapfile_in  = wsclean_image_full.output.wsclean_image_full-image.fits.mapfile
create_imagebase_map.control.trim        = -
create_imagebase_map.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map.control.filename    = wsclean_image_full_image_rootnames.mapfile

# make a mapfile with the full name of the WSClean image, length = 1
sector_image_mapfile.control.kind        = plugin
sector_image_mapfile.control.type        = appendMapfile
sector_image_mapfile.control.mapfile_in  = create_imagebase_map2.output.mapfile
sector_image_mapfile.control.append      = -MFS-image.fits
sector_image_mapfile.control.mapfile_dir = input.output.mapfile_dir
sector_image_mapfile.control.filename    = sector_image.mapfile
