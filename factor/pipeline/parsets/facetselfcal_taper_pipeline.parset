{% extends "facetselfcal_pipeline.parset" %}
{% block selfcal_steps %} {% if not preapply_phase_cal %} average0, {% endif %} create_compressed_mapfile0, sort_average0_into_Groups, sort_average0_into_Groups_maps, concat_average0_data, create_compressed_mapfile01, premask_selfcal, wsclean_image01, create_imagebase_map01, adjust_wsclean_mapfile0, mask0, wsclean_image02, create_imagebase_map02, pad_selfcal_model0_images, regroup_concat_data_map, create_expanded_model0_mapfile, expand_selfcal_model_size_map, wsclean_ft0, {% if pre_average %} copy_model_data0, {% endif %} make_fast_phase_parmdb_map, {% if peel_skymodel is not none %} create_peel_skymodel_map, make_peel_sourcedb, expand_peel_sourcedb_map, {% endif %} remove_parmdbs1, solve_phaseonly1, {% if selfcal_local_dir is not none %} make_apply_mapfile, {% endif %} apply_phaseonly1, create_compressed_mapfile1, wsclean_image11, create_imagebase_map11, adjust_wsclean_mapfile11, mask1, wsclean_image12, create_imagebase_map12, create_expanded_model1_mapfile, pad_selfcal_model1_images, wsclean_ft1, {% if pre_average %} copy_model_data1, {% endif %} remove_parmdbs2, solve_phaseonly2, apply_phaseonly2, loop_phasecal, make_slow_gain_parmdb_map, remove_parmdbs12, solve_ampphase12, merge_amp_parmdbs1, smooth_amp1, expand_smoothed_amp1_parmdb_map, apply_amp1, create_compressed_mapfile3, wsclean_image31, create_imagebase_map31, adjust_wsclean_mapfile31, mask3, wsclean_image32, loop_ampcal, {% endblock selfcal_steps %}

{% block selfcal_parameters %}
########## start of first round of selfcal (20" resolution)
########## start of first round of selfcal

# apply dir-independent calibration and average, length = nfiles
# this step must be done band-by-band, as each band has its own parmdb.
# if we preapply solutions, we don't need to do this step as we already have
# averaged MSs from the shift_cal_dir_indep step
# Compress both data and weights
{% if not preapply_phase_cal %}
average0.control.type                                 = dppp
average0.control.mapfiles_in                          = [shift_cal.output.mapfile,create_parmdb_map.output.mapfile]
average0.control.inputkeys                            = [msin,parmdb]
average0.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
average0.argument.msin.datacolumn                     = DATA
average0.argument.msout.overwrite                     = True
average0.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average0.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average0.argument.steps                               = [correct,avg]
average0.argument.correct.type                        = applycal
average0.argument.correct.parmdb                      = parmdb
average0.argument.correct.correction                  = gain
average0.argument.correct.invert                      = True
average0.argument.avg.type                            = squash
average0.argument.avg.freqstep                        = 1
average0.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
average0.argument.msout.storagemanager                = "Dysco"
average0.argument.msout.storagemanager.databitrate    = 16
average0.argument.msout.storagemanager.weightbitrate  = 12
average0.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average0.argument.msout.storagemanager.disttruncation = 1.5
average0.argument.msout.storagemanager.normalization  = "AF"
{% endif %}
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile0.control.kind        = plugin
create_compressed_mapfile0.control.type        = compressMapfile
{% if preapply_phase_cal %}
create_compressed_mapfile0.control.mapfile_in  = shift_cal_dir_indep.output.mapfile
{% else %}
create_compressed_mapfile0.control.mapfile_in  = average0.output.mapfile
{% endif %}
create_compressed_mapfile0.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile0.control.filename    = concat_average0_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes
sort_average0_into_Groups.control.type           = sort_times_into_freqGroups
sort_average0_into_Groups.argument.flags         = [create_compressed_mapfile0.output.mapfile]
sort_average0_into_Groups.argument.filename      = sorted_average0_groups.mapfile
sort_average0_into_Groups.argument.mapfile_dir   = input.output.mapfile_dir
sort_average0_into_Groups.argument.hosts         = {{ hosts }}
sort_average0_into_Groups.argument.stepname      = sort_average0_into_Groups
sort_average0_into_Groups.argument.enforce_numSB = False
sort_average0_into_Groups.argument.nband_pad     = {{ nband_pad_selfcal }}

# convert the output of sort_average0_into_Groups into usable mapfiles, len = 1 / ntimes
sort_average0_into_Groups_maps.control.kind             = plugin
sort_average0_into_Groups_maps.control.type             = mapfilenamesFromMapfiles
sort_average0_into_Groups_maps.control.mapfile_groupmap = sort_average0_into_Groups.output.groupmapfile.mapfile
sort_average0_into_Groups_maps.control.mapfile_filesmap = sort_average0_into_Groups.output.mapfile.mapfile

# concat averaged data in frequency, length = ntimes
# Note, this step is done to ensure that we get WSClean channel images that match
# the datasets used for selfcal so that predict will work properly
# Compress both data and weights
concat_average0_data.control.type                                 = dppp_concat
concat_average0_data.control.mapfile_out                          = sort_average0_into_Groups_maps.output.groupmap
concat_average0_data.control.mapfile_in                           = sort_average0_into_Groups_maps.output.filesmap
concat_average0_data.control.inputkey                             = msin
concat_average0_data.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
concat_average0_data.argument.msin.datacolumn                     = DATA
concat_average0_data.argument.msin.missingdata                    = True
concat_average0_data.argument.msin.orderms                        = False
concat_average0_data.argument.msout.overwrite                     = True
concat_average0_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
concat_average0_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
concat_average0_data.argument.steps                               = []
{% if use_compression %}
concat_average0_data.argument.msout.storagemanager                = "Dysco"
concat_average0_data.argument.msout.storagemanager.databitrate    = 16
concat_average0_data.argument.msout.storagemanager.weightbitrate  = 12
concat_average0_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
concat_average0_data.argument.msout.storagemanager.disttruncation = 1.5
concat_average0_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile for concatenated averaged data MSs, length = 1
create_compressed_mapfile01.control.kind        = plugin
create_compressed_mapfile01.control.type        = compressMapfile
create_compressed_mapfile01.control.mapfile_in  = concat_average0_data.output.mapfile
create_compressed_mapfile01.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile01.control.filename    = image0_input.mapfile

# make a mask using user-supplied region (if any), length = 1
premask_selfcal.control.type                   = make_clean_mask
premask_selfcal.control.mapfile_in             = create_compressed_mapfile01.output.mapfile
premask_selfcal.control.inputkey               = imagefile
premask_selfcal.control.outputkey              = maskfile
premask_selfcal.argument.flags                 = [imagefile,maskfile]
premask_selfcal.argument.img_format            = fits
premask_selfcal.argument.pad_to_size           = {{ cal_imsize }}
premask_selfcal.argument.skip_source_detection = True
premask_selfcal.argument.vertices_file         = {{ vertices_file }}
premask_selfcal.argument.reference_ra_deg      = {{ ra }}
premask_selfcal.argument.reference_dec_deg     = {{ dec }}
premask_selfcal.argument.cellsize_deg          = {{ cellsize_selfcal_deg }}
premask_selfcal.argument.region_file           = {{ region_selfcal }}
premask_selfcal.argument.make_blank_image      = True
premask_selfcal.argument.trim_by               = 0.4

# image the concatenated data with wsclean, length = 1
wsclean_image01.control.type                    = wsclean
wsclean_image01.control.mapfiles_in             = [create_compressed_mapfile01.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image01.control.inputkeys               = [msfile,fitsmask]
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image01.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image01.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image01.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,msfile]
{% endif %}
wsclean_image01.argument.fitsmask               = fitsmask
wsclean_image01.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image01.argument.niter                  = 1000
wsclean_image01.argument.threshold              = 0.0
wsclean_image01.argument.pol                    = I
wsclean_image01.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image01.argument.mgain                  = 0.6
wsclean_image01.argument.cleanborder            = 0
wsclean_image01.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image01.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image01.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image01.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image01.argument.tempdir                = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image01.argument.tempdir                = {{ selfcal_local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image01.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image01.argument.deconvolution-channels = 3
wsclean_image01.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image01.argument.weighting-rank-filter  = 3
wsclean_image01.argument.taper-gaussian         = 20arcsec
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image01.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map01.control.kind        = plugin
create_imagebase_map01.control.type        = trimMapfile
create_imagebase_map01.control.mapfile_in  = wsclean_image01.output.wsclean_image01-image.fits.mapfile
create_imagebase_map01.control.trim        = -
create_imagebase_map01.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map01.control.filename    = wsclean_image01_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile0.control.kind        = plugin
adjust_wsclean_mapfile0.control.type        = appendMapfile
adjust_wsclean_mapfile0.control.mapfile_in  = create_imagebase_map01.output.mapfile
adjust_wsclean_mapfile0.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile0.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile0.control.filename    = wsclean_image01_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask0.control.type                    = make_clean_mask
mask0.control.mapfile_in              = adjust_wsclean_mapfile0.output.mapfile
mask0.control.inputkey                = imagefile
mask0.control.outputkey               = maskfile
mask0.argument.flags                  = [imagefile,maskfile]
mask0.argument.region_file            = {{ region_selfcal }}
mask0.argument.threshpix              = 10
mask0.argument.threshisl              = 6
mask0.argument.iterate_threshold      = True
mask0.argument.atrous_do              = {{ atrous_do }}
mask0.argument.rmsbox                 = (120,30)
mask0.argument.rmsbox_bright          = (120,30)
mask0.argument.adaptive_rmsbox        = True
mask0.argument.trim_by                = 0.4
mask0.argument.img_format             = fits
mask0.argument.threshold_format       = float
mask0.argument.use_adaptive_threshold = {{ use_selfcal_adaptive_threshold }}

# image the concatenated data again with wsclean, length = 1
wsclean_image02.control.type                    = wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image02.control.mapfiles_in             = [create_compressed_mapfile01.output.mapfile,mask0.output.mapfile,mask0.output.threshold_5sig.mapfile]
wsclean_image02.control.inputkeys               = [msfile,fitsmask,threshold]
wsclean_image02.argument.threshold              = threshold
wsclean_image02.argument.niter                  = 10000
{% else %}
wsclean_image02.control.mapfiles_in             = [create_compressed_mapfile01.output.mapfile,mask0.output.mapfile]
wsclean_image02.control.inputkeys               = [msfile,fitsmask]
wsclean_image02.argument.threshold              = 0.0
wsclean_image02.argument.niter                  = 1000
{% endif %}
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image02.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image02.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image02.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,msfile]
{% endif %}
wsclean_image02.argument.fitsmask               = fitsmask
wsclean_image02.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image02.argument.pol                    = I
wsclean_image02.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image02.argument.mgain                  = 0.6
wsclean_image02.argument.cleanborder            = 0
wsclean_image02.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image02.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image02.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image02.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image02.argument.tempdir                = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image02.argument.tempdir                = {{ selfcal_local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image02.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image02.argument.deconvolution-channels = 3
wsclean_image02.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image02.argument.weighting-rank-filter  = 3
wsclean_image02.argument.taper-gaussian         = 20arcsec
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image02.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map02.control.kind        = plugin
create_imagebase_map02.control.type        = trimMapfile
create_imagebase_map02.control.mapfile_in  = wsclean_image02.output.wsclean_image02-image.fits.mapfile
create_imagebase_map02.control.trim        = -
create_imagebase_map02.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map02.control.filename    = image02_rootname.mapfile

# pad the model image with zeros, length = 1
pad_selfcal_model0_images.control.type       = pad_image
pad_selfcal_model0_images.control.mapfile_in = create_imagebase_map02.output.mapfile
pad_selfcal_model0_images.control.inputkey   = imagefile
pad_selfcal_model0_images.argument.flags     = [imagefile]

# make compressed mapfile of concatenated data, length = ntimes
# needed for the wsclean_ft steps to get full frequency coverage per group
regroup_concat_data_map.control.kind               = plugin
regroup_concat_data_map.control.type               = compressMapfile
regroup_concat_data_map.control.mapfile_in         = {{ concat_data_mapfile }}
regroup_concat_data_map.control.nitems_to_compress = {{ num_cal_blocks }}
regroup_concat_data_map.control.mapfile_dir        = input.output.mapfile_dir
regroup_concat_data_map.control.filename           = regroup_concat_data.mapfile

# expand the mapfile of the model image to match ft files, length = ntimes
create_expanded_model0_mapfile.control.kind             = plugin
create_expanded_model0_mapfile.control.type             = expandMapfile
create_expanded_model0_mapfile.control.mapfile_in       = create_imagebase_map02.output.mapfile
create_expanded_model0_mapfile.control.mapfile_to_match = regroup_concat_data_map.output.mapfile
create_expanded_model0_mapfile.control.mapfile_dir      = input.output.mapfile_dir
create_expanded_model0_mapfile.control.filename         = expand_model0.mapfile

# expand mapfile of the model image sizes to all groups, length = ntimes
expand_selfcal_model_size_map.control.kind             = plugin
expand_selfcal_model_size_map.control.type             = expandMapfile
expand_selfcal_model_size_map.control.mapfile_in       = pad_selfcal_model0_images.output.padsize.mapfile
expand_selfcal_model_size_map.control.mapfile_to_match = regroup_concat_data_map.output.mapfile
expand_selfcal_model_size_map.control.mapfile_dir      = input.output.mapfile_dir
expand_selfcal_model_size_map.control.filename         = expand_selfcal_model_size.mapfile

# predict model visibilities, length = ntimes
wsclean_ft0.control.type         = wsclean_ft
wsclean_ft0.control.mapfiles_in  = [regroup_concat_data_map.output.mapfile,create_expanded_model0_mapfile.output.mapfile,expand_selfcal_model_size_map.output.mapfile]
wsclean_ft0.control.inputkeys    = [msfile,name,size]
wsclean_ft0.argument.flags       = [-predict,msfile]
wsclean_ft0.argument.scale       = {{ cellsize_selfcal_deg }}
wsclean_ft0.argument.mem         = {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft0.argument.channelsout = {{ wsclean_nchannels_selfcal }}
wsclean_ft0.argument.j           = {{ max_cpus_per_io_proc_ntimes }}
{% if selfcal_local_dir is none and local_dir is not none %}
# WSClean uses selfcal_local_dir automatically if the output files are there
wsclean_ft0.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

{% if pre_average %}
# copy the MODEL_DATA column to the preaveraged datasets, length = ntimes * num_cal_blocks
copy_model_data0.control.type        = copy_column
copy_model_data0.control.mapfiles_in = [{{ concat_data_mapfile }},{{ phase_concat_data_mapfile }}]
copy_model_data0.control.inputkeys   = [ms_from,ms_to]
copy_model_data0.argument.flags      = [ms_from,ms_to,MODEL_DATA,MODEL_DATA]
{% endif %}

# generate mapfile for the fast-phase parmDBs generated in the solve_phaseonly steps, length = ntimes * num_cal_blocks
make_fast_phase_parmdb_map.control.kind               = plugin
make_fast_phase_parmdb_map.control.type               = createMapfile
make_fast_phase_parmdb_map.control.method             = add_suffix_to_file
make_fast_phase_parmdb_map.control.mapfile_in         = concat_data.output.mapfile
make_fast_phase_parmdb_map.control.add_suffix_to_file = /instrument
make_fast_phase_parmdb_map.control.mapfile_dir        = input.output.mapfile_dir
make_fast_phase_parmdb_map.control.filename           = fast_parmdb.mapfile

{% if peel_skymodel is not none %}
# create a mapfile with the outlier skymodel from supplied list, length = 1
create_peel_skymodel_map.control.kind        = plugin
create_peel_skymodel_map.control.type        = addListMapfile
create_peel_skymodel_map.control.hosts       = {{ hosts }}
create_peel_skymodel_map.control.files       = [{{ peel_skymodel }}]
create_peel_skymodel_map.control.mapfile_dir = input.output.mapfile_dir
create_peel_skymodel_map.control.filename    = peel_skymodel.mapfile

# convert the outlier skymodel into a sourcedb, length = 1
make_peel_sourcedb.control.type       = make_sourcedb
make_peel_sourcedb.control.mapfile_in = create_peel_skymodel_map.output.mapfile
make_peel_sourcedb.control.inputkey   = in
make_peel_sourcedb.argument.format    = <
make_peel_sourcedb.argument.outtype   = blob

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_peel_sourcedb_map.control.kind             = plugin
expand_peel_sourcedb_map.control.type             = expandMapfile
expand_peel_sourcedb_map.control.mapfile_in       = make_peel_sourcedb.output.mapfile
expand_peel_sourcedb_map.control.mapfile_to_match = concat_data.output.mapfile
expand_peel_sourcedb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_peel_sourcedb_map.control.filename         = expand_peel_sourcedb.mapfile
{% endif %}

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs1.control.type       = remove_file
remove_parmdbs1.control.mapfile_in = make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs1.control.inputkey   = parmdb
remove_parmdbs1.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_phaseonly1.control.type                     = dppp_inplace
{% if peel_skymodel is not none %}
solve_phaseonly1.control.mapfiles_in              = [{{ phase_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile,expand_peel_sourcedb_map.output.mapfile]
solve_phaseonly1.control.inputkeys                = [msin,parmdb,sourcedb]
{% else %}
solve_phaseonly1.control.mapfiles_in              = [{{ phase_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
solve_phaseonly1.control.inputkeys                = [msin,parmdb]
{% endif %}
solve_phaseonly1.argument.numthreads              = {{ max_cpus_per_proc_ntimes }}
solve_phaseonly1.argument.msin.datacolumn         = DATA
solve_phaseonly1.argument.msout                   = .
solve_phaseonly1.argument.steps                   = [uvcut,solvetec]
solve_phaseonly1.argument.uvcut.type              = uvwflagger
solve_phaseonly1.argument.uvcut.uvlambdamin       = {{ solve_min_uv_lambda }}
solve_phaseonly1.argument.solvetec.type           = gaincal
solve_phaseonly1.argument.solvetec.caltype        = tecandphase
solve_phaseonly1.argument.solvetec.parmdb         = parmdb
{% if peel_skymodel is not none %}
solve_phaseonly1.argument.solvetec.usemodelcolumn = False
solve_phaseonly1.argument.solvetec.sourcedb       = sourcedb
{% else %}
solve_phaseonly1.argument.solvetec.usemodelcolumn = True
{% endif %}
solve_phaseonly1.argument.solvetec.solint         = {{ solint_time_p }}
solve_phaseonly1.argument.solvetec.nchan          = {{ solint_freq_a }}

########## end of first round of selfcal (20" resolution)
########## start of second round of selfcal (10" resolution)

{% if selfcal_local_dir is not none %}
# make mapfile for the output of apply steps, len = ntimes * num_cal_blocks
# this step is needed to direct the output to the shared disk if one is being
# used with mulitple nodes
make_apply_mapfile.control.kind         = plugin
make_apply_mapfile.control.type         = changeDirectory
make_apply_mapfile.control.mapfile_in   = make_concat_data_sync_mapfile.output.mapfile
make_apply_mapfile.control.new_dir      = {{ pipeline_parset_dir }}
make_apply_mapfile.control.append       = _apply_output
make_apply_mapfile.control.mapfile_dir  = input.output.mapfile_dir
make_apply_mapfile.control.filename     = apply_output.mapfile
{% endif %}

# apply the previous calibration and average, length = ntimes * num_cal_blocks
apply_phaseonly1.control.type                                 = dppp
apply_phaseonly1.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_phaseonly1.control.inputkeys                            = [msin,parmdb]
{% if selfcal_local_dir is not none %}
apply_phaseonly1.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_phaseonly1.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
apply_phaseonly1.argument.msin.datacolumn                     = DATA
apply_phaseonly1.argument.msout.overwrite                     = True
apply_phaseonly1.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_phaseonly1.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_phaseonly1.argument.steps                               = [correct_fast1,correct_fast2,avg]
apply_phaseonly1.argument.correct_fast1.type                  = applycal
apply_phaseonly1.argument.correct_fast1.parmdb                = parmdb
apply_phaseonly1.argument.correct_fast1.correction            = tec
apply_phaseonly1.argument.correct_fast1.invert                = True
apply_phaseonly1.argument.correct_fast2.type                  = applycal
apply_phaseonly1.argument.correct_fast2.parmdb                = parmdb
apply_phaseonly1.argument.correct_fast2.correction            = commonscalarphase
apply_phaseonly1.argument.correct_fast2.invert                = True
apply_phaseonly1.argument.avg.type                            = squash
apply_phaseonly1.argument.avg.freqstep                        = 1
apply_phaseonly1.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_phaseonly1.argument.msout.storagemanager                = "Dysco"
apply_phaseonly1.argument.msout.storagemanager.databitrate    = 16
apply_phaseonly1.argument.msout.storagemanager.weightbitrate  = 12
apply_phaseonly1.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_phaseonly1.argument.msout.storagemanager.disttruncation = 1.5
apply_phaseonly1.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile1.control.kind        = plugin
create_compressed_mapfile1.control.type        = compressMapfile
create_compressed_mapfile1.control.mapfile_in  = apply_phaseonly1.output.mapfile
create_compressed_mapfile1.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile1.control.filename    = image1_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image11.control.type                    = wsclean
wsclean_image11.control.mapfiles_in             = [create_compressed_mapfile1.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image11.control.inputkeys               = [msfile,fitsmask]
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image11.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image11.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image11.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,msfile]
{% endif %}
wsclean_image11.argument.fitsmask               = fitsmask
wsclean_image11.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image11.argument.niter                  = 1000
wsclean_image11.argument.threshold              = 0.0
wsclean_image11.argument.pol                    = I
wsclean_image11.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image11.argument.mgain                  = 0.6
wsclean_image11.argument.cleanborder            = 0
wsclean_image11.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image11.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image11.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image11.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image11.argument.tempdir                = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image11.argument.tempdir                = {{ selfcal_local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image11.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image11.argument.deconvolution-channels = 3
wsclean_image11.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image11.argument.weighting-rank-filter  = 3
wsclean_image11.argument.taper-gaussian         = 10arcsec
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image11.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map11.control.kind        = plugin
create_imagebase_map11.control.type        = trimMapfile
create_imagebase_map11.control.mapfile_in  = wsclean_image11.output.wsclean_image11-image.fits.mapfile
create_imagebase_map11.control.trim        = -
create_imagebase_map11.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map11.control.filename    = wsclean_image11_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile11.control.kind        = plugin
adjust_wsclean_mapfile11.control.type        = appendMapfile
adjust_wsclean_mapfile11.control.mapfile_in  = create_imagebase_map11.output.mapfile
adjust_wsclean_mapfile11.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile11.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile11.control.filename    = wsclean_image11_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask1.control.type                    = make_clean_mask
mask1.control.mapfile_in              = adjust_wsclean_mapfile11.output.mapfile
mask1.control.inputkey                = imagefile
mask1.control.outputkey               = maskfile
mask1.argument.flags                  = [imagefile,maskfile]
mask1.argument.region_file            = {{ region_selfcal }}
mask1.argument.threshpix              = 8
mask1.argument.threshisl              = 7
mask1.argument.iterate_threshold      = True
mask1.argument.atrous_do              = {{ atrous_do }}
mask1.argument.rmsbox                 = (120,30)
mask1.argument.rmsbox_bright          = (80,20)
mask1.argument.adaptive_rmsbox        = True
mask1.argument.trim_by                = 0.4
mask1.argument.img_format             = fits
mask1.argument.threshold_format       = float
mask1.argument.use_adaptive_threshold = {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image12.control.type                    = wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image12.control.mapfiles_in             = [create_compressed_mapfile1.output.mapfile,mask1.output.mapfile,mask1.output.threshold_5sig.mapfile]
wsclean_image12.control.inputkeys               = [msfile,fitsmask,threshold]
wsclean_image12.argument.threshold              = threshold
wsclean_image12.argument.niter                  = 10000
{% else %}
wsclean_image12.control.mapfiles_in             = [create_compressed_mapfile1.output.mapfile,mask1.output.mapfile]
wsclean_image12.control.inputkeys               = [msfile,fitsmask]
wsclean_image12.argument.threshold              = 0.0
wsclean_image12.argument.niter                  = 1000
{% endif %}
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image12.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image12.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image12.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,msfile]
{% endif %}
wsclean_image12.argument.fitsmask               = fitsmask
wsclean_image12.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image12.argument.pol                    = I
wsclean_image12.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image12.argument.mgain                  = 0.6
wsclean_image12.argument.cleanborder            = 0
wsclean_image12.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image12.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image12.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image12.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image12.argument.tempdir                = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image12.argument.tempdir                = {{ selfcal_local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image12.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image12.argument.deconvolution-channels = 3
wsclean_image12.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image12.argument.weighting-rank-filter  = 3
wsclean_image12.argument.taper-gaussian         = 10arcsec
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image12.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map12.control.kind        = plugin
create_imagebase_map12.control.type        = trimMapfile
create_imagebase_map12.control.mapfile_in  = wsclean_image12.output.wsclean_image12-image.fits.mapfile
create_imagebase_map12.control.trim        = -
create_imagebase_map12.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map12.control.filename    = wsclean_image12_image_rootname.mapfile

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model1_mapfile.control.kind             = plugin
create_expanded_model1_mapfile.control.type             = expandMapfile
create_expanded_model1_mapfile.control.mapfile_in       = create_imagebase_map12.output.mapfile
create_expanded_model1_mapfile.control.mapfile_to_match = regroup_concat_data_map.output.mapfile
create_expanded_model1_mapfile.control.mapfile_dir      = input.output.mapfile_dir
create_expanded_model1_mapfile.control.filename         = expand_wsclean_model1.mapfile

## pad the model image with zeros, length = 1
pad_selfcal_model1_images.control.type       = pad_image
pad_selfcal_model1_images.control.mapfile_in = create_imagebase_map12.output.mapfile
pad_selfcal_model1_images.control.inputkey   = imagefile
pad_selfcal_model1_images.argument.flags     = [imagefile]

# predict model visibilities, length = ntimes
wsclean_ft1.control.type         = wsclean_ft
wsclean_ft1.control.mapfiles_in  = [regroup_concat_data_map.output.mapfile,create_expanded_model1_mapfile.output.mapfile,expand_selfcal_model_size_map.output.mapfile]
wsclean_ft1.control.inputkeys    = [msfile,name,size]
wsclean_ft1.argument.flags       = [-predict,msfile]
wsclean_ft1.argument.scale       = {{ cellsize_selfcal_deg }}
wsclean_ft1.argument.mem         = {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft1.argument.channelsout = {{ wsclean_nchannels_selfcal }}
wsclean_ft1.argument.j           = {{ max_cpus_per_io_proc_ntimes }}
{% if selfcal_local_dir is none and local_dir is not none %}
# WSClean uses selfcal_local_dir automatically if the output files are there
wsclean_ft1.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

{% if pre_average %}
# copy the MODEL_DATA column to the preaveraged datasets, length = ntimes * num_cal_blocks
copy_model_data1.control.type        = copy_column
copy_model_data1.control.mapfiles_in = [{{ concat_data_mapfile }},{{ phase_concat_data_mapfile }}]
copy_model_data1.control.inputkeys   = [ms_from,ms_to]
copy_model_data1.argument.flags      = [ms_from,ms_to,MODEL_DATA,MODEL_DATA]
{% endif %}

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs2.control.type       = remove_file
remove_parmdbs2.control.mapfile_in = make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs2.control.inputkey   = parmdb
remove_parmdbs2.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_phaseonly2.control.type                     = dppp_inplace
solve_phaseonly2.control.mapfiles_in              = [{{ phase_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
solve_phaseonly2.control.inputkeys                = [msin,parmdb]
solve_phaseonly2.argument.numthreads              = {{ max_cpus_per_proc_ntimes }}
solve_phaseonly2.argument.msin.datacolumn         = DATA
solve_phaseonly2.argument.msout                   = .
solve_phaseonly2.argument.steps                   = [uvcut,solvetec]
solve_phaseonly2.argument.uvcut.type              = uvwflagger
solve_phaseonly2.argument.uvcut.uvlambdamin       = {{ solve_min_uv_lambda }}
solve_phaseonly2.argument.solvetec.type           = gaincal
solve_phaseonly2.argument.solvetec.caltype        = tecandphase
solve_phaseonly2.argument.solvetec.parmdb         = parmdb
solve_phaseonly2.argument.solvetec.usemodelcolumn = True
solve_phaseonly2.argument.solvetec.solint         = {{ solint_time_p }}
solve_phaseonly2.argument.solvetec.nchan          = {{ solint_freq_a }}

########## end of second round of selfcal
########## start of third round of selfcal

# apply the previous calibration, length = ntimes * num_cal_blocks
apply_phaseonly2.control.type                      = dppp_inplace
apply_phaseonly2.control.mapfiles_in               = [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_phaseonly2.control.inputkeys                 = [msin,parmdb]
apply_phaseonly2.argument.numthreads               = {{ max_cpus_per_proc_ntimes }}
apply_phaseonly2.argument.msin.datacolumn          = DATA
apply_phaseonly2.argument.msout                    = .
apply_phaseonly2.argument.msout.datacolumn         = CORRECTED_DATA
apply_phaseonly2.argument.steps                    = [correct_fast1,correct_fast2]
apply_phaseonly2.argument.correct_fast1.type       = applycal
apply_phaseonly2.argument.correct_fast1.parmdb     = parmdb
apply_phaseonly2.argument.correct_fast1.correction = tec
apply_phaseonly2.argument.correct_fast1.invert     = True
apply_phaseonly2.argument.correct_fast2.type       = applycal
apply_phaseonly2.argument.correct_fast2.parmdb     = parmdb
apply_phaseonly2.argument.correct_fast2.correction = commonscalarphase
apply_phaseonly2.argument.correct_fast2.invert     = True

########## end of second round of selfcal (10" resolution)
########## start of phase-only selfcal loop

# loop step
loop_phasecal.control.kind      = loop
loop_phasecal.control.type      = conditional
loop_phasecal.control.loopcount = {{ loopcount }}
loop_phasecal.control.loopsteps = [average2,create_compressed_mapfile2,wsclean_image21,create_imagebase_map21,adjust_wsclean_mapfile21,mask2,wsclean_image22,create_imagebase_map22,create_expanded_model2_mapfile,pad_selfcal_model2_images,wsclean_ft2,{% if pre_average %}copy_model_data2,{% endif %}remove_parmdbs11,solve_ampphase11,apply_ampphase11,adjust_wsclean_mapfile22_phaseloop,copy_image1,check_image1]

# average the output of the previous apply step, length = ntimes * num_cal_blocks
average2.control.type                                 = dppp
average2.control.mapfile_in                           = {{ concat_data_mapfile }}
average2.control.inputkey                             = msin
{% if selfcal_local_dir is not none %}
average2.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
average2.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
average2.argument.msin.datacolumn                     = CORRECTED_DATA
average2.argument.msout.overwrite                     = True
average2.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average2.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average2.argument.steps                               = [avg]
average2.argument.avg.type                            = squash
average2.argument.avg.freqstep                        = 1
average2.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
average2.argument.msout.storagemanager                = "Dysco"
average2.argument.msout.storagemanager.databitrate    = 16
average2.argument.msout.storagemanager.weightbitrate  = 12
average2.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average2.argument.msout.storagemanager.disttruncation = 1.5
average2.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile2.control.kind        = plugin
create_compressed_mapfile2.control.type        = compressMapfile
create_compressed_mapfile2.control.mapfile_in  = average2.output.mapfile
create_compressed_mapfile2.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile2.control.filename    = image2_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image21.control.type                    = wsclean
wsclean_image21.control.mapfiles_in             = [create_compressed_mapfile2.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image21.control.inputkeys               = [msfile,fitsmask]
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image21.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image21.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image21.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,msfile]
{% endif %}
wsclean_image21.argument.fitsmask               = fitsmask
wsclean_image21.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image21.argument.niter                  = 1000
wsclean_image21.argument.threshold              = 0.0
wsclean_image21.argument.pol                    = I
wsclean_image21.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image21.argument.mgain                  = 0.6
wsclean_image21.argument.cleanborder            = 0
wsclean_image21.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image21.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image21.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image21.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image21.argument.tempdir                = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image21.argument.tempdir                = {{ selfcal_local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image21.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image21.argument.deconvolution-channels = 3
wsclean_image21.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image21.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image21.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map21.control.kind        = plugin
create_imagebase_map21.control.type        = trimMapfile
create_imagebase_map21.control.mapfile_in  = wsclean_image21.output.wsclean_image21-image.fits.mapfile
create_imagebase_map21.control.trim        = -
create_imagebase_map21.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map21.control.filename    = wsclean_image21_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile21.control.kind        = plugin
adjust_wsclean_mapfile21.control.type        = appendMapfile
adjust_wsclean_mapfile21.control.mapfile_in  = create_imagebase_map21.output.mapfile
adjust_wsclean_mapfile21.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile21.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile21.control.filename    = wsclean_image21_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask2.control.type                    = make_clean_mask
mask2.control.mapfile_in              = adjust_wsclean_mapfile21.output.mapfile
mask2.control.inputkey                = imagefile
mask2.control.outputkey               = maskfile
mask2.argument.flags                  = [imagefile,maskfile]
mask2.argument.region_file            = {{ region_selfcal }}
mask2.argument.threshpix              = 8
mask2.argument.threshisl              = 7
mask2.argument.iterate_threshold      = True
mask2.argument.atrous_do              = {{ atrous_do }}
mask2.argument.rmsbox                 = (80,20)
mask2.argument.adaptive_rmsbox        = True
mask2.argument.trim_by                = 0.4
mask2.argument.img_format             = fits
mask2.argument.threshold_format       = float
mask2.argument.use_adaptive_threshold = {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image22.control.type                    = wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image22.control.mapfiles_in             = [create_compressed_mapfile2.output.mapfile,mask2.output.mapfile,mask2.output.threshold_5sig.mapfile]
wsclean_image22.control.inputkeys               = [msfile,fitsmask,threshold]
wsclean_image22.argument.threshold              = threshold
wsclean_image22.argument.niter                  = 10000
{% else %}
wsclean_image22.control.mapfiles_in             = [create_compressed_mapfile2.output.mapfile,mask2.output.mapfile]
wsclean_image22.control.inputkeys               = [msfile,fitsmask]
wsclean_image22.argument.threshold              = 0.0
wsclean_image22.argument.niter                  = 1000
{% endif %}
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image22.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image22.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image22.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,msfile]
{% endif %}
wsclean_image22.argument.fitsmask               = fitsmask
wsclean_image22.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image22.argument.pol                    = I
wsclean_image22.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image22.argument.mgain                  = 0.6
wsclean_image22.argument.cleanborder            = 0
wsclean_image22.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image22.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image22.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image22.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image22.argument.tempdir                = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image22.argument.tempdir                = {{ selfcal_local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image22.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image22.argument.deconvolution-channels = 3
wsclean_image22.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image22.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image22.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map22.control.kind        = plugin
create_imagebase_map22.control.type        = trimMapfile
create_imagebase_map22.control.mapfile_in  = wsclean_image22.output.wsclean_image22-image.fits.mapfile
create_imagebase_map22.control.trim        = -
create_imagebase_map22.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map22.control.filename    = wsclean_image22_image_rootname.mapfile

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model2_mapfile.control.kind             = plugin
create_expanded_model2_mapfile.control.type             = expandMapfile
create_expanded_model2_mapfile.control.mapfile_in       = create_imagebase_map22.output.mapfile
create_expanded_model2_mapfile.control.mapfile_to_match = regroup_concat_data_map.output.mapfile
create_expanded_model2_mapfile.control.mapfile_dir      = input.output.mapfile_dir
create_expanded_model2_mapfile.control.filename         = expand_wsclean_model1.mapfile

# pad the model image with zeros, length = 1
pad_selfcal_model2_images.control.type       = pad_image
pad_selfcal_model2_images.control.mapfile_in = create_imagebase_map22.output.mapfile
pad_selfcal_model2_images.control.inputkey   = imagefile
pad_selfcal_model2_images.argument.flags     = [imagefile]

# predict model visibilities, length = ntimes
wsclean_ft2.control.type         = wsclean_ft
wsclean_ft2.control.mapfiles_in  = [regroup_concat_data_map.output.mapfile,create_expanded_model2_mapfile.output.mapfile,expand_selfcal_model_size_map.output.mapfile]
wsclean_ft2.control.inputkeys    = [msfile,name,size]
wsclean_ft2.argument.flags       = [-predict,msfile]
wsclean_ft2.argument.scale       = {{ cellsize_selfcal_deg }}
wsclean_ft2.argument.mem         = {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft2.argument.channelsout = {{ wsclean_nchannels_selfcal }}
wsclean_ft2.argument.j           = {{ max_cpus_per_io_proc_ntimes }}
{% if selfcal_local_dir is none and local_dir is not none %}
# WSClean uses selfcal_local_dir automatically if the output files are there
wsclean_ft2.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

{% if pre_average %}
# copy the MODEL_DATA column to the preaveraged datasets, length = ntimes * num_cal_blocks
copy_model_data2.control.type        = copy_column
copy_model_data2.control.mapfiles_in = [{{ concat_data_mapfile }},{{ phase_concat_data_mapfile }}]
copy_model_data2.control.inputkeys   = [ms_from,ms_to]
copy_model_data2.argument.flags      = [ms_from,ms_to,MODEL_DATA,MODEL_DATA]
{% endif %}

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs11.control.type       = remove_file
remove_parmdbs11.control.mapfile_in = make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs11.control.inputkey   = parmdb
remove_parmdbs11.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase11.control.type                     = dppp_inplace
solve_ampphase11.control.mapfiles_in              = [{{ phase_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
solve_ampphase11.control.inputkeys                = [msin,parmdb]
solve_ampphase11.argument.numthreads              = {{ max_cpus_per_proc_ntimes }}
solve_ampphase11.argument.msin.datacolumn         = DATA
solve_ampphase11.argument.msout                   = .
solve_ampphase11.argument.steps                   = [uvcut,solvetec]
solve_ampphase11.argument.uvcut.type              = uvwflagger
solve_ampphase11.argument.uvcut.uvlambdamin       = {{ solve_min_uv_lambda }}
solve_ampphase11.argument.solvetec.type           = gaincal
solve_ampphase11.argument.solvetec.caltype        = tecandphase
solve_ampphase11.argument.solvetec.parmdb         = parmdb
solve_ampphase11.argument.solvetec.usemodelcolumn = True
solve_ampphase11.argument.solvetec.solint         = {{ solint_time_p }}
solve_ampphase11.argument.solvetec.nchan          = {{ solint_freq_a }}

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase11.control.type                                 = dppp_inplace
apply_ampphase11.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_ampphase11.control.inputkeys                            = [msin,parmdb]
apply_ampphase11.argument.numthreads                          = {{ max_cpus_per_proc_ntimes }}
apply_ampphase11.argument.msin.datacolumn                     = DATA
apply_ampphase11.argument.msout                               = .
apply_ampphase11.argument.msout.datacolumn                    = CORRECTED_DATA
apply_ampphase11.argument.steps                               = [correct_fast1,correct_fast2]
apply_ampphase11.argument.correct_fast1.type                  = applycal
apply_ampphase11.argument.correct_fast1.parmdb                = parmdb
apply_ampphase11.argument.correct_fast1.correction            = tec
apply_ampphase11.argument.correct_fast1.invert                = True
apply_ampphase11.argument.correct_fast2.type                  = applycal
apply_ampphase11.argument.correct_fast2.parmdb                = parmdb
apply_ampphase11.argument.correct_fast2.correction            = commonscalarphase
apply_ampphase11.argument.correct_fast2.invert                = True
{% if use_compression %}
apply_ampphase11.argument.msout.storagemanager                = "Dysco"
apply_ampphase11.argument.msout.storagemanager.databitrate    = 16
apply_ampphase11.argument.msout.storagemanager.weightbitrate  = 12
apply_ampphase11.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_ampphase11.argument.msout.storagemanager.disttruncation = 1.5
apply_ampphase11.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# fiddle with the image mapfiles, length = 1
adjust_wsclean_mapfile22_phaseloop.control.kind        = plugin
adjust_wsclean_mapfile22_phaseloop.control.type        = appendMapfile
adjust_wsclean_mapfile22_phaseloop.control.mapfile_in  = create_imagebase_map22.output.mapfile
adjust_wsclean_mapfile22_phaseloop.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile22_phaseloop.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile22_phaseloop.control.filename    = compare_image_input_new1.mapfile

# copy the output image so that we can compare it later, length = 1
copy_image1.control.type       = copy_image
copy_image1.control.mapfile_in = adjust_wsclean_mapfile22_phaseloop.output.mapfile
copy_image1.control.inputkey   = image
copy_image1.argument.flags     = [image,loop_phasecal.output.counter,2]

# compare the current and the previous image to see if we can stop the loop, length = 1
check_image1.control.type        = compare_image_stats
check_image1.control.mapfiles_in = [adjust_wsclean_mapfile22_phaseloop.output.mapfile,copy_image1.output.previous_image.mapfile]
check_image1.control.inputkeys   = [image_new,image_prev]
check_image1.argument.flags      = [image_new,image_prev,loop_phasecal.output.counter,1.05]

###### end of phase-only selfcal loop
###### continue to amplitude calibration

# generate mapfile for the slow-gain parmDBs generated in the solve_ampphase12 step
make_slow_gain_parmdb_map.control.kind               =  plugin
make_slow_gain_parmdb_map.control.type               =  createMapfile
make_slow_gain_parmdb_map.control.method             =  add_suffix_to_file
make_slow_gain_parmdb_map.control.mapfile_in         =  concat_data.output.mapfile
make_slow_gain_parmdb_map.control.add_suffix_to_file =  /instrument_slow
make_slow_gain_parmdb_map.control.mapfile_dir        =  input.output.mapfile_dir
make_slow_gain_parmdb_map.control.filename           =  slow_parmdb.mapfile

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs12.control.type       = remove_file
remove_parmdbs12.control.mapfile_in = make_slow_gain_parmdb_map.output.mapfile
remove_parmdbs12.control.inputkey   = parmdb
remove_parmdbs12.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase12.control.type                      = dppp_inplace
solve_ampphase12.control.mapfiles_in               = [{{ concat_data_mapfile }},make_slow_gain_parmdb_map.output.mapfile]
solve_ampphase12.control.inputkeys                 = [msin,parmdb]
solve_ampphase12.argument.numthreads               = {{ max_cpus_per_proc_ntimes }}
solve_ampphase12.argument.msin.datacolumn          = CORRECTED_DATA
solve_ampphase12.argument.msout                    = .
solve_ampphase12.argument.steps                    = [uvcut,solvegain]
solve_ampphase12.argument.uvcut.type               = uvwflagger
solve_ampphase12.argument.uvcut.uvlambdamin        = {{ solve_min_uv_lambda }}
solve_ampphase12.argument.solvegain.type           = gaincal
solve_ampphase12.argument.solvegain.caltype        = {{ selfcal_caltype }}
solve_ampphase12.argument.solvegain.parmdb         = parmdb
solve_ampphase12.argument.solvegain.usemodelcolumn = True
solve_ampphase12.argument.solvegain.solint         = {{ solint_time_a }}
solve_ampphase12.argument.solvegain.nchan          = {{ solint_freq_a }}

# merge the parmDBs with the amplitude solutions into one, length = 1
merge_amp_parmdbs1.control.type       = merge_parmdbs_in_time
merge_amp_parmdbs1.control.mapfile_in = concat_data_compressed_mapfile.output.mapfile
merge_amp_parmdbs1.control.inputkey   = mslist
merge_amp_parmdbs1.control.outputkey  = outparmdb
merge_amp_parmdbs1.argument.flags     = [mslist,instrument_slow,outparmdb]

# smooth the amplitues in the merged parmDB, length = 1
# smooth_amps uses only ANTENNA subtable of inputms, so it should work on virtual concatenated MS
smooth_amp1.control.type       = {{ smooth_amps_task }}
smooth_amp1.control.mapfile_in = merge_amp_parmdbs1.output.mapfile
smooth_amp1.control.inputkey   = ampparmdb
smooth_amp1.control.outputkey  = outparmdb
smooth_amp1.control.arguments  = [ampparmdb,outparmdb]

# expand the mapfile with the smoothd parmDB to all time-steps, length = ntimes * num_cal_blocks
expand_smoothed_amp1_parmdb_map.control.kind             = plugin
expand_smoothed_amp1_parmdb_map.control.type             = expandMapfile
expand_smoothed_amp1_parmdb_map.control.mapfile_in       = smooth_amp1.output.mapfile
expand_smoothed_amp1_parmdb_map.control.mapfile_to_match = concat_data.output.mapfile
expand_smoothed_amp1_parmdb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_smoothed_amp1_parmdb_map.control.filename         = expand_amp1_smoothed_parmdbs.mapfile

# apply the smoothed amplitudes and average, length = ntimes * num_cal_blocks
apply_amp1.control.type                                 = dppp
apply_amp1.control.mapfiles_in                          = [{{ concat_data_mapfile }},expand_smoothed_amp1_parmdb_map.output.mapfile]
apply_amp1.control.inputkeys                            = [msin,parmdb]
{% if selfcal_local_dir is not none %}
apply_amp1.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_amp1.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
apply_amp1.argument.msin.datacolumn                     = CORRECTED_DATA
apply_amp1.argument.msout.overwrite                     = True
apply_amp1.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_amp1.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_amp1.argument.steps                               = [correct_slow,avg]
apply_amp1.argument.correct_slow.type                   = applycal
apply_amp1.argument.correct_slow.parmdb                 = parmdb
apply_amp1.argument.correct_slow.invert                 = True
apply_amp1.argument.avg.type                            = squash
apply_amp1.argument.avg.freqstep                        = 1
apply_amp1.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_amp1.argument.msout.storagemanager                = "Dysco"
apply_amp1.argument.msout.storagemanager.databitrate    = 16
apply_amp1.argument.msout.storagemanager.weightbitrate  = 12
apply_amp1.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_amp1.argument.msout.storagemanager.disttruncation = 1.5
apply_amp1.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

########## end of third round of selfcal
########## start of fourth round of selfcal

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile3.control.kind        = plugin
create_compressed_mapfile3.control.type        = compressMapfile
create_compressed_mapfile3.control.mapfile_in  = apply_amp1.output.mapfile
create_compressed_mapfile3.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile3.control.filename    = image3_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image31.control.type                    = wsclean
wsclean_image31.control.mapfiles_in             = [create_compressed_mapfile3.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image31.control.inputkeys               = [msfile,fitsmask]
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image31.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image31.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image31.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,msfile]
{% endif %}
wsclean_image31.argument.fitsmask               = fitsmask
wsclean_image31.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image31.argument.niter                  = 1000
wsclean_image31.argument.threshold              = 0.0
wsclean_image31.argument.pol                    = I
wsclean_image31.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image31.argument.mgain                  = 0.6
wsclean_image31.argument.cleanborder            = 0
wsclean_image31.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image31.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image31.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image31.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image31.argument.tempdir                = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image31.argument.tempdir                = {{ selfcal_local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image31.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image21.argument.deconvolution-channels = 3
wsclean_image21.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image31.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image31.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map31.control.kind        = plugin
create_imagebase_map31.control.type        = trimMapfile
create_imagebase_map31.control.mapfile_in  = wsclean_image31.output.wsclean_image31-image.fits.mapfile
create_imagebase_map31.control.trim        = -
create_imagebase_map31.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map31.control.filename    = wsclean_image31_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile31.control.kind        = plugin
adjust_wsclean_mapfile31.control.type        = appendMapfile
adjust_wsclean_mapfile31.control.mapfile_in  = create_imagebase_map31.output.mapfile
adjust_wsclean_mapfile31.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile31.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile31.control.filename    = wsclean_image31_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask3.control.type                    = make_clean_mask
mask3.control.mapfile_in              = adjust_wsclean_mapfile31.output.mapfile
mask3.control.inputkey                = imagefile
mask3.control.outputkey               = maskfile
mask3.argument.flags                  = [imagefile,maskfile]
mask3.argument.region_file            = {{ region_selfcal }}
mask3.argument.threshpix              = 10
mask3.argument.threshisl              = 10
mask3.argument.iterate_threshold      = True
mask3.argument.atrous_do              = {{ atrous_do }}
mask3.argument.rmsbox                 = (80,20)
mask3.argument.adaptive_rmsbox        = True
mask3.argument.trim_by                = 0.4
mask3.argument.img_format             = fits
mask3.argument.adaptive_thresh        = 180
mask3.argument.threshold_format       = float
mask3.argument.use_adaptive_threshold = {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image32.control.type                    = wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image32.control.mapfiles_in             = [create_compressed_mapfile3.output.mapfile,mask3.output.mapfile,mask3.output.threshold_5sig.mapfile]
wsclean_image32.control.inputkeys               = [msfile,fitsmask,threshold]
wsclean_image32.argument.threshold              = threshold
wsclean_image32.argument.niter                  = 10000
{% else %}
wsclean_image32.control.mapfiles_in             = [create_compressed_mapfile3.output.mapfile,mask3.output.mapfile]
wsclean_image32.control.inputkeys               = [msfile,fitsmask]
wsclean_image32.argument.threshold              = 0.0
wsclean_image32.argument.niter                  = 1000
{% endif %}
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image32.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image32.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image32.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,msfile]
{% endif %}
wsclean_image32.argument.fitsmask               = fitsmask
wsclean_image32.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image32.argument.pol                    = I
wsclean_image32.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image32.argument.mgain                  = 0.6
wsclean_image32.argument.cleanborder            = 0
wsclean_image32.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image32.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image32.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image32.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image32.argument.tempdir                = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image32.argument.tempdir                = {{ selfcal_local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image32.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image32.argument.deconvolution-channels = 3
wsclean_image32.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image32.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image32.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

########## start of phase+amp selfcal loop

# loop step
loop_ampcal.control.kind      = loop
loop_ampcal.control.type      = conditional
loop_ampcal.control.loopcount = {{ loopcount }}
loop_ampcal.control.loopsteps = [create_imagebase_map32,create_expanded_model3_mapfile,pad_selfcal_model3_images,wsclean_ft3,{% if pre_average %}copy_model_data3,{% endif %}remove_parmdbs21,solve_ampphase21,apply_ampphase21,merge_phase_parmdbs,remove_parmdbs22,solve_ampphase22,merge_amp_parmdbs2,smooth_amp2,expand_smoothed_amp2_parmdb_map,apply_amp2,create_compressed_mapfile4,wsclean_image41,create_imagebase_map41,adjust_wsclean_mapfile41,mask4,wsclean_image42,create_imagebase_map42,adjust_wsclean_mapfile42,copy_image2,check_image2]

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map32.control.kind        = plugin
create_imagebase_map32.control.type        = trimMapfile
create_imagebase_map32.control.mapfile_in  = wsclean_image32.output.wsclean_image32-image.fits.mapfile
create_imagebase_map32.control.trim        = -
create_imagebase_map32.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map32.control.filename    = model3_rootnames.mapfile
create_imagebase_map32.control.counter     = loop_ampcal.output.counter

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model3_mapfile.control.kind             = plugin
create_expanded_model3_mapfile.control.type             = expandMapfile
create_expanded_model3_mapfile.control.mapfile_in       = create_imagebase_map32.output.mapfile
create_expanded_model3_mapfile.control.mapfile_to_match = regroup_concat_data_map.output.mapfile
create_expanded_model3_mapfile.control.mapfile_dir      = input.output.mapfile_dir
create_expanded_model3_mapfile.control.filename         = expand_wsclean_model1.mapfile

# pad the model image with zeros, length = 1
pad_selfcal_model3_images.control.type       = pad_image
pad_selfcal_model3_images.control.mapfile_in = create_imagebase_map32.output.mapfile
pad_selfcal_model3_images.control.inputkey   = imagefile
pad_selfcal_model3_images.argument.flags     = [imagefile]

# predict model visibilities, length =  times
wsclean_ft3.control.type         = wsclean_ft
wsclean_ft3.control.mapfiles_in  = [regroup_concat_data_map.output.mapfile,create_expanded_model3_mapfile.output.mapfile,expand_selfcal_model_size_map.output.mapfile]
wsclean_ft3.control.inputkeys    = [msfile,name,size]
wsclean_ft3.argument.flags       = [-predict,msfile]
wsclean_ft3.argument.scale       = {{ cellsize_selfcal_deg }}
wsclean_ft3.argument.mem         = {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft3.argument.channelsout = {{ wsclean_nchannels_selfcal }}
wsclean_ft3.argument.j           = {{ max_cpus_per_io_proc_ntimes }}
{% if selfcal_local_dir is none and local_dir is not none %}
# WSClean uses selfcal_local_dir automatically if the output files are there
wsclean_ft3.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

{% if pre_average %}
# copy the MODEL_DATA column to the preaveraged datasets, length = ntimes * num_cal_blocks
copy_model_data3.control.type        = copy_column
copy_model_data3.control.mapfiles_in = [{{ concat_data_mapfile }},{{ phase_concat_data_mapfile }}]
copy_model_data3.control.inputkeys   = [ms_from,ms_to]
copy_model_data3.argument.flags      = [ms_from,ms_to,MODEL_DATA,MODEL_DATA]
{% endif %}

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs21.control.type       = remove_file
remove_parmdbs21.control.mapfile_in = make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs21.control.inputkey   = parmdb
remove_parmdbs21.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase21.control.type                     = dppp_inplace
solve_ampphase21.control.mapfiles_in              = [{{ phase_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
solve_ampphase21.control.inputkeys                = [msin,parmdb]
solve_ampphase21.argument.numthreads              = {{ max_cpus_per_proc_ntimes }}
solve_ampphase21.argument.msin.datacolumn         = DATA
solve_ampphase21.argument.msout                   = .
solve_ampphase21.argument.steps                   = [uvcut,solvetec]
solve_ampphase21.argument.uvcut.type              = uvwflagger
solve_ampphase21.argument.uvcut.uvlambdamin       = {{ solve_min_uv_lambda }}
solve_ampphase21.argument.solvetec.type           = gaincal
solve_ampphase21.argument.solvetec.caltype        = tecandphase
solve_ampphase21.argument.solvetec.parmdb         = parmdb
solve_ampphase21.argument.solvetec.usemodelcolumn = True
solve_ampphase21.argument.solvetec.solint         = {{ solint_time_p }}
solve_ampphase21.argument.solvetec.nchan          = {{ solint_freq_a }}

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase21.control.type                                 = dppp_inplace
apply_ampphase21.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_ampphase21.control.inputkeys                            = [msin,parmdb]
apply_ampphase21.argument.numthreads                          = {{ max_cpus_per_proc_ntimes }}
apply_ampphase21.argument.msin.datacolumn                     = DATA
apply_ampphase21.argument.msout                               = .
apply_ampphase21.argument.msout.datacolumn                    = CORRECTED_DATA
apply_ampphase21.argument.steps                               = [correct_fast1,correct_fast2]
apply_ampphase21.argument.correct_fast1.type                  = applycal
apply_ampphase21.argument.correct_fast1.parmdb                = parmdb
apply_ampphase21.argument.correct_fast1.correction            = tec
apply_ampphase21.argument.correct_fast1.invert                = True
apply_ampphase21.argument.correct_fast2.type                  = applycal
apply_ampphase21.argument.correct_fast2.parmdb                = parmdb
apply_ampphase21.argument.correct_fast2.correction            = commonscalarphase
apply_ampphase21.argument.correct_fast2.invert                = True
{% if use_compression %}
apply_ampphase21.argument.msout.storagemanager                = "Dysco"
apply_ampphase21.argument.msout.storagemanager.databitrate    = 16
apply_ampphase21.argument.msout.storagemanager.weightbitrate  = 12
apply_ampphase21.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_ampphase21.argument.msout.storagemanager.disttruncation = 1.5
apply_ampphase21.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# merge the parmDBs with the phase solutions into one, length = 1
# This is needed later when the loop is done and we want to apply the solutions to the original data
merge_phase_parmdbs.control.type       = merge_parmdbs_in_time
merge_phase_parmdbs.control.mapfile_in = concat_data_compressed_mapfile.output.mapfile
merge_phase_parmdbs.control.inputkey   = mslist
merge_phase_parmdbs.control.outputkey  = outparmdb
merge_phase_parmdbs.argument.flags     = [mslist,instrument,outparmdb]

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs22.control.type       = remove_file
remove_parmdbs22.control.mapfile_in = make_slow_gain_parmdb_map.output.mapfile
remove_parmdbs22.control.inputkey   = parmdb
remove_parmdbs22.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase22.control.type                      = dppp_inplace
solve_ampphase22.control.mapfiles_in               = [{{ concat_data_mapfile }},make_slow_gain_parmdb_map.output.mapfile]
solve_ampphase22.control.inputkeys                 = [msin,parmdb]
solve_ampphase22.argument.numthreads               = {{ max_cpus_per_proc_ntimes }}
solve_ampphase22.argument.msin.datacolumn          = CORRECTED_DATA
solve_ampphase22.argument.msout                    = .
solve_ampphase22.argument.steps                    = [uvcut,solvegain]
solve_ampphase22.argument.uvcut.type               = uvwflagger
solve_ampphase22.argument.uvcut.uvlambdamin        = {{ solve_min_uv_lambda }}
solve_ampphase22.argument.solvegain.type           = gaincal
solve_ampphase22.argument.solvegain.caltype        = {{ selfcal_caltype }}
solve_ampphase22.argument.solvegain.parmdb         = parmdb
solve_ampphase22.argument.solvegain.usemodelcolumn = True
solve_ampphase22.argument.solvegain.solint         = {{ solint_time_a }}
solve_ampphase22.argument.solvegain.nchan          = {{ solint_freq_a }}

# merge the parmDBs with the amplitude solutions into one, length = 1
# This is also used after the loop, but also now for smoothing the amplitudes
merge_amp_parmdbs2.control.type       = merge_parmdbs_in_time
merge_amp_parmdbs2.control.mapfile_in = concat_data_compressed_mapfile.output.mapfile
merge_amp_parmdbs2.control.inputkey   = mslist
merge_amp_parmdbs2.control.outputkey  = outparmdb
merge_amp_parmdbs2.argument.flags     = [mslist,instrument_slow,outparmdb]

# smooth the amplitudes in the merged parmDB, length = 1
# smooth_amps uses only ANTENNA subtable of inputms, so it should work on virtual concatenated MS
smooth_amp2.control.type       = {{ smooth_amps_task }}
smooth_amp2.control.mapfile_in = merge_amp_parmdbs2.output.mapfile
smooth_amp2.control.inputkey   = ampparmdb
smooth_amp2.control.outputkey  = outparmdb
smooth_amp2.control.arguments  = [ampparmdb,outparmdb]

# expand the mapfile with the smoothd parmDB to all time-steps, length = ntimes * num_cal_blocks
expand_smoothed_amp2_parmdb_map.control.kind             = plugin
expand_smoothed_amp2_parmdb_map.control.type             = expandMapfile
expand_smoothed_amp2_parmdb_map.control.mapfile_in       = smooth_amp2.output.mapfile
expand_smoothed_amp2_parmdb_map.control.mapfile_to_match = concat_data.output.mapfile
expand_smoothed_amp2_parmdb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_smoothed_amp2_parmdb_map.control.filename         = expand_amp2_smoothed_parmdbs.mapfile

# apply the smoothed amplitudes and average, length = ntimes * num_cal_blocks
apply_amp2.control.type                                 = dppp
apply_amp2.control.mapfiles_in                          = [{{ concat_data_mapfile }},expand_smoothed_amp2_parmdb_map.output.mapfile]
apply_amp2.control.inputkeys                            = [msin,parmdb]
{% if selfcal_local_dir is not none %}
apply_amp2.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_amp2.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
apply_amp2.argument.msin.datacolumn                     = CORRECTED_DATA
apply_amp2.argument.msout.overwrite                     = True
apply_amp2.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_amp2.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_amp2.argument.steps                               = [correct_slow,avg]
apply_amp2.argument.correct_slow.type                   = applycal
apply_amp2.argument.correct_slow.parmdb                 = parmdb
apply_amp2.argument.correct_slow.invert                 = True
apply_amp2.argument.avg.type                            = squash
apply_amp2.argument.avg.freqstep                        = 1
apply_amp2.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_amp2.argument.msout.storagemanager                = "Dysco"
apply_amp2.argument.msout.storagemanager.databitrate    = 16
apply_amp2.argument.msout.storagemanager.weightbitrate  = 12
apply_amp2.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_amp2.argument.msout.storagemanager.disttruncation = 1.5
apply_amp2.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

########## end of fourth or of the looped round of selfcal

########## start of looped round of selfcal
########## make image to check if we can stop the loop, or as new model

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile4.control.kind        = plugin
create_compressed_mapfile4.control.type        = compressMapfile
create_compressed_mapfile4.control.mapfile_in  = apply_amp2.output.mapfile
create_compressed_mapfile4.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile4.control.filename    = image4_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image41.control.type                    = wsclean
wsclean_image41.control.mapfiles_in             = [create_compressed_mapfile4.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image41.control.inputkeys               = [msfile,fitsmask]
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image41.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image41.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image41.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,msfile]
{% endif %}
wsclean_image41.argument.fitsmask               = fitsmask
wsclean_image41.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image41.argument.niter                  = 1000
wsclean_image41.argument.threshold              = 0.0
wsclean_image41.argument.pol                    = I
wsclean_image41.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image41.argument.mgain                  = 0.6
wsclean_image41.argument.cleanborder            = 0
wsclean_image41.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image41.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image41.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image41.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image41.argument.tempdir                = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image41.argument.tempdir                = {{ selfcal_local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image41.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image41.argument.deconvolution-channels = 3
wsclean_image41.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image41.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image41.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map41.control.kind        = plugin
create_imagebase_map41.control.type        = trimMapfile
create_imagebase_map41.control.mapfile_in  = wsclean_image41.output.wsclean_image41-image.fits.mapfile
create_imagebase_map41.control.trim        = -
create_imagebase_map41.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map41.control.filename    = wsclean_image41_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile41.control.kind        = plugin
adjust_wsclean_mapfile41.control.type        = appendMapfile
adjust_wsclean_mapfile41.control.mapfile_in  = create_imagebase_map41.output.mapfile
adjust_wsclean_mapfile41.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile41.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile41.control.filename    = wsclean_image41_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask4.control.type                    = make_clean_mask
mask4.control.mapfile_in              = adjust_wsclean_mapfile41.output.mapfile
mask4.control.inputkey                = imagefile
mask4.control.outputkey               = maskfile
mask4.argument.flags                  = [imagefile,maskfile]
mask4.argument.region_file            = {{ region_selfcal }}
mask4.argument.threshpix              = 8
mask4.argument.threshisl              = 8
mask4.argument.iterate_threshold      = True
mask4.argument.atrous_do              = {{ atrous_do }}
mask4.argument.rmsbox                 = (80,20)
mask4.argument.adaptive_rmsbox        = True
mask4.argument.trim_by                = 0.4
mask4.argument.img_format             = fits
mask4.argument.adaptive_thresh        = 200
mask4.argument.threshold_format       = float
mask4.argument.use_adaptive_threshold = {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image42.control.type                    = wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image42.control.mapfiles_in             = [create_compressed_mapfile4.output.mapfile,mask4.output.mapfile,mask4.output.threshold_5sig.mapfile]
wsclean_image42.control.inputkeys               = [msfile,fitsmask,threshold]
wsclean_image42.argument.threshold              = threshold
wsclean_image42.argument.niter                  = 10000
{% else %}
wsclean_image42.control.mapfiles_in             = [create_compressed_mapfile4.output.mapfile,mask4.output.mapfile]
wsclean_image42.control.inputkeys               = [msfile,fitsmask]
wsclean_image42.argument.threshold              = 0.0
wsclean_image42.argument.niter                  = 1000
{% endif %}
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image42.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image42.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image42.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,msfile]
{% endif %}
wsclean_image42.argument.fitsmask               = fitsmask
wsclean_image42.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image42.argument.pol                    = I
wsclean_image42.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image42.argument.mgain                  = 0.6
wsclean_image42.argument.cleanborder            = 0
wsclean_image42.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image42.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image42.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image42.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image42.argument.tempdir                = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image42.argument.tempdir                = {{ selfcal_local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image42.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image42.argument.deconvolution-channels = 3
wsclean_image42.argument.fit-spectral-pol       = 3
{% endif %}
wsclean_image42.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image42.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map42.control.kind        = plugin
create_imagebase_map42.control.type        = trimMapfile
create_imagebase_map42.control.mapfile_in  = wsclean_image42.output.wsclean_image42-image.fits.mapfile
create_imagebase_map42.control.trim        = -
create_imagebase_map42.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map42.control.filename    = wsclean_image41_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile42.control.kind        = plugin
adjust_wsclean_mapfile42.control.type        = appendMapfile
adjust_wsclean_mapfile42.control.mapfile_in  = create_imagebase_map42.output.mapfile
adjust_wsclean_mapfile42.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile42.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile42.control.filename    = compare_image_input_new.mapfile

# copy the output image so that we can compare it later, length = 1
copy_image2.control.type       = copy_image
copy_image2.control.mapfile_in = adjust_wsclean_mapfile42.output.mapfile
copy_image2.control.inputkey   = image
copy_image2.argument.flags     = [image,loop_ampcal.output.counter,4]

# compare the current and the previous image to see if we can stop the loop, length = 1
check_image2.control.type        = compare_image_stats
check_image2.control.mapfiles_in = [adjust_wsclean_mapfile42.output.mapfile,copy_image2.output.previous_image.mapfile]
check_image2.control.inputkeys   = [image_new,image_prev]
check_image2.argument.flags      = [image_new,image_prev]

########## end of phase+amp selfcal loop
{% endblock selfcal_parameters %}
