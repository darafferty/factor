pipeline.steps = [update_mapfile_hosts, create_ms_map, create_msmulti_map, create_parmdb_map, create_full_skymodels_map, make_facet_skymodels_all, make_sourcedb_all_facet_sources, expand_sourcedb_all_facet_sources, make_facet_skymodels_cal, make_sourcedb_cal_facet_sources, expand_sourcedb_cal_facet_sources, shift_empty, predict_all_model_data, add_all_facet_sources, shift_cal, create_compressed_mapfile_data, sort_into_Groups, sort_into_Groups_maps, concat_data, {% if pre_average %} regroup_shift_cal, regroup_parmdb, pre_average, make_blavg_data_mapfile, switch_weights_col_shift_cal1, concat_blavg_data, switch_weights_col_shift_cal2, copy_column1, copy_column2, {% endif %} add_imaging_cols, concat_data_compressed_mapfile, concat_chunks, average0, create_compressed_mapfile_avgdata, sort_avg_into_Groups, sort_avg_into_Groups_maps, concat_avgdata, create_compressed_mapfile0, concat0, premask_selfcal, wsclean_image01, create_imagebase_map01, adjust_wsclean_mapfile0, mask0, wsclean_image02, create_imagebase_map02, create_expanded_model0_mapfile, wsclean_ft0, switch_weights_col1, make_fast_phase_parmdb_map, remove_parmdbs1, solve_phaseonly1, switch_weights_col2, apply_phaseonly1, create_compressed_mapfile1, concat1, wsclean_image11, create_imagebase_map11, adjust_wsclean_mapfile11, mask1, wsclean_image12, create_imagebase_map12, create_expanded_model1_mapfile, wsclean_ft1, switch_weights_col3, remove_parmdbs2, solve_phaseonly2, switch_weights_col4, apply_phaseonly2, loop_phasecal, make_slow_gain_parmdb_map, remove_parmdbs12, solve_ampphase12, merge_amp_parmdbs1, smooth_amp1, expand_smoothed_amp1_parmdb_map, apply_amp1, create_compressed_mapfile3, concat3, wsclean_image31, create_imagebase_map31, adjust_wsclean_mapfile31, mask3, wsclean_image32, loop_ampcal, merge_selfcal_parmdbs, make_selfcal_plots, create_selfcal_images_mapfile, make_selfcal_images, expand_merged_parmdb_map, add_imaging_cols_empty, {% if is_patch %} regroup_shift_empty_map_ft, concat_unaveraged_ft, create_compressed_mapfile_ft, create_model4_map, blank_model, casa_ft4, {% else %} apply_dir_dep, create_compressed_mapfile5, sort_averaged, sort_averaged_maps, concat_averaged, concat_averaged_compressed_map, {% block full_image_steps %} premask, wsclean_image_full1, create_imagebase_map, adjust_wsclean_mapfile1, mask5, wsclean_image_full2, create_model4_map, adjust_wsclean_mapfile2, pad_model_images, regroup_shift_empty_map, create_expanded_model_mapfile, expand_facet_model_size_map, wsclean_ft, {% endblock full_image_steps %} {% endif %} corrupt_final_model, subtract_initial_final, shift_diff_model_to_field, create_middle_band_mapfile, create_middle_model_mapfile, subtract_single, average_pre, average_post, average_pre_compressed_map, wsclean_pre, average_post_compressed_map, wsclean_post, verify_subtract]

pipeline.pluginpath                                        =   {{ pipeline_dir }}/plugins

update_mapfile_hosts.control.kind                          =   plugin
update_mapfile_hosts.control.type                          =   updateHosts
update_mapfile_hosts.control.mapfile_dir                   =   input.output.mapfile_dir
update_mapfile_hosts.control.hosts                         =   {{ hosts }}

# create a mapfile with all single MSs from supplied list, length = nfiles
create_ms_map.control.kind                                 =   plugin
create_ms_map.control.type                                 =   addListMapfile
create_ms_map.control.hosts                                =   {{ hosts }}
create_ms_map.control.files                                =   {{ ms_files_single }}
create_ms_map.control.mapfile_dir                          =   input.output.mapfile_dir
create_ms_map.control.filename                             =   input_files_single.mapfile

# create a multi-mapfile with the groups of MSs from supplied list, length = nbands
create_msmulti_map.control.kind                            =   plugin
create_msmulti_map.control.type                            =   addListMultiMapfile
create_msmulti_map.control.hosts                           =   {{ hosts }}
create_msmulti_map.control.files                           =   {{ ms_files_grouped }}
create_msmulti_map.control.mapfile_dir                     =   input.output.mapfile_dir
create_msmulti_map.control.filename                        =   input_files_grouped.mapfile

# create a mapfile with the direction-independent parmDBs from supplied list, length = nfiles
create_parmdb_map.control.kind                             =   plugin
create_parmdb_map.control.type                             =   addListMapfile
create_parmdb_map.control.hosts                            =   {{ hosts }}
create_parmdb_map.control.files                            =   {{ dir_indep_parmDBs }}
create_parmdb_map.control.mapfile_dir                      =   input.output.mapfile_dir
create_parmdb_map.control.filename                         =   dir_indep_instrument_parmdbs.mapfile

# create a mapfile with the current skymodels from supplied list, length = nbands
create_full_skymodels_map.control.kind                     =   plugin
create_full_skymodels_map.control.type                     =   addListMapfile
create_full_skymodels_map.control.hosts                    =   {{ hosts }}
create_full_skymodels_map.control.files                    =   {{ skymodels }}
create_full_skymodels_map.control.mapfile_dir              =   input.output.mapfile_dir
create_full_skymodels_map.control.filename                 =   full_skymodels.mapfile

# extract the skymodel for this facet from global skymodel, length = nbands
make_facet_skymodels_all.control.type                      =   make_facet_skymodel
make_facet_skymodels_all.control.mapfile_in                =   create_full_skymodels_map.output.mapfile
make_facet_skymodels_all.control.inputkey                  =   fullmodelfile
make_facet_skymodels_all.control.outputkey                 =   outfile
make_facet_skymodels_all.argument.flags                    =   [fullmodelfile,outfile,{{ vertices_file }}]
make_facet_skymodels_all.argument.cal_only                 =   False

# convert the facet skymodel into a sourcedb, length = nbands
make_sourcedb_all_facet_sources.control.type               =   make_sourcedb
make_sourcedb_all_facet_sources.control.opts.mapfile_in    =   make_facet_skymodels_all.output.mapfile
make_sourcedb_all_facet_sources.control.opts.inputkey      =   in
make_sourcedb_all_facet_sources.argument.format            =   <
make_sourcedb_all_facet_sources.argument.outtype           =   blob

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_all_facet_sources.control.kind             =   plugin
expand_sourcedb_all_facet_sources.control.type             =   mapfileSingleToGroup
expand_sourcedb_all_facet_sources.control.mapfile_in       =   make_sourcedb_all_facet_sources.output.mapfile
expand_sourcedb_all_facet_sources.control.mapfile_groups   =   create_msmulti_map.output.mapfile
expand_sourcedb_all_facet_sources.control.mapfile_dir      =   input.output.mapfile_dir
expand_sourcedb_all_facet_sources.control.filename         =   expand_sourcedb_all_facet_sources.mapfile

# extract the skymodel for the calibrator of this facet from global skymodel, length = nbands
make_facet_skymodels_cal.control.type                      =   make_facet_skymodel
make_facet_skymodels_cal.control.mapfile_in                =   create_full_skymodels_map.output.mapfile
make_facet_skymodels_cal.control.inputkey                  =   fullmodelfile
make_facet_skymodels_cal.control.outputkey                 =   outfile
make_facet_skymodels_cal.argument.flags                    =   [fullmodelfile,outfile,{{ vertices_file }}]
make_facet_skymodels_cal.argument.cal_only                 =   True

# convert the facet skymodel into a sourcedb, length = nbands
make_sourcedb_cal_facet_sources.control.type               =   make_sourcedb
make_sourcedb_cal_facet_sources.control.opts.mapfile_in    =   make_facet_skymodels_cal.output.mapfile
make_sourcedb_cal_facet_sources.control.opts.inputkey      =   in
make_sourcedb_cal_facet_sources.argument.format            =   <
make_sourcedb_cal_facet_sources.argument.outtype           =   blob

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_cal_facet_sources.control.kind             =   plugin
expand_sourcedb_cal_facet_sources.control.type             =   mapfileSingleToGroup
expand_sourcedb_cal_facet_sources.control.mapfile_in       =   make_sourcedb_cal_facet_sources.output.mapfile
expand_sourcedb_cal_facet_sources.control.mapfile_groups   =   create_msmulti_map.output.mapfile
expand_sourcedb_cal_facet_sources.control.mapfile_dir      =   input.output.mapfile_dir
expand_sourcedb_cal_facet_sources.control.filename         =   expand_sourcedb_cal_facet_sources.mapfile

# shift full-res data to facet position (to accept result of final ft step), length = nfiles
shift_empty.control.type                                   =   dppp
shift_empty.control.opts.mapfile_in                        =   create_ms_map.output.mapfile
shift_empty.control.opts.inputkey                          =   msin
shift_empty.argument.numthreads                            =   {{ max_cpus_per_io_proc_nfiles }}
shift_empty.argument.msin.datacolumn                       =   {{ subtracted_data_colname }}
shift_empty.argument.msout.overwrite                       =   True
shift_empty.argument.msout.writefullresflag                =   False
shift_empty.argument.local_scratch_dir                     =   {{ local_dir }}
shift_empty.argument.steps                                 =   [shift]
shift_empty.argument.shift.type                            =   phaseshifter
{% if is_patch or skip_facet_imaging %}
shift_empty.argument.shift.phasecenter                     =   [{{ ra }}deg, {{ dec }}deg]
{% else %}
shift_empty.argument.shift.phasecenter                     =   [{{ facet_ra }}deg, {{ facet_dec }}deg]
{% endif %}

# predict the skymodel data for the full facet, length = nfiles
predict_all_model_data.control.type                        =   dppp
{% if is_patch or skip_facet_imaging %}
predict_all_model_data.control.opts.mapfiles_in            =   [shift_empty.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
{% else %}
predict_all_model_data.control.opts.mapfiles_in            =   [shift_empty.output.mapfile,expand_sourcedb_all_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
{% endif %}
predict_all_model_data.control.opts.inputkeys              =   [msin,sourcedb,parmdb]
predict_all_model_data.argument.numthreads                 =   {{ max_cpus_per_io_proc_nfiles }}
predict_all_model_data.argument.msout.overwrite            =   True
predict_all_model_data.argument.msout.writefullresflag     =   False
predict_all_model_data.argument.local_scratch_dir          =   {{ local_dir }}
predict_all_model_data.argument.steps                      =   [pred]
predict_all_model_data.argument.pred.type                  =   predict
predict_all_model_data.argument.pred.sourcedb              =   sourcedb
predict_all_model_data.argument.pred.operation             =   replace
predict_all_model_data.argument.pred.applycal.parmdb       =   parmdb

# add predicted facet data to phase-shifted empty data, length = nfiles
add_all_facet_sources.control.type                         =   add_subtract_columns
add_all_facet_sources.control.opts.mapfiles_in             =   [shift_empty.output.mapfile,predict_all_model_data.output.mapfile]
add_all_facet_sources.control.opts.inputkeys               =   [file1,file2]
add_all_facet_sources.argument.flags                       =   [file1,file2,DATA,DATA,FACET_DATA_ALL,add]

{% if not is_patch and not skip_facet_imaging %}
# For normal (non-patch) facets, we need to phase shift the empty data, add the
# calibrator source, and average

# shift full-res data to calibrator position and average in frequency, length = nfiles
shift_cal.control.type                                     =   dppp
shift_cal.control.opts.mapfiles_in                         =   [create_ms_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
shift_cal.control.opts.inputkeys                           =   [msin,sourcedb,parmdb]
shift_cal.argument.numthreads                              =   {{ max_cpus_per_io_proc_nfiles }}
shift_cal.argument.msin.datacolumn                         =   {{ subtracted_data_colname }}
shift_cal.argument.msout.overwrite                         =   True
shift_cal.argument.msout.writefullresflag                  =   False
shift_cal.argument.local_scratch_dir                       =   {{ local_dir }}
shift_cal.argument.steps                                   =   [shift,add,avg]
shift_cal.argument.shift.type                              =   phaseshifter
shift_cal.argument.shift.phasecenter                       =   [{{ ra }}deg, {{ dec }}deg]
shift_cal.argument.add.type                                =   predict
shift_cal.argument.add.sourcedb                            =   sourcedb
shift_cal.argument.add.operation                           =   add
shift_cal.argument.add.applycal.parmdb                     =   parmdb
shift_cal.argument.avg.type                                =   squash
shift_cal.argument.avg.freqstep                            =   {{ facetselfcal_freqstep }}
shift_cal.argument.avg.timestep                            =   1

{% else %}

# For patches, we simply need to average the FACET_DATA_ALL column of the        // length = nfiles
# shift_empty datasets (since a patch has the same region for all sources as for
# the calibrator). Even though we don't phase shift here, we reuse the step name
# for simplicity
shift_cal.control.type                                     =   dppp
shift_cal.control.opts.mapfile_in                          =   shift_empty.output.mapfile
shift_cal.control.opts.inputkey                            =   msin
shift_cal.argument.numthreads                              =   {{ max_cpus_per_io_proc_nfiles }}
shift_cal.argument.msin.datacolumn                         =   FACET_DATA_ALL
shift_cal.argument.msout.overwrite                         =   True
shift_cal.argument.msout.writefullresflag                  =   False
shift_cal.argument.local_scratch_dir                       =   {{ local_dir }}
shift_cal.argument.steps                                   =   [avg]
shift_cal.argument.avg.type                                =   squash
shift_cal.argument.avg.freqstep                            =   {{ facetselfcal_freqstep }}
shift_cal.argument.avg.timestep                            =   1
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile_data.control.kind                =   plugin
create_compressed_mapfile_data.control.type                =   compressMapfile
create_compressed_mapfile_data.control.mapfile_in          =   shift_cal.output.mapfile
create_compressed_mapfile_data.control.mapfile_dir         =   input.output.mapfile_dir
create_compressed_mapfile_data.control.filename            =   concat_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes * num_cal_blocks
sort_into_Groups.control.type                              =   sort_times_into_freqGroups
sort_into_Groups.argument.flags                            =   [create_compressed_mapfile_data.output.mapfile]
sort_into_Groups.argument.filename                         =   sorted_groups.mapfile
sort_into_Groups.argument.mapfile_dir                      =   input.output.mapfile_dir
sort_into_Groups.argument.hosts                            =   {{ hosts }}
sort_into_Groups.argument.stepname                         =   sort_into_Groups
{% if num_cal_blocks > 1 %}
sort_into_Groups.argument.numSB                            =   {{ num_bands_per_cal_block }}
{% endif %}

# convert the output of sort_into_Groups into usable mapfiles, len = 1 / (ntimes * num_cal_blocks)
sort_into_Groups_maps.control.kind                         =   plugin
sort_into_Groups_maps.control.type                         =   mapfilenamesFromMapfiles
sort_into_Groups_maps.control.mapfile_groupmap             =   sort_into_Groups.output.groupmapfile.mapfile
sort_into_Groups_maps.control.mapfile_filesmap             =   sort_into_Groups.output.mapfile.mapfile

# concat data in frequency, length = ntimes * num_cal_blocks
concat_data.control.type                                   =   dppp
concat_data.control.mapfile_out                            =   sort_into_Groups_maps.output.groupmap
concat_data.control.mapfile_in                             =   sort_into_Groups_maps.output.filesmap
concat_data.control.inputkey                               =   msin
concat_data.argument.numthreads                            =   {{ max_cpus_per_io_proc_ntimes }}
concat_data.argument.msin.datacolumn                       =   DATA
concat_data.argument.msin.missingdata                      =   True
concat_data.argument.msin.orderms                          =   False
concat_data.argument.msout.overwrite                       =   True
concat_data.argument.msout.writefullresflag                =   False
concat_data.argument.local_scratch_dir                     =   {{ local_dir }}
concat_data.argument.steps                                 =   []

{% if pre_average %}
# re-group shift_cal mapfile to have one group per band, length = nbands
regroup_shift_cal.control.kind                             =   plugin
regroup_shift_cal.control.type                             =   reGroupMapfile
regroup_shift_cal.control.mapfile_in                       =   shift_cal.output.mapfile
regroup_shift_cal.control.mapfile_groups                   =   create_msmulti_map.output.mapfile
regroup_shift_cal.control.mapfile_dir                      =   input.output.mapfile_dir
regroup_shift_cal.control.filename                         =   re_grouped_shift_cal.mapfile

# re-group dir-independent parmdb mapfile to have one group per band, length = nbands
regroup_parmdb.control.kind                                =   plugin
regroup_parmdb.control.type                                =   reGroupMapfile
regroup_parmdb.control.mapfile_in                          =   create_parmdb_map.output.mapfile
regroup_parmdb.control.mapfile_groups                      =   create_msmulti_map.output.mapfile
regroup_parmdb.control.check_basename                      =   False
regroup_parmdb.control.mapfile_dir                         =   input.output.mapfile_dir
regroup_parmdb.control.filename                            =   re_grouped_parmdb.mapfile

# Do the baseline-dependent preaveraging, length = nbands
# overwrite the WEIGHT_SPECTRUM column
pre_average.control.type                                   =   pre_average
pre_average.control.mapfiles_in                            =   [regroup_shift_cal.output.mapfile,regroup_parmdb.output.mapfile]
pre_average.control.inputkeys                              =   [datafiles,parmdbs]
pre_average.argument.flags                                 =   [datafiles,parmdbs,DATA,BLAVG_DATA,BLAVG_WEIGHT_SPECTRUM,{{ target_rms_rad }}]

# make mapfile for concatenated preaveraged data, length = ntimes * num_cal_blocks
make_blavg_data_mapfile.control.kind                       =  plugin
make_blavg_data_mapfile.control.type                       =  createMapfile
make_blavg_data_mapfile.control.method                     =  add_suffix_to_file
make_blavg_data_mapfile.control.mapfile_in                 =  sort_into_Groups_maps.output.groupmap
make_blavg_data_mapfile.control.add_suffix_to_file         =  "_blavg.ms"
make_blavg_data_mapfile.control.mapfile_dir                =  input.output.mapfile_dir
make_blavg_data_mapfile.control.filename                   =  make_blavg_data.mapfile

# switch "normal" weights with block-average weights, length = nfiles
switch_weights_col_shift_cal1.control.type                 =   switch_columns
switch_weights_col_shift_cal1.control.mapfile_in           =   shift_cal.output.mapfile
switch_weights_col_shift_cal1.control.inputkey             =   msfiles
switch_weights_col_shift_cal1.argument.flags               =   [msfiles,WEIGHT_SPECTRUM,{{ blavg_weight_column }}]

# Concat the preaveraged data (and weights), length = ntimes * num_cal_blocks
concat_blavg_data.control.type                             =   dppp
concat_blavg_data.control.mapfile_out                      =   make_blavg_data_mapfile.output.mapfile
concat_blavg_data.control.mapfile_in                       =   sort_into_Groups_maps.output.filesmap
concat_blavg_data.control.inputkey                         =   msin
concat_blavg_data.argument.numthreads                      =   {{ max_cpus_per_node }}
concat_blavg_data.argument.msin.datacolumn                 =   BLAVG_DATA
concat_blavg_data.argument.msin.missingdata                =   True
concat_blavg_data.argument.msin.orderms                    =   False
concat_blavg_data.argument.msout.overwrite                 =   True
concat_blavg_data.argument.msout.writefullresflag          =   False
concat_blavg_data.argument.local_scratch_dir               =   {{ local_dir }}
concat_blavg_data.argument.steps                           =   []

# switch "normal" weights with block-average weights, length = nfiles
switch_weights_col_shift_cal2.control.type                 =   switch_columns
switch_weights_col_shift_cal2.control.mapfile_in           =   shift_cal.output.mapfile
switch_weights_col_shift_cal2.control.inputkey             =   msfiles
switch_weights_col_shift_cal2.argument.flags               =   [msfiles,WEIGHT_SPECTRUM,{{ blavg_weight_column }}]

# Copy BLAVG_DATA, length = ntimes * num_cal_blocks
copy_column1.control.type                                  =   copy_column
copy_column1.control.mapfiles_in                           =   [concat_blavg_data.output.mapfile,concat_data.output.mapfile]
copy_column1.control.inputkeys                             =   [blavgfile,datafile]
copy_column1.argument.flags                                =   [blavgfile,datafile,DATA,BLAVG_DATA]

# Copy BLAVG_WEIGHT_SPECTRUM, length = ntimes * num_cal_blocks
copy_column2.control.type                                  =   copy_column
copy_column2.control.mapfiles_in                           =   [concat_blavg_data.output.mapfile,concat_data.output.mapfile]
copy_column2.control.inputkeys                             =   [blavgfile,datafile]
copy_column2.argument.flags                                =   [blavgfile,datafile,WEIGHT_SPECTRUM,{{ blavg_weight_column }}]
{% endif %}

# add imaging columns to concatenated data MSs, length = ntimes * num_cal_blocks
add_imaging_cols.control.type                              =   add_imaging_columns
add_imaging_cols.control.mapfile_in                        =   concat_data.output.mapfile
add_imaging_cols.control.inputkey                          =   msfile
add_imaging_cols.argument.flags                            =   [msfile]

# make compressed mapfile for concatenated data MSs, length = 1
concat_data_compressed_mapfile.control.kind                =   plugin
concat_data_compressed_mapfile.control.type                =   compressMapfile
concat_data_compressed_mapfile.control.mapfile_in          =   concat_data.output.mapfile
concat_data_compressed_mapfile.control.mapfile_dir         =   input.output.mapfile_dir
concat_data_compressed_mapfile.control.filename            =   concat_chunks_input.mapfile

# virtual concat of time/cal-chunks, length = 1
concat_chunks.control.type                                 =   virtual_concat
concat_chunks.control.mapfile_in                           =   concat_data_compressed_mapfile.output.mapfile
concat_chunks.control.inputkey                             =   msfiles
concat_chunks.control.outputkey                            =   msconcat
concat_chunks.argument.flags                               =   [msfiles,msconcat]

########## start of first round of selfcal (20" resolution)

########## start of first round of selfcal

# apply dir-independent calibration and average, length = nfiles
average0.control.type                                      =   dppp
average0.control.opts.mapfiles_in                          =   [shift_cal.output.mapfile,create_parmdb_map.output.mapfile]
average0.control.opts.inputkeys                            =   [msin,parmdb]
average0.argument.numthreads                               =   {{ max_cpus_per_io_proc_nfiles }}
average0.argument.msin.datacolumn                          =   DATA
average0.argument.msout.overwrite                          =   True
average0.argument.msout.writefullresflag                   =   False
average0.argument.local_scratch_dir                        =   {{ local_dir }}
average0.argument.steps                                    =   [correct,avg]
average0.argument.correct.type                             =   applycal
average0.argument.correct.parmdb                           =   parmdb
average0.argument.correct.correction                       =   gain
average0.argument.correct.invert                           =   True
average0.argument.avg.type                                 =   squash
average0.argument.avg.freqstep                             =   1
average0.argument.avg.timestep                             =   {{ facetselfcal_timestep }}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile_avgdata.control.kind             =   plugin
create_compressed_mapfile_avgdata.control.type             =   compressMapfile
create_compressed_mapfile_avgdata.control.mapfile_in       =   average0.output.mapfile
create_compressed_mapfile_avgdata.control.mapfile_dir      =   input.output.mapfile_dir
create_compressed_mapfile_avgdata.control.filename         =   concat_avg_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes
sort_avg_into_Groups.control.type                          =   sort_times_into_freqGroups
sort_avg_into_Groups.argument.flags                        =   [create_compressed_mapfile_avgdata.output.mapfile]
sort_avg_into_Groups.argument.filename                     =   sorted_avg_groups.mapfile
sort_avg_into_Groups.argument.mapfile_dir                  =   input.output.mapfile_dir
sort_avg_into_Groups.argument.hosts                        =   {{ hosts }}
sort_avg_into_Groups.argument.stepname                     =   sort_avg_into_Groups

# convert the output of sort_into_Groups into usable mapfiles, len = 1 / ntimes
sort_avg_into_Groups_maps.control.kind                     =   plugin
sort_avg_into_Groups_maps.control.type                     =   mapfilenamesFromMapfiles
sort_avg_into_Groups_maps.control.mapfile_groupmap         =   sort_avg_into_Groups.output.groupmapfile.mapfile
sort_avg_into_Groups_maps.control.mapfile_filesmap         =   sort_avg_into_Groups.output.mapfile.mapfile

# concat averaged data in frequency, length = ntimes
concat_avgdata.control.type                                =   dppp
concat_avgdata.control.mapfile_out                         =   sort_avg_into_Groups_maps.output.groupmap
concat_avgdata.control.mapfile_in                          =   sort_avg_into_Groups_maps.output.filesmap
concat_avgdata.control.inputkey                            =   msin
concat_avgdata.argument.numthreads                         =   {{ max_cpus_per_io_proc_ntimes }}
concat_avgdata.argument.msin.datacolumn                    =   DATA
concat_avgdata.argument.msin.missingdata                   =   True
concat_avgdata.argument.msin.orderms                       =   False
concat_avgdata.argument.msout.overwrite                    =   True
concat_avgdata.argument.msout.writefullresflag             =   False
concat_avgdata.argument.local_scratch_dir                  =   {{ local_dir }}
concat_avgdata.argument.steps                              =   []

# make compressed mapfile for averaged data MSs, length = 1
create_compressed_mapfile0.control.kind                    =   plugin
create_compressed_mapfile0.control.type                    =   compressMapfile
create_compressed_mapfile0.control.mapfile_in              =   concat_avgdata.output.mapfile
create_compressed_mapfile0.control.mapfile_dir             =   input.output.mapfile_dir
create_compressed_mapfile0.control.filename                =   concat0_input.mapfile

# virtual concat of averaged time-steps, length = 1
concat0.control.type                                       =   virtual_concat
concat0.control.mapfile_in                                 =   create_compressed_mapfile0.output.mapfile
concat0.control.inputkey                                   =   msfiles
concat0.control.outputkey                                  =   msconcat
concat0.argument.flags                                     =   [msfiles,msconcat]

# make a mask using user-supplied region (if any), length = 1
premask_selfcal.control.type                               =   make_clean_mask
premask_selfcal.control.mapfile_in                         =   concat0.output.mapfile
premask_selfcal.control.inputkey                           =   imagefile
premask_selfcal.control.outputkey                          =   maskfile
premask_selfcal.argument.flags                             =   [imagefile,maskfile]
premask_selfcal.argument.img_format                        =   fits
premask_selfcal.argument.pad_to_size                       =   {{ cal_imsize }}
premask_selfcal.argument.skip_source_detection             =   True
premask_selfcal.argument.vertices_file                     =   {{ vertices_file }}
premask_selfcal.argument.reference_ra_deg                  =   {{ ra }}
premask_selfcal.argument.reference_dec_deg                 =   {{ dec }}
premask_selfcal.argument.cellsize_deg                      =   {{ cellsize_selfcal_deg }}
premask_selfcal.argument.region_file                       =   {{ region_selfcal }}
premask_selfcal.argument.make_blank_image                  =   True

# image the virtual concatenated data with wsclean, length = 1
wsclean_image01.control.type                               =   wsclean
wsclean_image01.control.mapfiles_in                        =   [concat0.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image01.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image01.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image01.argument.fitsmask                          =   fitsmask
wsclean_image01.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image01.argument.niter                             =   1000
wsclean_image01.argument.threshold                         =   0.0
wsclean_image01.argument.pol                               =   I
wsclean_image01.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image01.argument.mgain                             =   0.6
wsclean_image01.argument.cleanborder                       =   0
wsclean_image01.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image01.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image01.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image01.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image01.argument.j                                 =   {{ max_cpus_per_proc_single }}
wsclean_image01.argument.tempdir                           =   {{ local_dir }}
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image01.argument.deconvolution-channels            =   3
wsclean_image01.argument.fit-spectral-log-pol              =   2
{% endif %}
wsclean_image01.argument.weighting-rank-filter             =   3
wsclean_image01.argument.taper-gaussian                    =   20arcsec
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image01.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map01.control.kind                         =   plugin
create_imagebase_map01.control.type                         =   trimMapfile
create_imagebase_map01.control.mapfile_in                   =   wsclean_image01.output.wsclean_image01-image.fits.mapfile
create_imagebase_map01.control.trim                         =   -
create_imagebase_map01.control.mapfile_dir                  =   input.output.mapfile_dir
create_imagebase_map01.control.filename                     =   wsclean_image01_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile0.control.kind                       =   plugin
adjust_wsclean_mapfile0.control.type                       =   appendMapfile
adjust_wsclean_mapfile0.control.mapfile_in                 =   create_imagebase_map01.output.mapfile
adjust_wsclean_mapfile0.control.append                     =   {{ wsclean_suffix }}
adjust_wsclean_mapfile0.control.mapfile_dir                =   input.output.mapfile_dir
adjust_wsclean_mapfile0.control.filename                   =   wsclean_image01_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask0.control.type                                         =   make_clean_mask
mask0.control.mapfile_in                                   =   adjust_wsclean_mapfile0.output.mapfile
mask0.control.inputkey                                     =   imagefile
mask0.control.outputkey                                    =   maskfile
mask0.argument.flags                                       =   [imagefile,maskfile]
mask0.argument.region_file                                 =   {{ region_selfcal }}
mask0.argument.threshpix                                   =   10
mask0.argument.threshisl                                   =   6
mask0.argument.iterate_threshold                           =   True
mask0.argument.atrous_do                                   =   {{ atrous_do }}
mask0.argument.rmsbox                                      =   (120,30)
mask0.argument.rmsbox_bright                               =   (120,30)
mask0.argument.adaptive_rmsbox                             =   True
mask0.argument.trim_by                                     =   0.4
mask0.argument.img_format                                  =   fits
mask0.argument.threshold_format                            =   str_with_units
mask0.argument.use_adaptive_threshold                      =   {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image02.control.type                               =   wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image02.control.mapfiles_in                        =   [concat0.output.mapfile,mask0.output.mapfile,mask0.output.threshold_5sig.mapfile]
wsclean_image02.control.inputkeys                          =   [msfile,fitsmask,threshold]
wsclean_image02.argument.threshold                         =   threshold
wsclean_image02.argument.niter                             =   10000
{% else %}
wsclean_image02.control.mapfiles_in                        =   [concat0.output.mapfile,mask0.output.mapfile]
wsclean_image02.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image02.argument.threshold                         =   0.0
wsclean_image02.argument.niter                             =   1000
{% endif %}
wsclean_image02.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image02.argument.fitsmask                          =   fitsmask
wsclean_image02.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image02.argument.pol                               =   I
wsclean_image02.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image02.argument.mgain                             =   0.6
wsclean_image02.argument.cleanborder                       =   0
wsclean_image02.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image02.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image02.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image02.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image02.argument.j                                 =   {{ max_cpus_per_proc_single }}
wsclean_image02.argument.tempdir                           =   {{ local_dir }}
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image02.argument.deconvolution-channels            =   3
wsclean_image02.argument.fit-spectral-log-pol              =   2
{% endif %}
wsclean_image02.argument.weighting-rank-filter             =   3
wsclean_image02.argument.taper-gaussian                    =   20arcsec
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image02.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map02.control.kind                        =   plugin
create_imagebase_map02.control.type                        =   trimMapfile
create_imagebase_map02.control.mapfile_in                  =   wsclean_image02.output.wsclean_image02-image.fits.mapfile
create_imagebase_map02.control.trim                        =   -
create_imagebase_map02.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map02.control.filename                    =   wsclean_image02_image_rootname.mapfile

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model0_mapfile.control.kind                =   plugin
create_expanded_model0_mapfile.control.type                =   expandMapfile
create_expanded_model0_mapfile.control.mapfile_in          =   create_imagebase_map02.output.mapfile
create_expanded_model0_mapfile.control.mapfile_to_match    =   concat_data.output.mapfile
create_expanded_model0_mapfile.control.mapfile_dir         =   input.output.mapfile_dir
create_expanded_model0_mapfile.control.filename            =   expand_wsclean_model0.mapfile

# predict model visibilities, length = ntimes
wsclean_ft0.control.type                                   =   wsclean_ft
wsclean_ft0.control.mapfiles_in                            =   [concat_data.output.mapfile,create_expanded_model0_mapfile.output.mapfile]
wsclean_ft0.control.inputkeys                              =   [msfile,name]
wsclean_ft0.argument.flags                                 =   [-predict,msfile]
wsclean_ft0.argument.size                                  =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_ft0.argument.scale                                 =   {{ cellsize_selfcal_deg }}
wsclean_ft0.argument.mem                                   =   {{ max_percent_memory_per_proc_ntimes }}
wsclean_ft0.argument.channelsout                           =   {{ wsclean_nchannels_selfcal }}
wsclean_ft0.argument.j                                     =   {{ max_cpus_per_proc_ntimes }}
wsclean_ft0.argument.tempdir                               =   {{ local_dir }}

# switch "normal" weights with block-average weights, length = ntimes * num_cal_blocks
switch_weights_col1.control.type                           =   switch_columns
switch_weights_col1.control.mapfile_in                     =   concat_data.output.mapfile
switch_weights_col1.control.inputkey                       =   msfiles
switch_weights_col1.argument.flags                         =   [msfiles,WEIGHT_SPECTRUM,{{ blavg_weight_column }}]

# generate mapfile for the fast-phase parmDBs generated in the solve_phaseonly steps, length = ntimes * num_cal_blocks
make_fast_phase_parmdb_map.control.kind                    =  plugin
make_fast_phase_parmdb_map.control.type                    =  createMapfile
make_fast_phase_parmdb_map.control.method                  =  add_suffix_to_file
make_fast_phase_parmdb_map.control.mapfile_in              =  concat_data.output.mapfile
make_fast_phase_parmdb_map.control.add_suffix_to_file      =  /instrument
make_fast_phase_parmdb_map.control.mapfile_dir             =  input.output.mapfile_dir
make_fast_phase_parmdb_map.control.filename                =  fast_parmdb.mapfile

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs1.control.type                               =   remove_file
remove_parmdbs1.control.mapfile_in                         =   make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs1.control.inputkey                           =   parmdb
remove_parmdbs1.argument.flags                             =   [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we write out a new dataset even though it's never used, as this
# is the only way to add a uv cut without affecting the original dataset. Once
# GainCal has a filter parameter, we can use dppp_inplace instead and save on I/O
solve_phaseonly1.control.type                              =   dppp
solve_phaseonly1.control.mapfiles_in                       =   [concat_data.output.mapfile,make_fast_phase_parmdb_map.output.mapfile]
solve_phaseonly1.control.inputkeys                         =   [msin,parmdb]
solve_phaseonly1.argument.numthreads                       =   {{ max_cpus_per_io_proc_ntimes }}
solve_phaseonly1.argument.msin.datacolumn                  =   {{ data_column }}
solve_phaseonly1.argument.msout.overwrite                  =   True
solve_phaseonly1.argument.msout.writefullresflag           =   False
solve_phaseonly1.argument.local_scratch_dir                =   {{ local_dir }}
solve_phaseonly1.argument.steps                            =   [uvcut,solvetec]
solve_phaseonly1.argument.uvcut.type                       =   uvwflagger
solve_phaseonly1.argument.uvcut.uvlambdamin                =   {{ solve_min_uv_lambda }}
solve_phaseonly1.argument.solvetec.type                    =   gaincal
solve_phaseonly1.argument.solvetec.caltype                 =   tec
solve_phaseonly1.argument.solvetec.parmdb                  =   parmdb
solve_phaseonly1.argument.solvetec.usemodelcolumn          =   True
solve_phaseonly1.argument.solvetec.solint                  =   {{ solint_time_p }}
solve_phaseonly1.argument.solvetec.nchan                   =   {{ solint_freq_a }}

# switch the weights back, length = ntimes * num_cal_blocks
switch_weights_col2.control.type                           =   switch_columns
switch_weights_col2.control.mapfile_in                     =   concat_data.output.mapfile
switch_weights_col2.control.inputkey                       =   msfiles
switch_weights_col2.argument.flags                         =   [msfiles,WEIGHT_SPECTRUM,{{ blavg_weight_column }}]

########## end of first round of selfcal (20" resolution)
########## start of second round of selfcal (10" resolution)

# apply the previous calibration and average, length = ntimes * num_cal_blocks
apply_phaseonly1.control.type                              =   dppp
apply_phaseonly1.control.opts.mapfiles_in                  =   [concat_data.output.mapfile,make_fast_phase_parmdb_map.output.mapfile]
apply_phaseonly1.control.opts.inputkeys                    =   [msin,parmdb]
apply_phaseonly1.argument.numthreads                       =   {{ max_cpus_per_io_proc_ntimes }}
apply_phaseonly1.argument.msin.datacolumn                  =   DATA
apply_phaseonly1.argument.msout.overwrite                  =   True
apply_phaseonly1.argument.msout.writefullresflag           =   False
apply_phaseonly1.argument.local_scratch_dir                =   {{ local_dir }}
apply_phaseonly1.argument.steps                            =   [correct_fast1,correct_fast2,avg]
apply_phaseonly1.argument.correct_fast1.type               =   applycal
apply_phaseonly1.argument.correct_fast1.parmdb             =   parmdb
apply_phaseonly1.argument.correct_fast1.correction         =   tec
apply_phaseonly1.argument.correct_fast1.invert             =   True
apply_phaseonly1.argument.correct_fast2.type               =   applycal
apply_phaseonly1.argument.correct_fast2.parmdb             =   parmdb
apply_phaseonly1.argument.correct_fast2.correction         =   commonscalarphase
apply_phaseonly1.argument.correct_fast2.invert             =   True
apply_phaseonly1.argument.avg.type                         =   squash
apply_phaseonly1.argument.avg.freqstep                     =   1
apply_phaseonly1.argument.avg.timestep                     =   {{ facetselfcal_timestep }}

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile1.control.kind                    =   plugin
create_compressed_mapfile1.control.type                    =   compressMapfile
create_compressed_mapfile1.control.mapfile_in              =   apply_phaseonly1.output.mapfile
create_compressed_mapfile1.control.mapfile_dir             =   input.output.mapfile_dir
create_compressed_mapfile1.control.filename                =   concat1_input.mapfile

# virtual concatenate of averaged data, length = 1
concat1.control.type                                       =   virtual_concat
concat1.control.mapfile_in                                 =   create_compressed_mapfile1.output.mapfile
concat1.control.inputkey                                   =   msfiles
concat1.control.outputkey                                  =   msconcat
concat1.argument.flags                                     =   [msfiles,msconcat]

# image the virtual concatenated data with wsclean, length = 1
wsclean_image11.control.type                               =   wsclean
wsclean_image11.control.mapfiles_in                        =   [concat1.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image11.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image11.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image11.argument.fitsmask                          =   fitsmask
wsclean_image11.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image11.argument.niter                             =   1000
wsclean_image11.argument.threshold                         =   0.0
wsclean_image11.argument.pol                               =   I
wsclean_image11.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image11.argument.mgain                             =   0.6
wsclean_image11.argument.cleanborder                       =   0
wsclean_image11.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image11.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image11.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image11.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image11.argument.j                                 =   {{ max_cpus_per_proc_single }}
wsclean_image11.argument.tempdir                           =   {{ local_dir }}
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image11.argument.deconvolution-channels            =   3
wsclean_image11.argument.fit-spectral-log-pol              =   2
{% endif %}
wsclean_image11.argument.weighting-rank-filter             =   3
wsclean_image11.argument.taper-gaussian                    =   10arcsec
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image11.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map11.control.kind                        =   plugin
create_imagebase_map11.control.type                        =   trimMapfile
create_imagebase_map11.control.mapfile_in                  =   wsclean_image11.output.wsclean_image11-image.fits.mapfile
create_imagebase_map11.control.trim                        =   -
create_imagebase_map11.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map11.control.filename                    =   wsclean_image11_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile11.control.kind                      =   plugin
adjust_wsclean_mapfile11.control.type                      =   appendMapfile
adjust_wsclean_mapfile11.control.mapfile_in                =   create_imagebase_map11.output.mapfile
adjust_wsclean_mapfile11.control.append                    =   {{ wsclean_suffix }}
adjust_wsclean_mapfile11.control.mapfile_dir               =   input.output.mapfile_dir
adjust_wsclean_mapfile11.control.filename                  =   wsclean_image11_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask1.control.type                                         =   make_clean_mask
mask1.control.mapfile_in                                   =   adjust_wsclean_mapfile11.output.mapfile
mask1.control.inputkey                                     =   imagefile
mask1.control.outputkey                                    =   maskfile
mask1.argument.flags                                       =   [imagefile,maskfile]
mask1.argument.region_file                                 =   {{ region_selfcal }}
mask1.argument.threshpix                                   =   8
mask1.argument.threshisl                                   =   7
mask1.argument.iterate_threshold                           =   True
mask1.argument.atrous_do                                   =   {{ atrous_do }}
mask1.argument.rmsbox                                      =   (80,20)
mask1.argument.adaptive_rmsbox                             =   True
mask1.argument.trim_by                                     =   0.4
mask1.argument.img_format                                  =   fits
mask1.argument.threshold_format                            =   str_with_units
mask1.argument.use_adaptive_threshold                      =   {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image12.control.type                               =   wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image12.control.mapfiles_in                        =   [concat1.output.mapfile,mask1.output.mapfile,mask1.output.threshold_5sig.mapfile]
wsclean_image12.control.inputkeys                          =   [msfile,fitsmask,threshold]
wsclean_image12.argument.threshold                         =   threshold
wsclean_image12.argument.niter                             =   10000
{% else %}
wsclean_image12.control.mapfiles_in                        =   [concat1.output.mapfile,mask1.output.mapfile]
wsclean_image12.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image12.argument.threshold                         =   0.0
wsclean_image12.argument.niter                             =   1000
{% endif %}
wsclean_image12.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image12.argument.fitsmask                          =   fitsmask
wsclean_image12.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image12.argument.pol                               =   I
wsclean_image12.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image12.argument.mgain                             =   0.6
wsclean_image12.argument.cleanborder                       =   0
wsclean_image12.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image12.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image12.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image12.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image12.argument.j                                 =   {{ max_cpus_per_proc_single }}
wsclean_image12.argument.tempdir                           =   {{ local_dir }}
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image12.argument.deconvolution-channels            =   3
wsclean_image12.argument.fit-spectral-log-pol              =   2
{% endif %}
wsclean_image12.argument.weighting-rank-filter             =   3
wsclean_image12.argument.taper-gaussian                    =   10arcsec
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image12.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map12.control.kind                        =   plugin
create_imagebase_map12.control.type                        =   trimMapfile
create_imagebase_map12.control.mapfile_in                  =   wsclean_image12.output.wsclean_image12-image.fits.mapfile
create_imagebase_map12.control.trim                        =   -
create_imagebase_map12.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map12.control.filename                    =   wsclean_image12_image_rootname.mapfile

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model1_mapfile.control.kind                =   plugin
create_expanded_model1_mapfile.control.type                =   expandMapfile
create_expanded_model1_mapfile.control.mapfile_in          =   create_imagebase_map12.output.mapfile
create_expanded_model1_mapfile.control.mapfile_to_match    =   concat_data.output.mapfile
create_expanded_model1_mapfile.control.mapfile_dir         =   input.output.mapfile_dir
create_expanded_model1_mapfile.control.filename            =   expand_wsclean_model1.mapfile

# predict model visibilities, length = ntimes
wsclean_ft1.control.type                                   =   wsclean_ft
wsclean_ft1.control.mapfiles_in                            =   [concat_data.output.mapfile,create_expanded_model1_mapfile.output.mapfile]
wsclean_ft1.control.inputkeys                              =   [msfile,name]
wsclean_ft1.argument.flags                                 =   [-predict,msfile]
wsclean_ft1.argument.size                                  =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_ft1.argument.scale                                 =   {{ cellsize_selfcal_deg }}
wsclean_ft1.argument.mem                                   =   {{ max_percent_memory_per_proc_ntimes }}
wsclean_ft1.argument.channelsout                           =   {{ wsclean_nchannels_selfcal }}
wsclean_ft1.argument.j                                     =   {{ max_cpus_per_proc_ntimes }}
wsclean_ft1.argument.tempdir                               =   {{ local_dir }}

# switch "normal" weights with block-average weigthts, length = ntimes * num_cal_blocks
switch_weights_col3.control.type                           =   switch_columns
switch_weights_col3.control.mapfile_in                     =   concat_data.output.mapfile
switch_weights_col3.control.inputkey                       =   msfiles
switch_weights_col3.argument.flags                         =   [msfiles,WEIGHT_SPECTRUM,{{ blavg_weight_column }}]

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs2.control.type                               =   remove_file
remove_parmdbs2.control.mapfile_in                         =   make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs2.control.inputkey                           =   parmdb
remove_parmdbs2.argument.flags                             =   [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we write out a new dataset even though it's never used, as this
# is the only way to add a uv cut without affecting the original dataset. Once
# GainCal has a filter parameter, we can use dppp_inplace instead and save on I/O
solve_phaseonly2.control.type                              =   dppp
solve_phaseonly2.control.mapfiles_in                       =   [concat_data.output.mapfile,make_fast_phase_parmdb_map.output.mapfile]
solve_phaseonly2.control.inputkeys                         =   [msin,parmdb]
solve_phaseonly2.argument.numthreads                       =   {{ max_cpus_per_io_proc_ntimes }}
solve_phaseonly2.argument.msin.datacolumn                  =   {{ data_column }}
solve_phaseonly2.argument.msout.overwrite                  =   True
solve_phaseonly2.argument.msout.writefullresflag           =   False
solve_phaseonly2.argument.local_scratch_dir                =   {{ local_dir }}
solve_phaseonly2.argument.steps                            =   [uvcut,solvetec]
solve_phaseonly2.argument.uvcut.type                       =   uvwflagger
solve_phaseonly2.argument.uvcut.uvlambdamin                =   {{ solve_min_uv_lambda }}
solve_phaseonly2.argument.solvetec.type                    =   gaincal
solve_phaseonly2.argument.solvetec.caltype                 =   tec
solve_phaseonly2.argument.solvetec.parmdb                  =   parmdb
solve_phaseonly2.argument.solvetec.usemodelcolumn          =   True
solve_phaseonly2.argument.solvetec.solint                  =   {{ solint_time_p }}
solve_phaseonly2.argument.solvetec.nchan                   =   {{ solint_freq_a }}

# switch the weigthts back, length = ntimes * num_cal_blocks
switch_weights_col4.control.type                           =   switch_columns
switch_weights_col4.control.mapfile_in                     =   concat_data.output.mapfile
switch_weights_col4.control.inputkey                       =   msfiles
switch_weights_col4.argument.flags                         =   [msfiles,WEIGHT_SPECTRUM,{{ blavg_weight_column }}]

# apply the previous calibration, length = ntimes * num_cal_blocks
apply_phaseonly2.control.type                              =   dppp_inplace
apply_phaseonly2.control.opts.mapfiles_in                  =   [concat_data.output.mapfile,make_fast_phase_parmdb_map.output.mapfile]
apply_phaseonly2.control.opts.inputkeys                    =   [msin,parmdb]
apply_phaseonly2.argument.numthreads                       =   {{ max_cpus_per_proc_ntimes }}
apply_phaseonly2.argument.msin.datacolumn                  =   DATA
apply_phaseonly2.argument.msout                            =   .
apply_phaseonly2.argument.msout.datacolumn                 =   CORRECTED_DATA
apply_phaseonly2.argument.steps                            =   [correct_fast1,correct_fast2]
apply_phaseonly2.argument.correct_fast1.type               =   applycal
apply_phaseonly2.argument.correct_fast1.parmdb             =   parmdb
apply_phaseonly2.argument.correct_fast1.correction         =   tec
apply_phaseonly2.argument.correct_fast1.invert             =   True
apply_phaseonly2.argument.correct_fast2.type               =   applycal
apply_phaseonly2.argument.correct_fast2.parmdb             =   parmdb
apply_phaseonly2.argument.correct_fast2.correction         =   commonscalarphase
apply_phaseonly2.argument.correct_fast2.invert             =   True

########## end of second round of selfcal (10" resolution)
########## start of phase-only selfcal loop

# loop step
loop_phasecal.control.kind                                 =   loop
loop_phasecal.control.type                                 =   conditional
loop_phasecal.control.loopcount                            =   {{ loopcount }}
loop_phasecal.control.loopsteps                            =   [average2,create_compressed_mapfile2,concat2,delete_image1,wsclean_image21,create_imagebase_map21,adjust_wsclean_mapfile21,mask2,wsclean_image22,create_imagebase_map22,create_expanded_model2_mapfile,wsclean_ft2,{% if pre_average %}switch_weights_col5,{% endif %}remove_parmdbs11,solve_ampphase11,{% if pre_average %}switch_weights_col6,{% endif %}apply_ampphase11,adjust_casa_mapfile_phaseloop,copy_image1,check_image1]

# average the output of the previous apply step, length = ntimes * num_cal_blocks
average2.control.type                                      =   dppp
average2.control.mapfile_in                                =   concat_data.output.mapfile
average2.control.inputkey                                  =   msin
average2.argument.numthreads                               =   {{ max_cpus_per_io_proc_ntimes }}
average2.argument.msin.datacolumn                          =   CORRECTED_DATA
average2.argument.msout.overwrite                          =   True
average2.argument.msout.writefullresflag                   =   False
average2.argument.local_scratch_dir                        =   {{ local_dir }}
average2.argument.steps                                    =   [avg]
average2.argument.avg.type                                 =   squash
average2.argument.avg.freqstep                             =   1
average2.argument.avg.timestep                             =   {{ facetselfcal_timestep }}

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile2.control.kind                    =   plugin
create_compressed_mapfile2.control.type                    =   compressMapfile
create_compressed_mapfile2.control.mapfile_in              =   apply_phaseonly2.output.mapfile
create_compressed_mapfile2.control.mapfile_dir             =   input.output.mapfile_dir
create_compressed_mapfile2.control.filename                =   concat2_input.mapfile

# virtual concatenate of averaged data, length = 1
concat2.control.type                                       =   virtual_concat
concat2.control.mapfile_in                                 =   create_compressed_mapfile2.output.mapfile
concat2.control.inputkey                                   =   msfiles
concat2.control.outputkey                                  =   msconcat
concat2.argument.flags                                     =   [msfiles,msconcat]

# delete image from previous selfcal step, length = 1
delete_image1.control.type                                 =   delete_image
delete_image1.control.mapfile_in                           =   create_model1_map.output.mapfile
delete_image1.control.inputkey                             =   imageroot
delete_image1.argument.flags                               =   [imageroot,loop_phasecal.output.counter,2]

# image the virtual concatenated data with wsclean, length = 1
wsclean_image21.control.type                               =   wsclean
wsclean_image21.control.mapfiles_in                        =   [concat2.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image21.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image21.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image21.argument.fitsmask                          =   fitsmask
wsclean_image21.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image21.argument.niter                             =   1000
wsclean_image21.argument.threshold                         =   0.0
wsclean_image21.argument.pol                               =   I
wsclean_image21.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image21.argument.mgain                             =   0.6
wsclean_image21.argument.cleanborder                       =   0
wsclean_image21.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image21.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image21.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image21.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image21.argument.j                                 =   {{ max_cpus_per_proc_single }}
wsclean_image21.argument.tempdir                           =   {{ local_dir }}
{% if not wsclean_selfcal_multiscale %}
wsclean_image21.argument.multiscale-scales                 =   0
{% endif %}
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image21.argument.deconvolution-channels            =   3
wsclean_image21.argument.fit-spectral-log-pol              =   2
{% endif %}
wsclean_image21.argument.weighting-rank-filter             =   3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image21.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map21.control.kind                        =   plugin
create_imagebase_map21.control.type                        =   trimMapfile
create_imagebase_map21.control.mapfile_in                  =   wsclean_image21.output.wsclean_image21-image.fits.mapfile
create_imagebase_map21.control.trim                        =   -
create_imagebase_map21.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map21.control.filename                    =   wsclean_image21_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile21.control.kind                      =   plugin
adjust_wsclean_mapfile21.control.type                      =   appendMapfile
adjust_wsclean_mapfile21.control.mapfile_in                =   create_imagebase_map21.output.mapfile
adjust_wsclean_mapfile21.control.append                    =   {{ wsclean_suffix }}
adjust_wsclean_mapfile21.control.mapfile_dir               =   input.output.mapfile_dir
adjust_wsclean_mapfile21.control.filename                  =   wsclean_image21_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask2.control.type                                         =   make_clean_mask
mask2.control.mapfile_in                                   =   adjust_wsclean_mapfile21.output.mapfile
mask2.control.inputkey                                     =   imagefile
mask2.control.outputkey                                    =   maskfile
mask2.argument.flags                                       =   [imagefile,maskfile]
mask2.argument.region_file                                 =   {{ region_selfcal }}
mask2.argument.threshpix                                   =   8
mask2.argument.threshisl                                   =   7
mask2.argument.iterate_threshold                           =   True
mask2.argument.atrous_do                                   =   {{ atrous_do }}
mask2.argument.rmsbox                                      =   (80,20)
mask2.argument.adaptive_rmsbox                             =   True
mask2.argument.trim_by                                     =   0.4
mask2.argument.img_format                                  =   fits
mask2.argument.threshold_format                            =   str_with_units
mask2.argument.use_adaptive_threshold                      =   {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image22.control.type                               =   wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image22.control.mapfiles_in                        =   [concat2.output.mapfile,mask2.output.mapfile,mask2.output.threshold_5sig.mapfile]
wsclean_image22.control.inputkeys                          =   [msfile,fitsmask,threshold]
wsclean_image22.argument.threshold                         =   threshold
wsclean_image22.argument.niter                             =   10000
{% else %}
wsclean_image22.control.mapfiles_in                        =   [concat2.output.mapfile,mask2.output.mapfile]
wsclean_image22.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image22.argument.threshold                         =   0.0
wsclean_image22.argument.niter                             =   1000
{% endif %}
wsclean_image22.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image22.argument.fitsmask                          =   fitsmask
wsclean_image22.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image22.argument.pol                               =   I
wsclean_image22.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image22.argument.mgain                             =   0.6
wsclean_image22.argument.cleanborder                       =   0
wsclean_image22.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image22.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image22.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image22.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image22.argument.j                                 =   {{ max_cpus_per_proc_single }}
wsclean_image22.argument.tempdir                           =   {{ local_dir }}
{% if not wsclean_selfcal_multiscale %}
wsclean_image22.argument.multiscale-scales                 =   0
{% endif %}
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image22.argument.deconvolution-channels            =   3
wsclean_image22.argument.fit-spectral-log-pol              =   2
{% endif %}
wsclean_image22.argument.weighting-rank-filter             =   3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image22.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map22.control.kind                        =   plugin
create_imagebase_map22.control.type                        =   trimMapfile
create_imagebase_map22.control.mapfile_in                  =   wsclean_image22.output.wsclean_image22-image.fits.mapfile
create_imagebase_map22.control.trim                        =   -
create_imagebase_map22.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map22.control.filename                    =   wsclean_image22_image_rootname.mapfile

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model2_mapfile.control.kind                =   plugin
create_expanded_model2_mapfile.control.type                =   expandMapfile
create_expanded_model2_mapfile.control.mapfile_in          =   create_imagebase_map22.output.mapfile
create_expanded_model2_mapfile.control.mapfile_to_match    =   concat_data.output.mapfile
create_expanded_model2_mapfile.control.mapfile_dir         =   input.output.mapfile_dir
create_expanded_model2_mapfile.control.filename            =   expand_wsclean_model1.mapfile

# predict model visibilities, length = ntimes
wsclean_ft2.control.type                                   =   wsclean_ft
wsclean_ft2.control.mapfiles_in                            =   [concat_data.output.mapfile,create_expanded_model2_mapfile.output.mapfile]
wsclean_ft2.control.inputkeys                              =   [msfile,name]
wsclean_ft2.argument.flags                                 =   [-predict,msfile]
wsclean_ft2.argument.size                                  =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_ft2.argument.scale                                 =   {{ cellsize_selfcal_deg }}
wsclean_ft2.argument.mem                                   =   {{ max_percent_memory_per_proc_ntimes }}
wsclean_ft2.argument.channelsout                           =   {{ wsclean_nchannels_selfcal }}
wsclean_ft2.argument.j                                     =   {{ max_cpus_per_proc_ntimes }}
wsclean_ft2.argument.tempdir                               =   {{ local_dir }}

# switch "normal" weights with block-average weigthts, length = ntimes * num_cal_blocks
switch_weights_col5.control.type                           =   switch_columns
switch_weights_col5.control.mapfile_in                     =   concat_data.output.mapfile
switch_weights_col5.control.inputkey                       =   msfiles
switch_weights_col5.argument.flags                         =   [msfiles,WEIGHT_SPECTRUM,{{ blavg_weight_column }}]

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs11.control.type                              =   remove_file
remove_parmdbs11.control.mapfile_in                        =   make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs11.control.inputkey                          =   parmdb
remove_parmdbs11.argument.flags                            =   [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we write out a new dataset even though it's never used, as this
# is the only way to add a uv cut without affecting the original dataset. Once
# GainCal has a filter parameter, we can use dppp_inplace instead and save on I/O
solve_ampphase11.control.type                              =   dppp
solve_ampphase11.control.mapfiles_in                       =   [concat_data.output.mapfile,make_fast_phase_parmdb_map.output.mapfile]
solve_ampphase11.control.inputkeys                         =   [msin,parmdb]
solve_ampphase11.argument.numthreads                       =   {{ max_cpus_per_io_proc_ntimes }}
solve_ampphase11.argument.msin.datacolumn                  =   {{ data_column }}
solve_ampphase11.argument.msout.overwrite                  =   True
solve_ampphase11.argument.msout.writefullresflag           =   False
solve_ampphase11.argument.local_scratch_dir                =   {{ local_dir }}
solve_ampphase11.argument.steps                            =   [uvcut,solvetec]
solve_ampphase11.argument.uvcut.type                       =   uvwflagger
solve_ampphase11.argument.uvcut.uvlambdamin                =   {{ solve_min_uv_lambda }}
solve_ampphase11.argument.solvetec.type                    =   gaincal
solve_ampphase11.argument.solvetec.caltype                 =   tec
solve_ampphase11.argument.solvetec.parmdb                  =   parmdb
solve_ampphase11.argument.solvetec.usemodelcolumn          =   True
solve_ampphase11.argument.solvetec.solint                  =   {{ solint_time_p }}
solve_ampphase11.argument.solvetec.nchan                   =   {{ solint_freq_a }}

# switch weights back, length = ntimes * num_cal_blocks
switch_weights_col6.control.type                           =   switch_columns
switch_weights_col6.control.mapfile_in                     =   concat_data.output.mapfile
switch_weights_col6.control.inputkey                       =   msfiles
switch_weights_col6.argument.flags                         =   [msfiles,WEIGHT_SPECTRUM,{{ blavg_weight_column }}]

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase11.control.type                              =   dppp_inplace
apply_ampphase11.control.opts.mapfiles_in                  =   [concat_data.output.mapfile,make_fast_phase_parmdb_map.output.mapfile]
apply_ampphase11.control.opts.inputkeys                    =   [msin,parmdb]
apply_ampphase11.argument.numthreads                       =   {{ max_cpus_per_proc_ntimes }}
apply_ampphase11.argument.msin.datacolumn                  =   DATA
apply_ampphase11.argument.msout                            =   .
apply_ampphase11.argument.msout.datacolumn                 =   CORRECTED_DATA
apply_ampphase11.argument.steps                            =   [correct_fast1,correct_fast2]
apply_ampphase11.argument.correct_fast1.type               =   applycal
apply_ampphase11.argument.correct_fast1.parmdb             =   parmdb
apply_ampphase11.argument.correct_fast1.correction         =   tec
apply_ampphase11.argument.correct_fast1.invert             =   True
apply_ampphase11.argument.correct_fast2.type               =   applycal
apply_ampphase11.argument.correct_fast2.parmdb             =   parmdb
apply_ampphase11.argument.correct_fast2.correction         =   commonscalarphase
apply_ampphase11.argument.correct_fast2.invert             =   True

# fiddle with the casa mapfiles, length = 1
adjust_casa_mapfile_phaseloop.control.kind                 =   plugin
adjust_casa_mapfile_phaseloop.control.type                 =   appendMapfile
adjust_casa_mapfile_phaseloop.control.mapfile_in           =   casa_image22.output.casa_image22.image.mapfile
adjust_casa_mapfile_phaseloop.control.append               =   {{ casa_suffix }}
adjust_casa_mapfile_phaseloop.control.mapfile_dir          =   input.output.mapfile_dir
adjust_casa_mapfile_phaseloop.control.filename             =   compare_image_input_new1.mapfile

# copy the output image so that we can compare it later, length = 1
copy_image1.control.type                                   =   copy_image
copy_image1.control.mapfile_in                             =   adjust_casa_mapfile_phaseloop.output.mapfile
copy_image1.control.inputkey                               =   image
copy_image1.argument.flags                                 =   [image,loop_phasecal.output.counter,2]

# compare the current and the previous image to see if we can stop the loop, length = 1
check_image1.control.type                                  =   compare_image_stats
check_image1.control.mapfiles_in                           =   [adjust_casa_mapfile_phaseloop.output.mapfile,copy_image1.output.previous_image.mapfile]
check_image1.control.inputkeys                             =   [image_new,image_prev]
check_image1.argument.flags                                =   [image_new,image_prev,loop_phasecal.output.counter,1.05]

###### end of phase-only selfcal loop
###### continue to amplitude calibration

# generate mapfile for the slow-gain parmDBs generated in the solve_ampphase12 step
make_slow_gain_parmdb_map.control.kind                     =  plugin
make_slow_gain_parmdb_map.control.type                     =  createMapfile
make_slow_gain_parmdb_map.control.method                   =  add_suffix_to_file
make_slow_gain_parmdb_map.control.mapfile_in               =  concat_data.output.mapfile
make_slow_gain_parmdb_map.control.add_suffix_to_file       =  /instrument_slow
make_slow_gain_parmdb_map.control.mapfile_dir              =  input.output.mapfile_dir
make_slow_gain_parmdb_map.control.filename                 =  slow_parmdb.mapfile

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs12.control.type                              =   remove_file
remove_parmdbs12.control.mapfile_in                        =   make_slow_gain_parmdb_map.output.mapfile
remove_parmdbs12.control.inputkey                          =   parmdb
remove_parmdbs12.argument.flags                            =   [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes * num_cal_blocks
# note: for now, we write out a new dataset even though it's never used, as this
# is the only way to add a uv cut without affecting the original dataset. Once
# GainCal has a filter parameter, we can use dppp_inplace instead and save on I/O
solve_ampphase12.control.type                              =   dppp
solve_ampphase12.control.mapfiles_in                       =   [concat_data.output.mapfile,make_slow_gain_parmdb_map.output.mapfile]
solve_ampphase12.control.inputkeys                         =   [msin,parmdb]
solve_ampphase12.argument.numthreads                       =   {{ max_cpus_per_io_proc_ntimes }}
solve_ampphase12.argument.msin.datacolumn                  =   CORRECTED_DATA
solve_ampphase12.argument.msout.overwrite                  =   True
solve_ampphase12.argument.msout.writefullresflag           =   False
solve_ampphase12.argument.local_scratch_dir                =   {{ local_dir }}
solve_ampphase12.argument.steps                            =   [uvcut,solvegain]
solve_ampphase12.argument.uvcut.type                       =   uvwflagger
solve_ampphase12.argument.uvcut.uvlambdamin                =   {{ solve_min_uv_lambda }}
solve_ampphase12.argument.solvegain.type                   =   gaincal
solve_ampphase12.argument.solvegain.caltype                =   {{ selfcal_caltype }}
solve_ampphase12.argument.solvegain.parmdb                 =   parmdb
solve_ampphase12.argument.solvegain.usemodelcolumn         =   True
solve_ampphase12.argument.solvegain.solint                 =   {{ solint_time_a }}
solve_ampphase12.argument.solvegain.nchan                  =   {{ solint_freq_a }}

# merge the parmDBs with the amplitude solutions into one, length = 1
merge_amp_parmdbs1.control.type                            =   merge_parmdbs_in_time
merge_amp_parmdbs1.control.mapfile_in                      =   concat_data_compressed_mapfile.output.mapfile
merge_amp_parmdbs1.control.inputkey                        =   mslist
merge_amp_parmdbs1.control.outputkey                       =   outparmdb
merge_amp_parmdbs1.argument.flags                          =   [mslist,instrument_slow,outparmdb]

# smooth the amplitues in the merged parmDB, length = 1
# smooth_amps uses only ANTENNA subtable of inputms, so it should work on virtual concatenated MS
smooth_amp1.control.type                                   =   {{ smooth_amps_task }}
smooth_amp1.control.mapfile_in                             =   merge_amp_parmdbs1.output.mapfile
smooth_amp1.control.inputkey                               =   ampparmdb
smooth_amp1.control.outputkey                              =   outparmdb
smooth_amp1.control.arguments                              =   [ampparmdb,outparmdb]

# expand the mapfile with the smoothd parmDB to all time-steps, length = ntimes * num_cal_blocks
expand_smoothed_amp1_parmdb_map.control.kind               =   plugin
expand_smoothed_amp1_parmdb_map.control.type               =   expandMapfile
expand_smoothed_amp1_parmdb_map.control.mapfile_in         =   smooth_amp1.output.mapfile
expand_smoothed_amp1_parmdb_map.control.mapfile_to_match   =   concat_data.output.mapfile
expand_smoothed_amp1_parmdb_map.control.mapfile_dir        =   input.output.mapfile_dir
expand_smoothed_amp1_parmdb_map.control.filename           =   expand_amp1_smoothed_parmdbs.mapfile

# apply the smoothed amplitudes and average, length = ntimes * num_cal_blocks
apply_amp1.control.type                                    =   dppp
apply_amp1.control.opts.mapfiles_in                        =   [concat_data.output.mapfile,expand_smoothed_amp1_parmdb_map.output.mapfile]
apply_amp1.control.opts.inputkeys                          =   [msin,parmdb]
apply_amp1.argument.numthreads                             =   {{ max_cpus_per_io_proc_ntimes }}
apply_amp1.argument.msin.datacolumn                        =   CORRECTED_DATA
apply_amp1.argument.msout.overwrite                        =   True
apply_amp1.argument.msout.writefullresflag                 =   False
apply_amp1.argument.local_scratch_dir                      =   {{ local_dir }}
apply_amp1.argument.steps                                  =   [correct_slow,avg]
apply_amp1.argument.correct_slow.type                      =   applycal
apply_amp1.argument.correct_slow.parmdb                    =   parmdb
apply_amp1.argument.correct_slow.invert                    =   True
apply_amp1.argument.avg.type                               =   squash
apply_amp1.argument.avg.freqstep                           =   1
apply_amp1.argument.avg.timestep                           =   {{ facetselfcal_timestep }}

########## end of third round of selfcal
########## start of fourth round of selfcal

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile3.control.kind                    =   plugin
create_compressed_mapfile3.control.type                    =   compressMapfile
create_compressed_mapfile3.control.mapfile_in              =   apply_amp1.output.mapfile
create_compressed_mapfile3.control.mapfile_dir             =   input.output.mapfile_dir
create_compressed_mapfile3.control.filename                =   concat3_input.mapfile

# virtual concatenate of averaged data, length = 1
concat3.control.type                                       =   virtual_concat
concat3.control.mapfile_in                                 =   create_compressed_mapfile3.output.mapfile
concat3.control.inputkey                                   =   msfiles
concat3.control.outputkey                                  =   msconcat
concat3.argument.flags                                     =   [msfiles,msconcat]

# image the virtual concatenated data with wsclean, length = 1
wsclean_image31.control.type                               =   wsclean
wsclean_image31.control.mapfiles_in                        =   [concat3.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image31.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image31.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image31.argument.fitsmask                          =   fitsmask
wsclean_image31.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image31.argument.niter                             =   1000
wsclean_image31.argument.threshold                         =   0.0
wsclean_image31.argument.pol                               =   I
wsclean_image31.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image31.argument.mgain                             =   0.6
wsclean_image31.argument.cleanborder                       =   0
wsclean_image31.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image31.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image31.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image31.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image31.argument.j                                 =   {{ max_cpus_per_proc_single }}
wsclean_image31.argument.tempdir                           =   {{ local_dir }}
{% if not wsclean_selfcal_multiscale %}
wsclean_image31.argument.multiscale-scales                 =   0
{% endif %}
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image31.argument.deconvolution-channels            =   3
wsclean_image31.argument.fit-spectral-log-pol              =   2
{% endif %}
wsclean_image31.argument.weighting-rank-filter             =   3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image31.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map31.control.kind                        =   plugin
create_imagebase_map31.control.type                        =   trimMapfile
create_imagebase_map31.control.mapfile_in                  =   wsclean_image31.output.wsclean_image31-image.fits.mapfile
create_imagebase_map31.control.trim                        =   -
create_imagebase_map31.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map31.control.filename                    =   wsclean_image31_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile31.control.kind                      =   plugin
adjust_wsclean_mapfile31.control.type                      =   appendMapfile
adjust_wsclean_mapfile31.control.mapfile_in                =   create_imagebase_map31.output.mapfile
adjust_wsclean_mapfile31.control.append                    =   {{ wsclean_suffix }}
adjust_wsclean_mapfile31.control.mapfile_dir               =   input.output.mapfile_dir
adjust_wsclean_mapfile31.control.filename                  =   wsclean_image31_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask3.control.type                                         =   make_clean_mask
mask3.control.mapfile_in                                   =   adjust_wsclean_mapfile31.output.mapfile
mask3.control.inputkey                                     =   imagefile
mask3.control.outputkey                                    =   maskfile
mask3.argument.flags                                       =   [imagefile,maskfile]
mask3.argument.region_file                                 =   {{ region_selfcal }}
mask3.argument.threshpix                                   =   10
mask3.argument.threshisl                                   =   10
mask3.argument.iterate_threshold                           =   True
mask3.argument.atrous_do                                   =   {{ atrous_do }}
mask3.argument.rmsbox                                      =   (80,20)
mask3.argument.adaptive_rmsbox                             =   True
mask3.argument.trim_by                                     =   0.4
mask3.argument.img_format                                  =   fits
mask3.argument.adaptive_thresh                             =   180
mask3.argument.threshold_format                            =   str_with_units
mask3.argument.use_adaptive_threshold                      =   {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image32.control.type                               =   wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image32.control.mapfiles_in                        =   [concat3.output.mapfile,mask3.output.mapfile,mask3.output.threshold_5sig.mapfile]
wsclean_image32.control.inputkeys                          =   [msfile,fitsmask,threshold]
wsclean_image32.argument.threshold                         =   threshold
wsclean_image32.argument.niter                             =   10000
{% else %}
wsclean_image32.control.mapfiles_in                        =   [concat3.output.mapfile,mask3.output.mapfile]
wsclean_image32.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image32.argument.threshold                         =   0.0
wsclean_image32.argument.niter                             =   1000
{% endif %}
wsclean_image32.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image32.argument.fitsmask                          =   fitsmask
wsclean_image32.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image32.argument.pol                               =   I
wsclean_image32.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image32.argument.mgain                             =   0.6
wsclean_image32.argument.cleanborder                       =   0
wsclean_image32.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image32.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image32.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image32.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image32.argument.j                                 =   {{ max_cpus_per_proc_single }}
wsclean_image32.argument.tempdir                           =   {{ local_dir }}
{% if not wsclean_selfcal_multiscale %}
wsclean_image32.argument.multiscale-scales                 =   0
{% endif %}
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image32.argument.deconvolution-channels            =   3
wsclean_image32.argument.fit-spectral-log-pol              =   2
{% endif %}
wsclean_image32.argument.weighting-rank-filter             =   3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image32.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

########## start of phase+amp selfcal loop

# loop step
loop_ampcal.control.kind                                   =   loop
loop_ampcal.control.type                                   =   conditional
loop_ampcal.control.loopcount                              =   {{ loopcount }}
loop_ampcal.control.loopsteps                              =   [create_imagebase_map32,create_expanded_model3_mapfile,wsclean_ft3,{% if pre_average %}switch_weights_col7,{% endif %}remove_parmdbs21,solve_ampphase21,{% if pre_average %}switch_weights_col8,{% endif %}apply_ampphase21,merge_phase_parmdbs,remove_parmdbs22,solve_ampphase22,merge_amp_parmdbs2,smooth_amp2,expand_smoothed_amp2_parmdb_map,apply_amp2,create_compressed_mapfile4,concat4,wsclean_image41,create_imagebase_map41,adjust_wsclean_mapfile41,mask4,wsclean_image42,create_imagebase_map42,adjust_wsclean_mapfile42,copy_image2,check_image2]

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map32.control.kind                        =   plugin
create_imagebase_map32.control.type                        =   trimMapfile
create_imagebase_map32.control.mapfile_in                  =   wsclean_image32.output.wsclean_image32-image.fits.mapfile
create_imagebase_map32.control.trim                        =   -
create_imagebase_map32.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map32.control.filename                    =   wsclean_image32_image_rootname.mapfile

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model3_mapfile.control.kind                =   plugin
create_expanded_model3_mapfile.control.type                =   expandMapfile
create_expanded_model3_mapfile.control.mapfile_in          =   create_imagebase_map32.output.mapfile
create_expanded_model3_mapfile.control.mapfile_to_match    =   concat_data.output.mapfile
create_expanded_model3_mapfile.control.mapfile_dir         =   input.output.mapfile_dir
create_expanded_model3_mapfile.control.filename            =   expand_wsclean_model1.mapfile

# predict model visibilities, length =  times
wsclean_ft3.control.type                                   =   wsclean_ft
wsclean_ft3.control.mapfiles_in                            =   [concat_data.output.mapfile,create_expanded_model3_mapfile.output.mapfile]
wsclean_ft3.control.inputkeys                              =   [msfile,name]
wsclean_ft3.argument.flags                                 =   [-predict,msfile]
wsclean_ft3.argument.size                                  =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_ft3.argument.scale                                 =   {{ cellsize_selfcal_deg }}
wsclean_ft3.argument.mem                                   =   {{ max_percent_memory_per_proc_ntimes }}
wsclean_ft3.argument.channelsout                           =   {{ wsclean_nchannels_selfcal }}
wsclean_ft3.argument.j                                     =   {{ max_cpus_per_proc_ntimes }}
wsclean_ft3.argument.tempdir                               =   {{ local_dir }}

# switch "normal" weights with block-average weigthts, length = ntimes * num_cal_blocks
switch_weights_col7.control.type                           =   switch_columns
switch_weights_col7.control.mapfile_in                     =   concat_data.output.mapfile
switch_weights_col7.control.inputkey                       =   msfiles
switch_weights_col7.argument.flags                         =   [msfiles,WEIGHT_SPECTRUM,{{ blavg_weight_column }}]

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs21.control.type                              =   remove_file
remove_parmdbs21.control.mapfile_in                        =   make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs21.control.inputkey                          =   parmdb
remove_parmdbs21.argument.flags                            =   [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we write out a new dataset even though it's never used, as this
# is the only way to add a uv cut without affecting the original dataset. Once
# GainCal has a filter parameter, we can use dppp_inplace instead and save on I/O
solve_ampphase21.control.type                              =   dppp
solve_ampphase21.control.mapfiles_in                       =   [concat_data.output.mapfile,make_fast_phase_parmdb_map.output.mapfile]
solve_ampphase21.control.inputkeys                         =   [msin,parmdb]
solve_ampphase21.argument.numthreads                       =   {{ max_cpus_per_io_proc_ntimes }}
solve_ampphase21.argument.msin.datacolumn                  =   {{ data_column }}
solve_ampphase21.argument.msout.overwrite                  =   True
solve_ampphase21.argument.msout.writefullresflag           =   False
solve_ampphase21.argument.local_scratch_dir                =   {{ local_dir }}
solve_ampphase21.argument.steps                            =   [uvcut,solvetec]
solve_ampphase21.argument.uvcut.type                       =   uvwflagger
solve_ampphase21.argument.uvcut.uvlambdamin                =   {{ solve_min_uv_lambda }}
solve_ampphase21.argument.solvetec.type                    =   gaincal
solve_ampphase21.argument.solvetec.caltype                 =   tec
solve_ampphase21.argument.solvetec.parmdb                  =   parmdb
solve_ampphase21.argument.solvetec.usemodelcolumn          =   True
solve_ampphase21.argument.solvetec.solint                  =   {{ solint_time_p }}
solve_ampphase21.argument.solvetec.nchan                   =   {{ solint_freq_a }}

# switch weights back, length = ntimes * num_cal_blocks
switch_weights_col8.control.type                           =   switch_columns
switch_weights_col8.control.mapfile_in                     =   concat_data.output.mapfile
switch_weights_col8.control.inputkey                       =   msfiles
switch_weights_col8.argument.flags                         =   [msfiles,WEIGHT_SPECTRUM,{{ blavg_weight_column }}]

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase21.control.type                              =   dppp_inplace
apply_ampphase21.control.opts.mapfiles_in                  =   [concat_data.output.mapfile,make_fast_phase_parmdb_map.output.mapfile]
apply_ampphase21.control.opts.inputkeys                    =   [msin,parmdb]
apply_ampphase21.argument.numthreads                       =   {{ max_cpus_per_proc_ntimes }}
apply_ampphase21.argument.msin.datacolumn                  =   DATA
apply_ampphase21.argument.msout                            =   .
apply_ampphase21.argument.msout.datacolumn                 =   CORRECTED_DATA
apply_ampphase21.argument.steps                            =   [correct_fast1,correct_fast2]
apply_ampphase21.argument.correct_fast1.type               =   applycal
apply_ampphase21.argument.correct_fast1.parmdb             =   parmdb
apply_ampphase21.argument.correct_fast1.correction         =   tec
apply_ampphase21.argument.correct_fast1.invert             =   True
apply_ampphase21.argument.correct_fast2.type               =   applycal
apply_ampphase21.argument.correct_fast2.parmdb             =   parmdb
apply_ampphase21.argument.correct_fast2.correction         =   commonscalarphase
apply_ampphase21.argument.correct_fast2.invert             =   True

# merge the parmDBs with the phase solutions into one, length = 1
# This is needed later when the loop is done and we want to apply the solutions to the original data
merge_phase_parmdbs.control.type                           =   merge_parmdbs_in_time
merge_phase_parmdbs.control.mapfile_in                     =   concat_data_compressed_mapfile.output.mapfile
merge_phase_parmdbs.control.inputkey                       =   mslist
merge_phase_parmdbs.control.outputkey                      =   outparmdb
merge_phase_parmdbs.argument.flags                         =   [mslist,instrument,outparmdb]

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs22.control.type                              =   remove_file
remove_parmdbs22.control.mapfile_in                        =   make_slow_gain_parmdb_map.output.mapfile
remove_parmdbs22.control.inputkey                          =   parmdb
remove_parmdbs22.argument.flags                            =   [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes * num_cal_blocks
# note: for now, we write out a new dataset even though it's never used, as this
# is the only way to add a uv cut without affecting the original dataset. Once
# GainCal has a filter parameter, we can use dppp_inplace instead and save on I/O
solve_ampphase22.control.type                              =   dppp
solve_ampphase22.control.mapfiles_in                       =   [concat_data.output.mapfile,make_slow_gain_parmdb_map.output.mapfile]
solve_ampphase22.control.inputkeys                         =   [msin,parmdb]
solve_ampphase22.argument.numthreads                       =   {{ max_cpus_per_io_proc_ntimes }}
solve_ampphase22.argument.msin.datacolumn                  =   CORRECTED_DATA
solve_ampphase22.argument.msout.overwrite                  =   True
solve_ampphase22.argument.msout.writefullresflag           =   False
solve_ampphase22.argument.local_scratch_dir                =   {{ local_dir }}
solve_ampphase22.argument.steps                            =   [uvcut,solvegain]
solve_ampphase22.argument.uvcut.type                       =   uvwflagger
solve_ampphase22.argument.uvcut.uvlambdamin                =   {{ solve_min_uv_lambda }}
solve_ampphase22.argument.solvegain.type                   =   gaincal
solve_ampphase22.argument.solvegain.caltype                =   {{ selfcal_caltype }}
solve_ampphase22.argument.solvegain.parmdb                 =   parmdb
solve_ampphase22.argument.solvegain.usemodelcolumn         =   True
solve_ampphase22.argument.solvegain.solint                 =   {{ solint_time_a }}
solve_ampphase22.argument.solvegain.nchan                  =   {{ solint_freq_a }}

# merge the parmDBs with the amplitude solutions into one, length = 1
# This is also used after the loop, but also now for smoothing the amplitudes
merge_amp_parmdbs2.control.type                            =   merge_parmdbs_in_time
merge_amp_parmdbs2.control.mapfile_in                      =   concat_data_compressed_mapfile.output.mapfile
merge_amp_parmdbs2.control.inputkey                        =   mslist
merge_amp_parmdbs2.control.outputkey                       =   outparmdb
merge_amp_parmdbs2.argument.flags                          =   [mslist,instrument_slow,outparmdb]

# smooth the amplitudes in the merged parmDB, length = 1
# smooth_amps uses only ANTENNA subtable of inputms, so it should work on virtual concatenated MS
smooth_amp2.control.type                                   =   {{ smooth_amps_task }}
smooth_amp2.control.mapfile_in                             =   merge_amp_parmdbs2.output.mapfile
smooth_amp2.control.inputkey                               =   ampparmdb
smooth_amp2.control.outputkey                              =   outparmdb
smooth_amp2.control.arguments                              =   [ampparmdb,outparmdb]

# expand the mapfile with the smoothd parmDB to all time-steps, length = ntimes * num_cal_blocks
expand_smoothed_amp2_parmdb_map.control.kind               =   plugin
expand_smoothed_amp2_parmdb_map.control.type               =   expandMapfile
expand_smoothed_amp2_parmdb_map.control.mapfile_in         =   smooth_amp2.output.mapfile
expand_smoothed_amp2_parmdb_map.control.mapfile_to_match   =   concat_data.output.mapfile
expand_smoothed_amp2_parmdb_map.control.mapfile_dir        =   input.output.mapfile_dir
expand_smoothed_amp2_parmdb_map.control.filename           =   expand_amp2_smoothed_parmdbs.mapfile

# apply the smoothed amplitudes and average, length = ntimes * num_cal_blocks
apply_amp2.control.type                                    =   dppp
apply_amp2.control.opts.mapfiles_in                        =   [concat_data.output.mapfile,expand_smoothed_amp2_parmdb_map.output.mapfile]
apply_amp2.control.opts.inputkeys                          =   [msin,parmdb]
apply_amp2.argument.numthreads                             =   {{ max_cpus_per_io_proc_ntimes }}
apply_amp2.argument.msin.datacolumn                        =   CORRECTED_DATA
apply_amp2.argument.msout.overwrite                        =   True
apply_amp2.argument.msout.writefullresflag                 =   False
apply_amp2.argument.local_scratch_dir                      =   {{ local_dir }}
apply_amp2.argument.steps                                  =   [correct_slow,avg]
apply_amp2.argument.correct_slow.type                      =   applycal
apply_amp2.argument.correct_slow.parmdb                    =   parmdb
apply_amp2.argument.correct_slow.invert                    =   True
apply_amp2.argument.avg.type                               =   squash
apply_amp2.argument.avg.freqstep                           =   1
apply_amp2.argument.avg.timestep                           =   {{ facetselfcal_timestep }}

########## end of fourth or of the looped round of selfcal

########## start of looped round of selfcal
########## make image to check if we can stop the loop, or as new model

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile4.control.kind                    =   plugin
create_compressed_mapfile4.control.type                    =   compressMapfile
create_compressed_mapfile4.control.mapfile_in              =   apply_amp2.output.mapfile
create_compressed_mapfile4.control.mapfile_dir             =   input.output.mapfile_dir
create_compressed_mapfile4.control.filename                =   concat4_input.mapfile

# virtual concatenate of averaged data, length = 1
concat4.control.type                                       =   virtual_concat
concat4.control.mapfile_in                                 =   create_compressed_mapfile4.output.mapfile
concat4.control.inputkey                                   =   msfiles
concat4.control.outputkey                                  =   msconcat
concat4.argument.flags                                     =   [msfiles,msconcat]

# image the virtual concatenated data with wsclean, length = 1
wsclean_image41.control.type                               =   wsclean
wsclean_image41.control.mapfiles_in                        =   [concat4.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image41.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image41.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image41.argument.fitsmask                          =   fitsmask
wsclean_image41.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image41.argument.niter                             =   1000
wsclean_image41.argument.threshold                         =   0.0
wsclean_image41.argument.pol                               =   I
wsclean_image41.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image41.argument.mgain                             =   0.6
wsclean_image41.argument.cleanborder                       =   0
wsclean_image41.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image41.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image41.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image41.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image41.argument.j                                 =   {{ max_cpus_per_proc_single }}
wsclean_image41.argument.tempdir                           =   {{ local_dir }}
{% if not wsclean_selfcal_multiscale %}
wsclean_image41.argument.multiscale-scales                 =   0
{% endif %}
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image41.argument.deconvolution-channels            =   3
wsclean_image41.argument.fit-spectral-log-pol              =   2
{% endif %}
wsclean_image41.argument.weighting-rank-filter             =   3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image41.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map41.control.kind                        =   plugin
create_imagebase_map41.control.type                        =   trimMapfile
create_imagebase_map41.control.mapfile_in                  =   wsclean_image41.output.wsclean_image41-image.fits.mapfile
create_imagebase_map41.control.trim                        =   -
create_imagebase_map41.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map41.control.filename                    =   wsclean_image41_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile41.control.kind                      =   plugin
adjust_wsclean_mapfile41.control.type                      =   appendMapfile
adjust_wsclean_mapfile41.control.mapfile_in                =   create_imagebase_map41.output.mapfile
adjust_wsclean_mapfile41.control.append                    =   {{ wsclean_suffix }}
adjust_wsclean_mapfile41.control.mapfile_dir               =   input.output.mapfile_dir
adjust_wsclean_mapfile41.control.filename                  =   wsclean_image41_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask4.control.type                                         =   make_clean_mask
mask4.control.mapfile_in                                   =   adjust_wsclean_mapfile41.output.mapfile
mask4.control.inputkey                                     =   imagefile
mask4.control.outputkey                                    =   maskfile
mask4.argument.flags                                       =   [imagefile,maskfile]
mask4.argument.region_file                                 =   {{ region_selfcal }}
mask4.argument.threshpix                                   =   8
mask4.argument.threshisl                                   =   8
mask4.argument.iterate_threshold                           =   True
mask4.argument.atrous_do                                   =   {{ atrous_do }}
mask4.argument.rmsbox                                      =   (80,20)
mask4.argument.adaptive_rmsbox                             =   True
mask4.argument.trim_by                                     =   0.4
mask4.argument.img_format                                  =   fits
mask4.argument.adaptive_thresh                             =   200
mask4.argument.threshold_format                            =   str_with_units
mask4.argument.use_adaptive_threshold                      =   {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image42.control.type                               =   wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image42.control.mapfiles_in                        =   [concat4.output.mapfile,mask4.output.mapfile,mask4.output.threshold_5sig.mapfile]
wsclean_image42.control.inputkeys                          =   [msfile,fitsmask,threshold]
wsclean_image42.argument.threshold                         =   threshold
wsclean_image42.argument.niter                             =   10000
{% else %}
wsclean_image42.control.mapfiles_in                        =   [concat4.output.mapfile,mask4.output.mapfile]
wsclean_image42.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image42.argument.threshold                         =   0.0
wsclean_image42.argument.niter                             =   1000
{% endif %}
wsclean_image42.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image42.argument.fitsmask                          =   fitsmask
wsclean_image42.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image42.argument.pol                               =   I
wsclean_image42.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image42.argument.mgain                             =   0.6
wsclean_image42.argument.cleanborder                       =   0
wsclean_image42.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image42.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image42.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image42.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image42.argument.j                                 =   {{ max_cpus_per_proc_single }}
wsclean_image42.argument.tempdir                           =   {{ local_dir }}
{% if not wsclean_selfcal_multiscale %}
wsclean_image42.argument.multiscale-scales                 =   0
{% endif %}
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image42.argument.deconvolution-channels            =   3
wsclean_image42.argument.fit-spectral-log-pol              =   2
{% endif %}
wsclean_image42.argument.weighting-rank-filter             =   3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image42.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map42.control.kind                        =   plugin
create_imagebase_map42.control.type                        =   trimMapfile
create_imagebase_map42.control.mapfile_in                  =   wsclean_image42.output.wsclean_image42-image.fits.mapfile
create_imagebase_map42.control.trim                        =   -
create_imagebase_map42.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map42.control.filename                    =   wsclean_image41_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile42.control.kind                      =   plugin
adjust_wsclean_mapfile42.control.type                      =   appendMapfile
adjust_wsclean_mapfile42.control.mapfile_in                =   create_imagebase_map42.output.mapfile
adjust_wsclean_mapfile42.control.append                    =   {{ wsclean_suffix }}
adjust_wsclean_mapfile42.control.mapfile_dir               =   input.output.mapfile_dir
adjust_wsclean_mapfile42.control.filename                  =   compare_image_input_new.mapfile

# copy the output image so that we can compare it later, length = 1
copy_image2.control.type                                   =   copy_image
copy_image2.control.mapfile_in                             =   adjust_casa_mapfile5.output.mapfile
copy_image2.control.inputkey                               =   image
copy_image2.argument.flags                                 =   [image,loop_ampcal.output.counter,4]

# compare the current and the previous image to see if we can stop the loop, length = 1
check_image2.control.type                                  =   compare_image_stats
check_image2.control.mapfiles_in                           =   [adjust_casa_mapfile5.output.mapfile,copy_image2.output.previous_image.mapfile]
check_image2.control.inputkeys                             =   [image_new,image_prev]
check_image2.argument.flags                                =   [image_new,image_prev]

########## end of phase+amp selfcal loop

# merge the phases and amplitudes parmDBs, length = 1
merge_selfcal_parmdbs.control.type                         =   merge_parmdbs_selfcal
merge_selfcal_parmdbs.control.mapfiles_in                  =   [merge_phase_parmdbs.output.mapfile,smooth_amp2.output.mapfile]
merge_selfcal_parmdbs.control.inputkeys                    =   [parmdb_p,parmdb_a]
merge_selfcal_parmdbs.control.outputkey                    =   parmdb_out
merge_selfcal_parmdbs.argument.flags                       =   [parmdb_p,parmdb_a,parmdb_out]

# make plots of the selfcal solutions from the marged parmDB, length = 1
make_selfcal_plots.control.type                            =   make_selfcal_plots
make_selfcal_plots.control.mapfile_in                      =   merge_selfcal_parmdbs.output.mapfile
make_selfcal_plots.control.inputkeys                       =   parmdb
make_selfcal_plots.control.outputkey                       =   plots_root
make_selfcal_plots.argument.flags                          =   [parmdb,plots_root]
make_selfcal_plots.argument.fourpol                        =   {{ fourpol }}

# create a mapfile with the selfcal images, length = 1
create_selfcal_images_mapfile.control.kind                 =   plugin
create_selfcal_images_mapfile.control.type                 =   addSelfcalImagesMapfile
create_selfcal_images_mapfile.control.selfcal_dir          =   {{ pipeline_parset_dir }}
create_selfcal_images_mapfile.control.mapfile_dir          =   input.output.mapfile_dir
create_selfcal_images_mapfile.control.hosts                =   {{ hosts }}
create_selfcal_images_mapfile.control.filename             =   selfcal_images.mapfile

# make plots of the selfcal images, length = 1
make_selfcal_images.control.type                           =   make_selfcal_images
make_selfcal_images.control.mapfile_in                     =   create_selfcal_images_mapfile.output.mapfile
make_selfcal_images.control.inputkeys                      =   imagefiles
make_selfcal_images.argument.flags                         =   [imagefiles]

# expand the merged parmDB to all files, length = nfiles
expand_merged_parmdb_map.control.kind                      =   plugin
expand_merged_parmdb_map.control.type                      =   expandMapfile
expand_merged_parmdb_map.control.mapfile_in                =   merge_selfcal_parmdbs.output.mapfile
expand_merged_parmdb_map.control.mapfile_to_match          =   shift_empty.output.mapfile
expand_merged_parmdb_map.control.mapfile_dir               =   input.output.mapfile_dir
expand_merged_parmdb_map.control.filename                  =   expand_merged_parmdbs.mapfile

# add the imaging columns to the phase-shifted data, length = nfiles
add_imaging_cols_empty.control.type                        =   add_imaging_columns
add_imaging_cols_empty.control.mapfile_in                  =   shift_empty.output.mapfile
add_imaging_cols_empty.control.inputkey                    =   msfile
add_imaging_cols_empty.argument.flags                      =   [msfile]

{% if is_patch or skip_facet_imaging %}
# The calibrator is the full patch. (No need to re-image the facet.)

# sort the "shift_empty" unaveraged data into groups that can be concatenated, length = some
# needed because virtual concatenating all files results in a "too many open files" error.
regroup_shift_empty_map_ft.control.kind                    =   plugin
regroup_shift_empty_map_ft.control.type                    =   reGroupMapfile
regroup_shift_empty_map_ft.control.mapfile_in              =   shift_empty.output.mapfile
regroup_shift_empty_map_ft.control.mapfile_groups          =   create_msmulti_map.output.mapfile
regroup_shift_empty_map_ft.control.mapfile_dir             =   input.output.mapfile_dir
regroup_shift_empty_map_ft.control.join_max_files          =   100
regroup_shift_empty_map_ft.control.filename                =   regroup_shift_empty.mapfile

## virtual concat of the re-grouped unaveraged data, length = some
concat_unaveraged_ft.control.type                          =   virtual_concat
concat_unaveraged_ft.control.mapfile_in                    =   regroup_shift_empty_map_ft.output.mapfile
concat_unaveraged_ft.control.inputkey                      =   msfiles
concat_unaveraged_ft.control.outputkey                     =   msconcat
concat_unaveraged_ft.argument.flags                        =   [msfiles,msconcat]

# create a mapfile for the model image, length = 1
create_model4_map.control.kind                             =   plugin
create_model4_map.control.type                             =   trimMapfile
create_model4_map.control.mapfile_in                       =   wsclean_image42.output.wsclean_image42-model.fits.mapfile
create_model4_map.control.trim                             =   -
create_model4_map.control.mapfile_dir                      =   input.output.mapfile_dir
create_model4_map.control.filename                         =   final_model_rootnames.mapfile

# Blank (with zeros) regions of the model image that lie outside of the patch region, length = 1
blank_model.control.type                                   =   blank_image
blank_model.control.mapfile_in                             =   create_model4_map.output.mapfile
blank_model.control.inputkey                               =   infile
blank_model.control.outputkey                              =   outfile
blank_model.argument.flags                                 =   [infile,{{ vertices_file }},outfile]
blank_model.argument.blank_value                           =   zero
blank_model.argument.img_format                            =   fits
blank_model.argument.image_is_wsclean_model                =   True

# pad the model image with zeros, length = 1
pad_model_images.control.type                              =   pad_image
pad_model_images.control.mapfile_in                        =   create_model4_map.output.mapfile
pad_model_images.control.inputkey                          =   imagefile
pad_model_images.argument.flags                            =   [imagefile,{{ wsclean_model_padding }}]

# sort the "shift_empty" unaveraged data into groups that can be concatenated, length = some
# needed because virtual concatenating all files results in a "too many open files" error.
regroup_shift_empty_map.control.kind                       =   plugin
regroup_shift_empty_map.control.type                       =   reGroupMapfile
regroup_shift_empty_map.control.mapfile_in                 =   shift_empty.output.mapfile
regroup_shift_empty_map.control.mapfile_groups             =   create_msmulti_map.output.mapfile
regroup_shift_empty_map.control.mapfile_dir                =   input.output.mapfile_dir
regroup_shift_empty_map.control.join_max_files             =   100
regroup_shift_empty_map.control.rotate_groups              =   True
regroup_shift_empty_map.control.filename                   =   regroup_shift_empty.mapfile

# expand the mapfile of the model image to all files, length = some
create_expanded_model_mapfile.control.kind                 =   plugin
create_expanded_model_mapfile.control.type                 =   expandMapfile
create_expanded_model_mapfile.control.mapfile_in           =   create_model4_map.output.mapfile
create_expanded_model_mapfile.control.mapfile_to_match     =   regroup_shift_empty_map.output.mapfile
create_expanded_model_mapfile.control.mapfile_dir          =   input.output.mapfile_dir
create_expanded_model_mapfile.control.filename             =   expand_wsclean_model.mapfile

# expand mapfile of the model image sizes to all groups, length = some
expand_facet_model_size_map.control.kind                   =   plugin
expand_facet_model_size_map.control.type                   =   expandMapfile
expand_facet_model_size_map.control.mapfile_in             =   pad_model_images.output.padsize.mapfile
expand_facet_model_size_map.control.mapfile_to_match       =   regroup_shift_empty_map.output.mapfile
expand_facet_model_size_map.control.mapfile_dir            =   input.output.mapfile_dir
expand_facet_model_size_map.control.filename               =   expand_facet_model_size.mapfile

# make model visibilities, length = some
# For WSClean predict, we need to increase the number of wplanes so that the
# effective model image size is larger than the FOV (to prevent aliasing issues)
wsclean_ft.control.type                                    =   wsclean_ft
wsclean_ft.control.mapfiles_in                             =   [regroup_shift_empty_map.output.mapfile,create_expanded_model_mapfile.output.mapfile,expand_facet_model_size_map.output.mapfile]
wsclean_ft.control.inputkeys                               =   [msfile,name,size]
wsclean_ft.argument.flags                                  =   [-predict,msfile]
wsclean_ft.argument.scale                                  =   {{ cellsize_facet_deg }}
wsclean_ft.argument.mem                                    =   {{ max_percent_memory_per_proc_ngroups }}
wsclean_ft.argument.channelsout                            =   {{ wsclean_nchannels }}
wsclean_ft.argument.j                                      =   {{ max_cpus_per_proc_ngroups }}
wsclean_ft.argument.tempdir                                =   {{ local_dir }}
wsclean_ft.argument.nwlayers-for-size                      =   12288 12288
{% else %}

# apply the direction-dependent solutions and average, length = nfiles
apply_dir_dep.control.type                                 =   dppp
apply_dir_dep.control.opts.mapfiles_in                     =   [shift_empty.output.mapfile,expand_merged_parmdb_map.output.mapfile]
apply_dir_dep.control.opts.inputkeys                       =   [msin,dir_dep_parmdb]
apply_dir_dep.argument.numthreads                          =   {{ max_cpus_per_io_proc_nfiles }}
apply_dir_dep.argument.msin.datacolumn                     =   FACET_DATA_ALL
apply_dir_dep.argument.msout.overwrite                     =   True
apply_dir_dep.argument.msout.writefullresflag              =   False
apply_dir_dep.argument.local_scratch_dir                   =   {{ local_dir }}
apply_dir_dep.argument.steps                               =   [correct_fast1,correct_fast2,correct_slow,flagzero,avg]
apply_dir_dep.argument.correct_fast1.type                  =   applycal
apply_dir_dep.argument.correct_fast1.parmdb                =   dir_dep_parmdb
apply_dir_dep.argument.correct_fast1.correction            =   tec
apply_dir_dep.argument.correct_fast1.invert                =   True
apply_dir_dep.argument.correct_fast2.type                  =   applycal
apply_dir_dep.argument.correct_fast2.parmdb                =   dir_dep_parmdb
apply_dir_dep.argument.correct_fast2.correction            =   commonscalarphase
apply_dir_dep.argument.correct_fast2.invert                =   True
apply_dir_dep.argument.correct_slow.type                   =   applycal
apply_dir_dep.argument.correct_slow.parmdb                 =   dir_dep_parmdb
apply_dir_dep.argument.correct_slow.invert                 =   True
apply_dir_dep.argument.flagzero.type                       =   preflagger
apply_dir_dep.argument.flagzero.amplmin                    =   1e-20
apply_dir_dep.argument.avg.type                            =   squash
apply_dir_dep.argument.avg.freqstep                        =   {{ facetimage_freqstep }}
apply_dir_dep.argument.avg.timestep                        =   {{ facetimage_timestep }}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile5.control.kind                    =   plugin
create_compressed_mapfile5.control.type                    =   compressMapfile
create_compressed_mapfile5.control.mapfile_in              =   apply_dir_dep.output.mapfile
create_compressed_mapfile5.control.mapfile_dir             =   input.output.mapfile_dir
create_compressed_mapfile5.control.filename                =   concat_averaged_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes
# not sure if this is needed / useful
sort_averaged.control.type                                 =   sort_times_into_freqGroups
sort_averaged.argument.flags                               =   [create_compressed_mapfile5.output.mapfile]
sort_averaged.argument.filename                            =   apply_dir_dep_sorted_groups.mapfile
sort_averaged.argument.mapfile_dir                         =   input.output.mapfile_dir
sort_averaged.argument.hosts                               =   {{ hosts }}
sort_averaged.argument.stepname                            =   sort_averaged
sort_averaged.argument.nband_pad                           =   {{ nband_pad }}

# convert the output of sort_average5 into usable mapfiles, len = 1 / ntimes
sort_averaged_maps.control.kind                            =   plugin
sort_averaged_maps.control.type                            =   mapfilenamesFromMapfiles
sort_averaged_maps.control.mapfile_groupmap                =   sort_averaged.output.groupmapfile.mapfile
sort_averaged_maps.control.mapfile_filesmap                =   sort_averaged.output.mapfile.mapfile

# concatenate data in frequency, length = ntimes
# not sure if this is needed / useful
concat_averaged.control.type                               =   dppp
concat_averaged.control.mapfile_out                        =   sort_averaged_maps.output.groupmap
concat_averaged.control.mapfile_in                         =   sort_averaged_maps.output.filesmap
concat_averaged.control.inputkey                           =   msin
concat_averaged.argument.numthreads                        =   {{ max_cpus_per_io_proc_ntimes }}
concat_averaged.argument.msin.datacolumn                   =   DATA
concat_averaged.argument.msin.missingdata                  =   True
concat_averaged.argument.msin.orderms                      =   False
concat_averaged.argument.msout.overwrite                   =   True
concat_averaged.argument.msout.writefullresflag            =   False
concat_averaged.argument.local_scratch_dir                 =   {{ local_dir }}
concat_averaged.argument.steps                             =   []

# make a compressed mapfile of the concatenated data, length = 1
concat_averaged_compressed_map.control.kind                =   plugin
concat_averaged_compressed_map.control.type                =   compressMapfile
concat_averaged_compressed_map.control.mapfile_in          =   concat_averaged.output.mapfile
concat_averaged_compressed_map.control.mapfile_dir         =   input.output.mapfile_dir
concat_averaged_compressed_map.control.filename            =   concat_averaged_compressed.mapfile

# make a mask from the last selfcal image, length = 1
premask.control.type                                       =   make_clean_mask
premask.control.mapfile_in                                 =   create_imagebase_map42.output.mapfile
premask.control.inputkey                                   =   imagefile
premask.control.outputkey                                  =   maskfile
premask.argument.flags                                     =   [imagefile,maskfile]
premask.argument.img_format                                =   fits
premask.argument.pad_to_size                               =   {{ facet_imsize }}
premask.argument.skip_source_detection                     =   True
premask.argument.vertices_file                             =   {{ vertices_file }}
premask.argument.reference_ra_deg                          =   {{ facet_ra }}
premask.argument.reference_dec_deg                         =   {{ facet_dec }}

# image the concatenated data with the preliminary mask, length = 1
# maybe this can better run on all single files without concatenation
wsclean_image_full1.control.type                           =   wsclean
wsclean_image_full1.control.mapfiles_in                    =   [concat_averaged_compressed_map.output.mapfile,premask.output.mapfile]
wsclean_image_full1.control.inputkeys                      =   [msfile,fitsmask]
wsclean_image_full1.argument.flags                         =   [-no-update-model-required,{{ wsclean_multiscale }}-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image_full1.argument.fitsmask                      =   fitsmask
wsclean_image_full1.argument.size                          =   {{ facet_imsize }} {{ facet_imsize }}
wsclean_image_full1.argument.niter                         =   {{ wsclean_full1_image_niter }}
wsclean_image_full1.argument.threshold                     =   {{ wsclean_full1_image_threshold_jy }}
wsclean_image_full1.argument.pol                           =   I
wsclean_image_full1.argument.weight                        =   briggs {{ robust_selfcal }}
wsclean_image_full1.argument.mgain                         =   0.6
wsclean_image_full1.argument.cleanborder                   =   0
wsclean_image_full1.argument.minuv-l                       =   {{ facet_min_uv_lambda }}
wsclean_image_full1.argument.scale                         =   {{ cellsize_selfcal_deg }}
wsclean_image_full1.argument.channelsout                   =   {{ wsclean_nchannels }}
wsclean_image_full1.argument.mem                           =   {{ max_percent_memory_per_proc_single }}
wsclean_image_full1.argument.j                             =   {{ max_cpus_per_proc_single }}
wsclean_image_full1.argument.tempdir                       =   {{ local_dir }}
wsclean_image_full1.argument.weighting-rank-filter         =   3
{% if facetimage_wsclean_nwavelengths > 0.0 %}
wsclean_image_full1.argument.baseline-averaging            =   {{ facetimage_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean images, length = 1
create_imagebase_map.control.kind                          =   plugin
create_imagebase_map.control.type                          =   trimMapfile
create_imagebase_map.control.mapfile_in                    =   wsclean_image_full1.output.wsclean_image_full1-image.fits.mapfile
create_imagebase_map.control.trim                          =   -
create_imagebase_map.control.mapfile_dir                   =   input.output.mapfile_dir
create_imagebase_map.control.filename                      =   wsclean_image_full1_image_rootnames.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile1.control.kind                       =   plugin
adjust_wsclean_mapfile1.control.type                       =   appendMapfile
adjust_wsclean_mapfile1.control.mapfile_in                 =   create_imagebase_map.output.mapfile
adjust_wsclean_mapfile1.control.append                     =   {{ wsclean_suffix }}
adjust_wsclean_mapfile1.control.mapfile_dir                =   input.output.mapfile_dir
adjust_wsclean_mapfile1.control.filename                   =   final_image1.mapfile

# make a mask from the updated image, length = 1
mask5.control.type                                         =   make_clean_mask
mask5.control.mapfile_in                                   =   adjust_wsclean_mapfile1.output.mapfile
mask5.control.inputkey                                     =   imagefile
mask5.control.outputkey                                    =   maskfile
mask5.argument.flags                                       =   [imagefile,maskfile]
mask5.argument.region_file                                 =   {{ region_field }}
mask5.argument.threshisl                                   =   3
mask5.argument.threshpix                                   =   5
mask5.argument.rmsbox                                      =   (300,100)
mask5.argument.rmsbox_bright                               =   (70,10)
mask5.argument.atrous_jmax                                 =   3
mask5.argument.adaptive_rmsbox                             =   True
mask5.argument.atrous_do                                   =   True
mask5.argument.img_format                                  =   fits
mask5.argument.vertices_file                               =   {{ vertices_file }}

# image the concatenated data with the updated mask, length = 1
wsclean_image_full2.control.type                           =   wsclean
wsclean_image_full2.control.mapfiles_in                    =   [concat_averaged_compressed_map.output.mapfile,mask5.output.mapfile,mask5.output.threshold_5sig.mapfile]
wsclean_image_full2.control.inputkeys                      =   [msfile,fitsmask,threshold]
wsclean_image_full2.argument.flags                         =   [-no-update-model-required,{{ wsclean_multiscale }}-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image_full2.argument.fitsmask                      =   fitsmask
wsclean_image_full2.argument.size                          =   {{ facet_imsize }} {{ facet_imsize }}
wsclean_image_full2.argument.niter                         =   {{ wsclean_full2_image_niter }}
wsclean_image_full2.argument.threshold                     =   threshold
wsclean_image_full2.argument.pol                           =   I
wsclean_image_full2.argument.weight                        =   briggs {{ robust_selfcal }}
wsclean_image_full2.argument.mgain                         =   0.6
wsclean_image_full2.argument.cleanborder                   =   0
wsclean_image_full2.argument.minuv-l                       =   {{ facet_min_uv_lambda }}
wsclean_image_full2.argument.scale                         =   {{ cellsize_selfcal_deg }}
wsclean_image_full2.argument.channelsout                   =   {{ wsclean_nchannels }}
wsclean_image_full2.argument.mem                           =   {{ max_percent_memory_per_proc_single }}
wsclean_image_full2.argument.j                             =   {{ max_cpus_per_proc_single }}
wsclean_image_full2.argument.tempdir                       =   {{ local_dir }}
wsclean_image_full2.argument.weighting-rank-filter         =   3
{% if facetimage_wsclean_nwavelengths > 0.0 %}
wsclean_image_full2.argument.baseline-averaging            =   {{ facetimage_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the final WSClean images, length = 1
create_model4_map.control.kind                             =   plugin
create_model4_map.control.type                             =   trimMapfile
create_model4_map.control.mapfile_in                       =   wsclean_image_full2.output.wsclean_image_full2-model.fits.mapfile
create_model4_map.control.trim                             =   -
create_model4_map.control.mapfile_dir                      =   input.output.mapfile_dir
create_model4_map.control.filename                         =   final_model_rootnames.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile2.control.kind                       =   plugin
adjust_wsclean_mapfile2.control.type                       =   appendMapfile
adjust_wsclean_mapfile2.control.mapfile_in                 =   create_model4_map.output.mapfile
adjust_wsclean_mapfile2.control.append                     =   {{ wsclean_suffix }}
adjust_wsclean_mapfile2.control.mapfile_dir                =   input.output.mapfile_dir
adjust_wsclean_mapfile2.control.filename                   =   final_image.mapfile

# pad the model image with zeros, length = 1
pad_model_images.control.type                              =   pad_image
pad_model_images.control.mapfile_in                        =   create_model4_map.output.mapfile
pad_model_images.control.inputkey                          =   imagefile
pad_model_images.argument.flags                            =   [imagefile,{{ wsclean_model_padding }}]

# sort the "shift_empty" unaveraged data into groups that can be concatenated, length = some
# needed because virtual concatenating all files results in a "too many open files" error.
regroup_shift_empty_map.control.kind                       =   plugin
regroup_shift_empty_map.control.type                       =   reGroupMapfile
regroup_shift_empty_map.control.mapfile_in                 =   shift_empty.output.mapfile
regroup_shift_empty_map.control.mapfile_groups             =   create_msmulti_map.output.mapfile
regroup_shift_empty_map.control.mapfile_dir                =   input.output.mapfile_dir
regroup_shift_empty_map.control.join_max_files             =   100
regroup_shift_empty_map.control.rotate_groups              =   True
regroup_shift_empty_map.control.filename                   =   regroup_shift_empty.mapfile

# expand the mapfile of the model image to all files, length = some
create_expanded_model_mapfile.control.kind                 =   plugin
create_expanded_model_mapfile.control.type                 =   expandMapfile
create_expanded_model_mapfile.control.mapfile_in           =   create_model4_map.output.mapfile
create_expanded_model_mapfile.control.mapfile_to_match     =   regroup_shift_empty_map.output.mapfile
create_expanded_model_mapfile.control.mapfile_dir          =   input.output.mapfile_dir
create_expanded_model_mapfile.control.filename             =   expand_wsclean_model.mapfile

# expand mapfile of the model image sizes to all groups, length = some
expand_facet_model_size_map.control.kind                   =   plugin
expand_facet_model_size_map.control.type                   =   expandMapfile
expand_facet_model_size_map.control.mapfile_in             =   pad_model_images.output.padsize.mapfile
expand_facet_model_size_map.control.mapfile_to_match       =   regroup_shift_empty_map.output.mapfile
expand_facet_model_size_map.control.mapfile_dir            =   input.output.mapfile_dir
expand_facet_model_size_map.control.filename               =   expand_facet_model_size.mapfile

# make model visibilities, length = some
# For WSClean predict, we need to increase the number of wplanes so that the
# effective model image size is larger than the FOV (to prevent aliasing issues)
wsclean_ft.control.type                                    =   wsclean_ft
wsclean_ft.control.mapfiles_in                             =   [regroup_shift_empty_map.output.mapfile,create_expanded_model_mapfile.output.mapfile,expand_facet_model_size_map.output.mapfile]
wsclean_ft.control.inputkeys                               =   [msfile,name,size]
wsclean_ft.argument.flags                                  =   [-predict,msfile]
wsclean_ft.argument.scale                                  =   {{ cellsize_facet_deg }}
wsclean_ft.argument.mem                                    =   {{ max_percent_memory_per_proc_ngroups }}
wsclean_ft.argument.channelsout                            =   {{ wsclean_nchannels }}
wsclean_ft.argument.j                                      =   {{ max_cpus_per_proc_ngroups }}
wsclean_ft.argument.tempdir                                =   {{ local_dir }}
wsclean_ft.argument.nwlayers-for-size                      =   12288 12288
{% endif %}
########## end of the "is the calibrator the full facet" if-clause

# corrupt the model visibilities, length = nfiles
corrupt_final_model.control.type                           =   dppp
corrupt_final_model.control.opts.mapfiles_in               =   [shift_empty.output.mapfile,expand_merged_parmdb_map.output.mapfile]
corrupt_final_model.control.opts.inputkeys                 =   [msin,parmdb]
corrupt_final_model.argument.numthreads                    =   {{ max_cpus_per_io_proc_nfiles }}
corrupt_final_model.argument.msin.datacolumn               =   MODEL_DATA
corrupt_final_model.argument.msout.overwrite               =   True
corrupt_final_model.argument.msout.writefullresflag        =   False
corrupt_final_model.argument.local_scratch_dir             =   {{ local_dir }}
corrupt_final_model.argument.steps                         =   [corrupt_fast1,corrupt_fast2,corrupt_slow]
corrupt_final_model.argument.corrupt_fast1.type            =   applycal
corrupt_final_model.argument.corrupt_fast1.parmdb          =   parmdb
corrupt_final_model.argument.corrupt_fast1.correction      =   tec
corrupt_final_model.argument.corrupt_fast1.invert          =   False
corrupt_final_model.argument.corrupt_fast2.type            =   applycal
corrupt_final_model.argument.corrupt_fast2.parmdb          =   parmdb
corrupt_final_model.argument.corrupt_fast2.correction      =   commonscalarphase
corrupt_final_model.argument.corrupt_fast2.invert          =   False
corrupt_final_model.argument.corrupt_slow.type             =   applycal
corrupt_final_model.argument.corrupt_slow.parmdb           =   parmdb
corrupt_final_model.argument.corrupt_slow.correction       =   gain
corrupt_final_model.argument.corrupt_slow.invert           =   False

# subtract new model vis from original model+residual vis, length = nfiles
subtract_initial_final.control.type                        =   add_subtract_columns
subtract_initial_final.control.opts.mapfiles_in            =   [predict_all_model_data.output.mapfile,corrupt_final_model.output.mapfile]
subtract_initial_final.control.opts.inputkeys              =   [file1,file2]
subtract_initial_final.argument.flags                      =   [file1,file2,DATA,DATA,MODEL_DATA_DIFF,subtract]

# shift new residuals to field center, length = nfiles
shift_diff_model_to_field.control.type                     =   dppp
shift_diff_model_to_field.control.opts.mapfile_in          =   predict_all_model_data.output.mapfile
shift_diff_model_to_field.control.opts.inputkey            =   msin
shift_diff_model_to_field.argument.numthreads              =   {{ max_cpus_per_io_proc_nfiles }}
shift_diff_model_to_field.argument.msin.datacolumn         =   MODEL_DATA_DIFF
shift_diff_model_to_field.argument.msout.overwrite         =   True
shift_diff_model_to_field.argument.msout.writefullresflag  =   False
shift_diff_model_to_field.argument.local_scratch_dir       =   {{ local_dir }}
shift_diff_model_to_field.argument.steps                   =   [shift]
shift_diff_model_to_field.argument.shift.type              =   phaseshifter
shift_diff_model_to_field.argument.shift.phasecenter       =   [{{ field_ra }}deg, {{ field_dec }}deg]

#
# Verify the the quality of the selfcal on the middle band
#

# make a map with original facet data of only the central frequency band, length = ntimes
create_middle_band_mapfile.control.kind                    =   plugin
create_middle_band_mapfile.control.type                    =   selectMiddleFreq
create_middle_band_mapfile.control.mapfile_in              =   shift_empty.output.mapfile
create_middle_band_mapfile.control.mapfile_dir             =   input.output.mapfile_dir
create_middle_band_mapfile.control.filename                =   single_band.mapfile

# make a map with new facet data of only the central frequency band, length = ntimes
create_middle_model_mapfile.control.kind                   =   plugin
create_middle_model_mapfile.control.type                   =   selectMatching
create_middle_model_mapfile.control.mapfile_in             =   corrupt_final_model.output.mapfile
create_middle_model_mapfile.control.mapfile_reference      =   create_middle_band_mapfile.output.mapfile
create_middle_model_mapfile.control.mapfile_dir            =   input.output.mapfile_dir
create_middle_model_mapfile.control.filename               =   single_model.mapfile

# subtract new facet data from original full facet data, length = ntimes
subtract_single.control.type                               =   add_subtract_columns
subtract_single.control.opts.mapfiles_in                   =   [create_middle_band_mapfile.output.mapfile,create_middle_model_mapfile.output.mapfile]
subtract_single.control.opts.inputkeys                     =   [file1,file2]
subtract_single.argument.flags                             =   [file1,file2,FACET_DATA_ALL,DATA,SUBTRACTED_DATA,subtract]

# average old empty data, length = ntimes
average_pre.control.type                                   =   dppp
average_pre.control.mapfile_in                             =   create_middle_band_mapfile.output.mapfile
average_pre.control.inputkey                               =   msin
average_pre.argument.numthreads                            =   {{ max_cpus_per_io_proc_ntimes }}
average_pre.argument.msin.datacolumn                       =   DATA
average_pre.argument.msout.overwrite                       =   True
average_pre.argument.msout.writefullresflag                =   False
average_pre.argument.local_scratch_dir                     =   {{ local_dir }}
average_pre.argument.steps                                 =   [uv,avg]
average_pre.argument.uv.type                               =   uvwflagger
average_pre.argument.uv.uvmmax                             =   2500.0
average_pre.argument.avg.type                              =   squash
average_pre.argument.avg.freqstep                          =   {{ verify_freqstep }}
average_pre.argument.avg.timestep                          =   {{ verify_timestep }}

# average "old minus new" facet data (= new empty data), length = ntimes
average_post.control.type                                  =   dppp
average_post.control.mapfile_in                            =   create_middle_band_mapfile.output.mapfile
average_post.control.inputkey                              =   msin
average_post.argument.numthreads                           =   {{ max_cpus_per_io_proc_ntimes }}
average_post.argument.msin.datacolumn                      =   SUBTRACTED_DATA
average_post.argument.msout.overwrite                      =   True
average_post.argument.msout.writefullresflag               =   False
average_post.argument.local_scratch_dir                    =   {{ local_dir }}
average_post.argument.steps                                =   [uv,avg]
average_post.argument.uv.type                              =   uvwflagger
average_post.argument.uv.uvmmax                            =   2500.0
average_post.argument.avg.type                             =   squash
average_post.argument.avg.freqstep                         =   {{ verify_freqstep }}
average_post.argument.avg.timestep                         =   {{ verify_timestep }}

# make compressed mapfile of old empty data, length = 1
average_pre_compressed_map.control.kind                    =   plugin
average_pre_compressed_map.control.type                    =   compressMapfile
average_pre_compressed_map.control.mapfile_in              =   average_pre.output.mapfile
average_pre_compressed_map.control.mapfile_dir             =   input.output.mapfile_dir
average_pre_compressed_map.control.filename                =   average_pre_compressed.mapfile

# image the old empty data, length = 1
wsclean_pre.control.type                                   =   wsclean
wsclean_pre.control.mapfile_in                             =   average_pre_compressed_map.output.mapfile
wsclean_pre.control.inputkey                               =   msfiles
wsclean_pre.argument.flags                                 =   [-no-update-model-required,msfiles]
wsclean_pre.argument.size                                  =   2048 2048
wsclean_pre.argument.niter                                 =   10
wsclean_pre.argument.threshold                             =   0.0
wsclean_pre.argument.pol                                   =   I
wsclean_pre.argument.weight                                =   briggs -0.5
wsclean_pre.argument.mgain                                 =   0.5
wsclean_pre.argument.gain                                  =   0.1
wsclean_pre.argument.cleanborder                           =   0
wsclean_pre.argument.minuv-l                               =   {{ facet_min_uv_lambda }}
wsclean_pre.argument.maxuv-l                               =   2500
wsclean_pre.argument.scale                                 =   0.00833
wsclean_pre.argument.mem                                   =   {{ max_percent_memory_per_proc_single }}
wsclean_pre.argument.j                                     =   {{ max_cpus_per_proc_single }}

# make compressed mapfile of new empty data, length = 1
average_post_compressed_map.control.kind                   =   plugin
average_post_compressed_map.control.type                   =   compressMapfile
average_post_compressed_map.control.mapfile_in             =   average_post.output.mapfile
average_post_compressed_map.control.mapfile_dir            =   input.output.mapfile_dir
average_post_compressed_map.control.filename               =   average_post_compressed.mapfile

# image the new empty data, length = 1
wsclean_post.control.type                                  =   wsclean
wsclean_post.control.mapfile_in                            =   average_post_compressed_map.output.mapfile
wsclean_post.control.inputkey                              =   msfiles
wsclean_post.argument.flags                                =   [-no-update-model-required,msfiles]
wsclean_post.argument.size                                 =   2048 2048
wsclean_post.argument.niter                                =   10
wsclean_post.argument.threshold                            =   0.0
wsclean_post.argument.pol                                  =   I
wsclean_post.argument.weight                               =   briggs -0.5
wsclean_post.argument.mgain                                =   0.5
wsclean_post.argument.gain                                 =   0.1
wsclean_post.argument.cleanborder                          =   0
wsclean_post.argument.minuv-l                              =   {{ facet_min_uv_lambda }}
wsclean_post.argument.maxuv-l                              =   2500
wsclean_post.argument.scale                                =   0.00833
wsclean_post.argument.mem                                  =   {{ max_percent_memory_per_proc_single }}
wsclean_post.argument.j                                    =   {{ max_cpus_per_proc_single }}

# do a "verify_subtract" on the two "empty" images, length = 1
verify_subtract.control.type                               =   verify_subtract
verify_subtract.control.mapfiles_in                        =   [wsclean_pre.output.wsclean_pre-image.fits.mapfile,wsclean_post.output.wsclean_post-image.fits.mapfile]
verify_subtract.control.inputkeys                          =   [image_pre,image_post]
verify_subtract.argument.flags                             =   [image_pre,image_post,0.75]
