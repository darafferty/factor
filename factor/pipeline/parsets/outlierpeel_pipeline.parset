pipeline.steps = [update_mapfile_hosts, create_ms_map, create_msmulti_map, create_parmdb_map, create_full_skymodels_map, make_facet_skymodels_all, make_sourcedb_all_facet_sources, expand_sourcedb_all_facet_sources, add_all_facet_sources, shift_and_average,  create_compressed_mapfile, sort_into_Groups, sort_into_Groups_maps, concat_data, concat_data_compressed_mapfile, {% if pre_average %} regroup_shift_and_average, regroup_parmdb, pre_average, make_blavg_data_mapfile, concat_blavg_data, copy_column1, copy_column2, {% endif %} switch_weights_col1, make_fast_phase_parmdb_map, create_peel_skymodel_map, make_peel_sourcedb, expand_peel_sourcedb_map, remove_parmdbs11, solve_ampphase11, switch_weights_col2, apply_ampphase11, merge_phase_parmdbs, make_slow_gain_parmdb_map, remove_parmdbs12, solve_ampphase12, merge_amp_parmdbs, smooth_amps, smooth_amps_normalized, merge_selfcal_parmdbs, merge_normalized_selfcal_parmdbs, {% if create_preapply_parmdb %} create_preapply_parmdb, {% endif %} make_selfcal_plots, expand_merged_parmdb_map, create_outlier_skymodel_map, make_sourcedb_outlier_model, expand_sourcedb_outlier_map, predict_outlier_model, corrupt_outlier_model, subtract_outlier_model, create_middle_pre_band_mapfile, create_middle_post_mapfile, average_pre, average_post, average_pre_compressed_map, wsclean_pre, average_post_compressed_map, wsclean_post, verify_subtract, expand_verify_subtract_map, copy_to_empty_data]

pipeline.pluginpath                                      =   {{ pipeline_dir }}/plugins

update_mapfile_hosts.control.kind                        =   plugin
update_mapfile_hosts.control.type                        =   updateHosts
update_mapfile_hosts.control.mapfile_dir                 =   input.output.mapfile_dir
update_mapfile_hosts.control.hosts                       =   {{ hosts }}

# create a mapfile with all single MSs from supplied list, length = nfiles
create_ms_map.control.kind                               =   plugin
create_ms_map.control.type                               =   addListMapfile
create_ms_map.control.hosts                              =   {{ hosts }}
create_ms_map.control.files                              =   {{ ms_files_single }}
create_ms_map.control.mapfile_dir                        =   input.output.mapfile_dir
create_ms_map.control.filename                           =   input_files_single.mapfile

# create a multi-mapfile with the groups of MSs from supplied list, length = nbands
create_msmulti_map.control.kind                          =   plugin
create_msmulti_map.control.type                          =   addListMultiMapfile
create_msmulti_map.control.hosts                         =   {{ hosts }}
create_msmulti_map.control.files                         =   {{ ms_files_grouped }}
create_msmulti_map.control.mapfile_dir                   =   input.output.mapfile_dir
create_msmulti_map.control.filename                      =   input_files_grouped.mapfile

# create a mapfile with the direction-independent parmDBs from supplied list, length = nfiles
create_parmdb_map.control.kind                           =   plugin
create_parmdb_map.control.type                           =   addListMapfile
create_parmdb_map.control.hosts                          =   {{ hosts }}
create_parmdb_map.control.files                          =   {{ dir_indep_parmDBs }}
create_parmdb_map.control.mapfile_dir                    =   input.output.mapfile_dir
create_parmdb_map.control.filename                       =   dir_indep_instrument_parmdbs.mapfile

# create a mapfile with the current skymodels from supplied list, length = nbands
create_full_skymodels_map.control.kind                   =   plugin
create_full_skymodels_map.control.type                   =   addListMapfile
create_full_skymodels_map.control.hosts                  =   {{ hosts }}
create_full_skymodels_map.control.files                  =   {{ skymodels }}
create_full_skymodels_map.control.mapfile_dir            =   input.output.mapfile_dir
create_full_skymodels_map.control.filename               =   full_skymodels.mapfile

# extract the skymodel for this facet from global skymodel, length = nbands
make_facet_skymodels_all.control.type                    =   make_facet_skymodel
make_facet_skymodels_all.control.mapfile_in              =   create_full_skymodels_map.output.mapfile
make_facet_skymodels_all.control.inputkey                =   fullmodelfile
make_facet_skymodels_all.control.outputkey               =   outfile
make_facet_skymodels_all.argument.flags                  =   [fullmodelfile,outfile,{{ vertices_file }}]
make_facet_skymodels_all.argument.cal_only               =   True

# convert the facet skymodel into a sourcedb, length = nbands
make_sourcedb_all_facet_sources.control.type             =   make_sourcedb
make_sourcedb_all_facet_sources.control.opts.mapfile_in  =   make_facet_skymodels_all.output.mapfile
make_sourcedb_all_facet_sources.control.opts.inputkey    =   in
make_sourcedb_all_facet_sources.argument.format          =   <
make_sourcedb_all_facet_sources.argument.outtype         =   blob

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_all_facet_sources.control.kind           =   plugin
expand_sourcedb_all_facet_sources.control.type           =   mapfileSingleToGroup
expand_sourcedb_all_facet_sources.control.mapfile_in     =   make_sourcedb_all_facet_sources.output.mapfile
expand_sourcedb_all_facet_sources.control.mapfile_groups =   create_msmulti_map.output.mapfile
expand_sourcedb_all_facet_sources.control.mapfile_dir    =   input.output.mapfile_dir
expand_sourcedb_all_facet_sources.control.filename       =   expand_sourcedb_all_facet_sources.mapfile

# Add sources, but don't phase shift. We will use these data later        / length = nfiles
# to subtract the outlier model using the direction-dependent calibration
# to create improved "empty" datasets
add_all_facet_sources.control.type                       =   dppp
add_all_facet_sources.control.opts.mapfiles_in           =   [create_ms_map.output.mapfile,expand_sourcedb_all_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
add_all_facet_sources.control.opts.inputkeys             =   [msin,sourcedb,parmdb]
add_all_facet_sources.argument.numthreads                =   {{ max_cpus_per_io_proc_nfiles }}
add_all_facet_sources.argument.msin.datacolumn           =   {{ subtracted_data_colname }}
add_all_facet_sources.argument.msout.overwrite           =   True
add_all_facet_sources.argument.msout.writefullresflag    =   False
add_all_facet_sources.argument.local_scratch_dir         =   {{ local_dir }}
add_all_facet_sources.argument.steps                     =   [add]
add_all_facet_sources.argument.add.type                  =   predict
add_all_facet_sources.argument.add.sourcedb              =   sourcedb
add_all_facet_sources.argument.add.operation             =   add
add_all_facet_sources.argument.add.applycal.parmdb       =   parmdb

# Phase shift and average in preparation for calibration, length = nfiles
shift_and_average.control.type                           =   dppp
shift_and_average.control.mapfile_in                     =   add_all_facet_sources.output.mapfile
shift_and_average.control.inputkey                       =   msin
shift_and_average.argument.numthreads                    =   {{ max_cpus_per_io_proc_nfiles }}
shift_and_average.argument.msin.datacolumn               =   DATA
shift_and_average.argument.msout.overwrite               =   True
shift_and_average.argument.msout.writefullresflag        =   False
shift_and_average.argument.local_scratch_dir             =   {{ local_dir }}
shift_and_average.argument.steps                         =   [shift,avg]
shift_and_average.argument.shift.type                    =   phaseshifter
shift_and_average.argument.shift.phasecenter             =   [{{ ra }}deg, {{ dec }}deg]
shift_and_average.argument.avg.type                      =   squash
shift_and_average.argument.avg.freqstep                  =   {{ facetselfcal_freqstep }}
shift_and_average.argument.avg.timestep                  =   1

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile.control.kind                   =   plugin
create_compressed_mapfile.control.type                   =   compressMapfile
create_compressed_mapfile.control.mapfile_in             =   shift_and_average.output.mapfile
create_compressed_mapfile.control.mapfile_dir            =   input.output.mapfile_dir
create_compressed_mapfile.control.filename               =   concat_averaged_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes * num_cal_blocks
sort_into_Groups.control.type                            =   sort_times_into_freqGroups
sort_into_Groups.argument.flags                          =   [create_compressed_mapfile.output.mapfile]
sort_into_Groups.argument.filename                       =   sorted_groups.mapfile
sort_into_Groups.argument.mapfile_dir                    =   input.output.mapfile_dir
sort_into_Groups.argument.hosts                          =   {{ hosts }}
sort_into_Groups.argument.stepname                       =   sort_into_Groups
{% if num_cal_blocks > 1 %}
sort_into_Groups.argument.numSB                          =   {{ num_bands_per_cal_block }}
{% endif %}

# convert the output of sort_into_Groups into usable mapfiles, len = 1 / (ntimes * num_cal_blocks)
sort_into_Groups_maps.control.kind                       =   plugin
sort_into_Groups_maps.control.type                       =   mapfilenamesFromMapfiles
sort_into_Groups_maps.control.mapfile_groupmap           =   sort_into_Groups.output.groupmapfile.mapfile
sort_into_Groups_maps.control.mapfile_filesmap           =   sort_into_Groups.output.mapfile.mapfile

# concat data in frequency, length = ntimes * num_cal_blocks
concat_data.control.type                                 =   dppp
concat_data.control.mapfile_out                          =   sort_into_Groups_maps.output.groupmap
concat_data.control.mapfile_in                           =   sort_into_Groups_maps.output.filesmap
concat_data.control.inputkey                             =   msin
concat_data.argument.numthreads                          =   {{ max_cpus_per_io_proc_ntimes }}
concat_data.argument.msin.datacolumn                     =   DATA
concat_data.argument.msin.missingdata                    =   True
concat_data.argument.msin.orderms                        =   False
concat_data.argument.msout.overwrite                     =   True
concat_data.argument.msout.writefullresflag              =   False
concat_data.argument.local_scratch_dir                   =   {{ local_dir }}
concat_data.argument.steps                               =   []

# make compressed mapfile for concatenated data MSs, length = 1
concat_data_compressed_mapfile.control.kind              =   plugin
concat_data_compressed_mapfile.control.type              =   compressMapfile
concat_data_compressed_mapfile.control.mapfile_in        =   concat_data.output.mapfile
concat_data_compressed_mapfile.control.mapfile_dir       =   input.output.mapfile_dir
concat_data_compressed_mapfile.control.filename          =   concat_chunks_input.mapfile

{% if pre_average %}
# re-group shift_and_average mapfile to have one group per band, length = nbands
regroup_shift_and_average.control.kind                   =   plugin
regroup_shift_and_average.control.type                   =   reGroupMapfile
regroup_shift_and_average.control.mapfile_in             =   shift_and_average.output.mapfile
regroup_shift_and_average.control.mapfile_groups         =   create_msmulti_map.output.mapfile
regroup_shift_and_average.control.mapfile_dir            =   input.output.mapfile_dir
regroup_shift_and_average.control.filename               =   re_grouped_shift_and_average.mapfile

# re-group dir-independent parmdb mapfile to have one group per band, length = nbands
regroup_parmdb.control.kind                              =   plugin
regroup_parmdb.control.type                              =   reGroupMapfile
regroup_parmdb.control.mapfile_in                        =   create_parmdb_map.output.mapfile
regroup_parmdb.control.mapfile_groups                    =   create_msmulti_map.output.mapfile
regroup_parmdb.control.check_basename                    =   False
regroup_parmdb.control.mapfile_dir                       =   input.output.mapfile_dir
regroup_parmdb.control.filename                          =   re_grouped_parmdb.mapfile

# Do the baseline-dependent preaveraging. This must be done after concatenation  // length = nbands
# of DATA in the previous step so that we can safely overwrite the
# WEIGHT_SPECTRUM column
pre_average.control.type                                 =   pre_average
pre_average.control.mapfiles_in                          =   [regroup_shift_and_average.output.mapfile,regroup_parmdb.output.mapfile]
pre_average.control.inputkeys                            =   [datafile,parmdb]
pre_average.argument.flags                               =   [datafile,parmdb,DATA,BLAVG_DATA,{{ target_rms_rad }}]

# make mapfile for concatenated corrected data, length = ntimes * num_cal_blocks
make_blavg_data_mapfile.control.kind                     =  plugin
make_blavg_data_mapfile.control.type                     =  createMapfile
make_blavg_data_mapfile.control.method                   =  add_suffix_to_file
make_blavg_data_mapfile.control.mapfile_in               =  sort_into_Groups_maps.output.groupmap
make_blavg_data_mapfile.control.add_suffix_to_file       =  "_blavg.ms"
make_blavg_data_mapfile.control.mapfile_dir              =  input.output.mapfile_dir
make_blavg_data_mapfile.control.filename                 =  make_blavg_data.mapfile

# Concat the preaveraged data (and weights), len = ntimes * num_cal_blocks
concat_blavg_data.control.type                           =   dppp
concat_blavg_data.control.mapfile_out                    =   make_blavg_data_mapfile.output.mapfile
concat_blavg_data.control.mapfile_in                     =   sort_into_Groups_maps.output.filesmap
concat_blavg_data.control.inputkey                       =   msin
concat_blavg_data.argument.numthreads                    =   {{ max_cpus_per_io_proc_ntimes }}
concat_blavg_data.argument.msin.datacolumn               =   BLAVG_DATA
concat_blavg_data.argument.msin.missingdata              =   True
concat_blavg_data.argument.msin.orderms                  =   False
concat_blavg_data.argument.msout.overwrite               =   True
concat_blavg_data.argument.msout.writefullresflag        =   False
concat_blavg_data.argument.local_scratch_dir             =   {{ local_dir }}
concat_blavg_data.argument.steps                         =   []

# Copy BLAVG_DATA, length = ntimes * num_cal_blocks
copy_column1.control.type                                =   copy_column
copy_column1.control.mapfiles_in                         =   [concat_blavg_data.output.mapfile,concat_data.output.mapfile]
copy_column1.control.inputkeys                           =   [blavgfile,datafile]
copy_column1.argument.flags                              =   [blavgfile,datafile,DATA,BLAVG_DATA]

# Copy BLAVG_WEIGHT_SPECTRUM, length = ntimes * num_cal_blocks
copy_column2.control.type                                =   copy_column
copy_column2.control.mapfiles_in                         =   [concat_blavg_data.output.mapfile,concat_data.output.mapfile]
copy_column2.control.inputkeys                           =   [blavgfile,datafile]
copy_column2.argument.flags                              =   [blavgfile,datafile,WEIGHT_SPECTRUM,{{ blavg_weight_column }}]
{% endif %}

# switch "normal" weights with block-average weigthts, length = nfiles
switch_weights_col1.control.type                         =   switch_columns
switch_weights_col1.control.mapfile_in                   =   concat_data.output.mapfile
switch_weights_col1.control.inputkey                     =   msfiles
switch_weights_col1.argument.flags                       =   [msfiles,WEIGHT_SPECTRUM,{{ blavg_weight_column }}]

# generate mapfile for the fast-phase parmDBs generated in the solve_ampphase11 step, length = ntimes * num_cal_blocks
make_fast_phase_parmdb_map.control.kind                  =  plugin
make_fast_phase_parmdb_map.control.type                  =  createMapfile
make_fast_phase_parmdb_map.control.method                =  add_suffix_to_file
make_fast_phase_parmdb_map.control.mapfile_in            =  concat_data.output.mapfile
make_fast_phase_parmdb_map.control.add_suffix_to_file    =  /instrument
make_fast_phase_parmdb_map.control.mapfile_dir           =  input.output.mapfile_dir
make_fast_phase_parmdb_map.control.filename              =  fast_parmdb.mapfile

# create a mapfile with the outlier skymodel from supplied list, length = 1
create_peel_skymodel_map.control.kind                    =   plugin
create_peel_skymodel_map.control.type                    =   addListMapfile
create_peel_skymodel_map.control.hosts                   =   {{ hosts }}
create_peel_skymodel_map.control.files                   =   [{{ peel_skymodel }}]
create_peel_skymodel_map.control.mapfile_dir             =   input.output.mapfile_dir
create_peel_skymodel_map.control.filename                =   peel_skymodel.mapfile

# convert the outlier skymodel into a sourcedb, length = 1
make_peel_sourcedb.control.type                          =   make_sourcedb
make_peel_sourcedb.control.opts.mapfile_in               =   create_peel_skymodel_map.output.mapfile
make_peel_sourcedb.control.opts.inputkey                 =   in
make_peel_sourcedb.argument.format                       =   <
make_peel_sourcedb.argument.outtype                      =   blob

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_peel_sourcedb_map.control.kind                    =   plugin
expand_peel_sourcedb_map.control.type                    =   expandMapfile
expand_peel_sourcedb_map.control.mapfile_in              =   make_peel_sourcedb.output.mapfile
expand_peel_sourcedb_map.control.mapfile_to_match        =   concat_data.output.mapfile
expand_peel_sourcedb_map.control.mapfile_dir             =   input.output.mapfile_dir
expand_peel_sourcedb_map.control.filename                =   expand_peel_sourcedb.mapfile

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs11.control.type                            =   remove_file
remove_parmdbs11.control.mapfile_in                      =   make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs11.control.inputkey                        =   parmdb
remove_parmdbs11.argument.flags                          =   [-rf,parmdb]

# run GainCal with peel sourcedb on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase11.control.type                            =   dppp_inplace
solve_ampphase11.control.mapfiles_in                     =   [concat_data.output.mapfile,make_fast_phase_parmdb_map.output.mapfile,expand_peel_sourcedb_map.output.mapfile]
solve_ampphase11.control.inputkeys                       =   [msin,parmdb,sourcedb]
solve_ampphase11.argument.numthreads                     =   {{ max_cpus_per_io_proc_ntimes }}
solve_ampphase11.argument.msin.datacolumn                =   {{ data_column }}
solve_ampphase11.argument.msout                          =   .
solve_ampphase11.argument.steps                          =   [uvcut,solvetec]
solve_ampphase11.argument.uvcut.type                     =   uvwflagger
solve_ampphase11.argument.uvcut.uvlambdamin              =   {{ solve_min_uv_lambda }}
solve_ampphase11.argument.solvetec.type                  =   gaincal
solve_ampphase11.argument.solvetec.caltype               =   tecandphase
solve_ampphase11.argument.solvetec.parmdb                =   parmdb
solve_ampphase11.argument.solvetec.usemodelcolumn        =   False
solve_ampphase11.argument.solvetec.sourcedb              =   sourcedb
solve_ampphase11.argument.solvetec.solint                =   {{ solint_time_p }}
solve_ampphase11.argument.solvetec.nchan                 =   {{ solint_freq_a }}

# switch the weights back, length = ntimes
switch_weights_col2.control.type                         =   switch_columns
switch_weights_col2.control.mapfile_in                   =   concat_data.output.mapfile
switch_weights_col2.control.inputkey                     =   msfiles
switch_weights_col2.argument.flags                       =   [msfiles,WEIGHT_SPECTRUM,{{ blavg_weight_column }}]

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase11.control.type                            =   dppp_inplace
apply_ampphase11.control.opts.mapfiles_in                =   [concat_data.output.mapfile,make_fast_phase_parmdb_map.output.mapfile]
apply_ampphase11.control.opts.inputkeys                  =   [msin,parmdb]
apply_ampphase11.argument.numthreads                     =   {{ max_cpus_per_proc_ntimes }}
apply_ampphase11.argument.msin.datacolumn                =   DATA
apply_ampphase11.argument.msout                          =   .
apply_ampphase11.argument.msout.datacolumn               =   CORRECTED_DATA
apply_ampphase11.argument.steps                          =   [correct_fast1,correct_fast2]
apply_ampphase11.argument.correct_fast1.type             =   applycal
apply_ampphase11.argument.correct_fast1.parmdb           =   parmdb
apply_ampphase11.argument.correct_fast1.correction       =   tec
apply_ampphase11.argument.correct_fast1.invert           =   True
apply_ampphase11.argument.correct_fast2.type             =   applycal
apply_ampphase11.argument.correct_fast2.parmdb           =   parmdb
apply_ampphase11.argument.correct_fast2.correction       =   commonscalarphase
apply_ampphase11.argument.correct_fast2.invert           =   True

# merge the parmDBs with the phase solutions into one, length = 1
merge_phase_parmdbs.control.type                         =   merge_parmdbs_in_time
merge_phase_parmdbs.control.mapfile_in                   =   concat_data_compressed_mapfile.output.mapfile
merge_phase_parmdbs.control.inputkey                     =   mslist
merge_phase_parmdbs.control.outputkey                    =   outparmdb
merge_phase_parmdbs.argument.flags                       =   [mslist,instrument,outparmdb]

# generate mapfile for the slow-gain parmDBs generated in the solve_ampphase12 step, length = ntimes * num_cal_blocks
make_slow_gain_parmdb_map.control.kind                   =  plugin
make_slow_gain_parmdb_map.control.type                   =  createMapfile
make_slow_gain_parmdb_map.control.method                 =  add_suffix_to_file
make_slow_gain_parmdb_map.control.mapfile_in             =  concat_data.output.mapfile
make_slow_gain_parmdb_map.control.add_suffix_to_file     =  /instrument_slow
make_slow_gain_parmdb_map.control.mapfile_dir            =  input.output.mapfile_dir
make_slow_gain_parmdb_map.control.filename               =  slow_parmdb.mapfile

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs12.control.type                            =   remove_file
remove_parmdbs12.control.mapfile_in                      =   make_slow_gain_parmdb_map.output.mapfile
remove_parmdbs12.control.inputkey                        =   parmdb
remove_parmdbs12.argument.flags                          =   [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase12.control.type                            =   dppp_inplace
solve_ampphase12.control.mapfiles_in                     =   [concat_data.output.mapfile,make_slow_gain_parmdb_map.output.mapfile,expand_peel_sourcedb_map.output.mapfile]
solve_ampphase12.control.inputkeys                       =   [msin,parmdb,sourcedb]
solve_ampphase12.argument.numthreads                     =   {{ max_cpus_per_io_proc_ntimes }}
solve_ampphase12.argument.msin.datacolumn                =   CORRECTED_DATA
solve_ampphase12.argument.msout                          =   .
solve_ampphase12.argument.steps                          =   [uvcut,solvegain]
solve_ampphase12.argument.uvcut.type                     =   uvwflagger
solve_ampphase12.argument.uvcut.uvlambdamin              =   {{ solve_min_uv_lambda }}
solve_ampphase12.argument.solvegain.type                 =   gaincal
solve_ampphase12.argument.solvegain.caltype              =   {{ selfcal_caltype }}
solve_ampphase12.argument.solvegain.parmdb               =   parmdb
solve_ampphase12.argument.solvegain.sourcedb             =   sourcedb
solve_ampphase12.argument.solvegain.solint               =   {{ solint_time_a }}
solve_ampphase12.argument.solvegain.nchan                =   {{ solint_freq_a }}

# merge the parmDBs with the amplitude solutions into one, length = 1
merge_amp_parmdbs.control.type                           =   merge_parmdbs_in_time
merge_amp_parmdbs.control.mapfile_in                     =   concat_data_compressed_mapfile.output.mapfile
merge_amp_parmdbs.control.inputkey                       =   mslist
merge_amp_parmdbs.control.outputkey                      =   outparmdb
merge_amp_parmdbs.argument.flags                         =   [mslist,instrument_slow,outparmdb]

# Smooth the amplitude solutions, but do not normalize them as the sky model is  // length = 1
# in absolute flux and not apparent flux
smooth_amps.control.type                                 =   {{ smooth_amps_task }}
smooth_amps.control.mapfile_in                           =   merge_amp_parmdbs.output.mapfile
smooth_amps.control.inputkey                             =   ampparmdb
smooth_amps.control.outputkey                            =   outparmdb
smooth_amps.control.arguments                            =   [ampparmdb,outparmdb]
smooth_amps.argument.normalize                           =   False

# Now smooth the amplitude solutions and normalize them (for use later during
# imaging of facets for peeled calibrators), length = 1
smooth_amps_normalized.control.type                      =   {{ smooth_amps_task }}
smooth_amps_normalized.control.mapfile_in                =   merge_amp_parmdbs.output.mapfile
smooth_amps_normalized.control.inputkey                  =   ampparmdb
smooth_amps_normalized.control.outputkey                 =   outparmdb
smooth_amps_normalized.control.arguments                 =   [ampparmdb,outparmdb]
smooth_amps_normalized.argument.normalize                =   True

# merge the phases and amplitudes parmDBs, length = 1
merge_selfcal_parmdbs.control.type                       =   merge_parmdbs_selfcal
merge_selfcal_parmdbs.control.mapfiles_in                =   [merge_phase_parmdbs.output.mapfile,smooth_amps.output.mapfile]
merge_selfcal_parmdbs.control.inputkeys                  =   [parmdb_p,parmdb_a]
merge_selfcal_parmdbs.control.outputkey                  =   parmdb_out
merge_selfcal_parmdbs.argument.flags                     =   [parmdb_p,parmdb_a,parmdb_out]

# merge the phases and normalized amplitudes parmDBs, length = 1
merge_normalized_selfcal_parmdbs.control.type            =   merge_parmdbs_selfcal
merge_normalized_selfcal_parmdbs.control.mapfiles_in     =   [merge_phase_parmdbs.output.mapfile,smooth_amps_normalized.output.mapfile]
merge_normalized_selfcal_parmdbs.control.inputkeys       =   [parmdb_p,parmdb_a]
merge_normalized_selfcal_parmdbs.control.outputkey       =   parmdb_out
merge_normalized_selfcal_parmdbs.argument.flags          =   [parmdb_p,parmdb_a,parmdb_out]

{% if create_preapply_parmdb %}
# make a phase-only parmDB suitable for preapplication, length = 1
create_preapply_parmdb.control.type                      =   reset_amps
create_preapply_parmdb.control.mapfile_in                =   merge_selfcal_parmdbs.output.mapfile
create_preapply_parmdb.control.inputkey                  =   inparmdb
create_preapply_parmdb.control.outputkey                 =   outparmdb
create_preapply_parmdb.control.arguments                 =   [inparmdb,outparmdb]
{% endif %}

# make plots of the selfcal results (normalized) from the marged parmDB, length = 1
make_selfcal_plots.control.type                          =   make_selfcal_plots
make_selfcal_plots.control.mapfile_in                    =   merge_normalized_selfcal_parmdbs.output.mapfile
make_selfcal_plots.control.inputkeys                     =   parmdb
make_selfcal_plots.control.outputkey                     =   plots_root
make_selfcal_plots.argument.flags                        =   [parmdb,plots_root]
make_selfcal_plots.argument.fourpol                      =   {{ fourpol }}

# expand the merged parmDB to all files, length = nfiles
expand_merged_parmdb_map.control.kind                    =   plugin
expand_merged_parmdb_map.control.type                    =   expandMapfile
expand_merged_parmdb_map.control.mapfile_in              =   merge_selfcal_parmdbs.output.mapfile
expand_merged_parmdb_map.control.mapfile_to_match        =   add_all_facet_sources.output.mapfile
expand_merged_parmdb_map.control.mapfile_dir             =   input.output.mapfile_dir
expand_merged_parmdb_map.control.filename                =   expand_merged_parmdbs.mapfile

# create a mapfile with the outlier skymodel, length = 1
create_outlier_skymodel_map.control.kind                 =   plugin
create_outlier_skymodel_map.control.type                 =   addListMapfile
create_outlier_skymodel_map.control.hosts                =   {{ hosts }}
create_outlier_skymodel_map.control.files                =   [{{ peel_skymodel }}]
create_outlier_skymodel_map.control.mapfile_dir          =   input.output.mapfile_dir
create_outlier_skymodel_map.control.filename             =   outlier_skymodel.mapfile

# convert the outlier skymodel into a sourcedb, length = 1
make_sourcedb_outlier_model.control.type                 =   make_sourcedb
make_sourcedb_outlier_model.control.opts.mapfile_in      =   create_outlier_skymodel_map.output.mapfile
make_sourcedb_outlier_model.control.opts.inputkey        =   in
make_sourcedb_outlier_model.argument.format              =   <
make_sourcedb_outlier_model.argument.outtype             =   blob

# expand the sourcedb to all files, length = nfiles
expand_sourcedb_outlier_map.control.kind                 =   plugin
expand_sourcedb_outlier_map.control.type                 =   expandMapfile
expand_sourcedb_outlier_map.control.mapfile_in           =   make_sourcedb_outlier_model.output.mapfile
expand_sourcedb_outlier_map.control.mapfile_to_match     =   add_all_facet_sources.output.mapfile
expand_sourcedb_outlier_map.control.mapfile_dir          =   input.output.mapfile_dir
expand_sourcedb_outlier_map.control.filename             =   expand_sourcedb_outlier.mapfile

# Predict the outlier model data at the field phase center, length = nfiles
predict_outlier_model.control.type                       =   dppp
predict_outlier_model.control.opts.mapfiles_in           =   [add_all_facet_sources.output.mapfile,expand_sourcedb_outlier_map.output.mapfile]
predict_outlier_model.control.opts.inputkeys             =   [msin,sourcedb]
predict_outlier_model.argument.numthreads                =   {{ max_cpus_per_io_proc_nfiles }}
predict_outlier_model.argument.msin.datacolumn           =   DATA
predict_outlier_model.argument.msout.overwrite           =   True
predict_outlier_model.argument.msout.writefullresflag    =   False
predict_outlier_model.argument.local_scratch_dir         =   {{ local_dir }}
predict_outlier_model.argument.steps                     =   [predict]
predict_outlier_model.argument.predict.type              =   predict
predict_outlier_model.argument.predict.sourcedb          =   sourcedb
predict_outlier_model.argument.predict.operation         =   replace

# Corrupt the outlier model data with new calibration tables, length = nfiles
corrupt_outlier_model.control.type                       =   dppp
corrupt_outlier_model.control.opts.mapfiles_in           =   [predict_outlier_model.output.mapfile,expand_merged_parmdb_map.output.mapfile]
corrupt_outlier_model.control.opts.inputkeys             =   [msin,parmdb]
corrupt_outlier_model.argument.numthreads                =   {{ max_cpus_per_io_proc_nfiles }}
corrupt_outlier_model.argument.msin.datacolumn           =   DATA
corrupt_outlier_model.argument.msout.overwrite           =   True
corrupt_outlier_model.argument.msout.writefullresflag    =   False
corrupt_outlier_model.argument.local_scratch_dir         =   {{ local_dir }}
corrupt_outlier_model.argument.steps                     =   [corrupt_fast1,corrupt_fast2,corrupt_slow]
corrupt_outlier_model.argument.corrupt_fast1.type        =   applycal
corrupt_outlier_model.argument.corrupt_fast1.parmdb      =   parmdb
corrupt_outlier_model.argument.corrupt_fast1.correction  =   tec
corrupt_outlier_model.argument.corrupt_fast1.invert      =   False
corrupt_outlier_model.argument.corrupt_fast2.type        =   applycal
corrupt_outlier_model.argument.corrupt_fast2.parmdb      =   parmdb
corrupt_outlier_model.argument.corrupt_fast2.correction  =   commonscalarphase
corrupt_outlier_model.argument.corrupt_fast2.invert      =   False
corrupt_outlier_model.argument.corrupt_slow.type         =   applycal
corrupt_outlier_model.argument.corrupt_slow.parmdb       =   parmdb
corrupt_outlier_model.argument.corrupt_slow.invert       =   False

# Subtract the corrupted model from the data to make improved subtracted datasets, length = nfiles
subtract_outlier_model.control.type                      =   add_subtract_columns
subtract_outlier_model.control.opts.mapfiles_in          =   [add_all_facet_sources.output.mapfile,corrupt_outlier_model.output.mapfile]
subtract_outlier_model.control.opts.inputkeys            =   [file1,file2]
subtract_outlier_model.argument.flags                    =   [file1,file2,DATA,DATA,SUBTRACTED_DATA_ALL,subtract]

# make a map with original data of only the central frequency band, length = ntimes
create_middle_pre_band_mapfile.control.kind              =   plugin
create_middle_pre_band_mapfile.control.type              =   selectMiddleFreq
create_middle_pre_band_mapfile.control.mapfile_in        =   create_ms_map.output.mapfile
create_middle_pre_band_mapfile.control.mapfile_dir       =   input.output.mapfile_dir
create_middle_pre_band_mapfile.control.filename          =   single_pre.mapfile

# make a map with new data of only the central frequency band, length = ntimes
create_middle_post_mapfile.control.kind                  =   plugin
create_middle_post_mapfile.control.type                  =   selectMatching
create_middle_post_mapfile.control.mapfile_in            =   add_all_facet_sources.output.mapfile
create_middle_post_mapfile.control.mapfile_reference     =   create_middle_pre_band_mapfile.output.mapfile
create_middle_post_mapfile.control.mapfile_dir           =   input.output.mapfile_dir
create_middle_post_mapfile.control.filename              =   single_post.mapfile

# average old empty data, length = ntimes
average_pre.control.type                                 =   dppp
average_pre.control.mapfile_in                           =   create_middle_pre_band_mapfile.output.mapfile
average_pre.control.inputkey                             =   msin
average_pre.argument.numthreads                          =   {{ max_cpus_per_io_proc_ntimes }}
average_pre.argument.msin.datacolumn                     =   SUBTRACTED_DATA_ALL
average_pre.argument.msout.overwrite                     =   True
average_pre.argument.msout.writefullresflag              =   False
average_pre.argument.local_scratch_dir                   =   {{ local_dir }}
average_pre.argument.steps                               =   [uv,avg]
average_pre.argument.uv.type                             =   uvwflagger
average_pre.argument.uv.uvmmax                           =   2500.0
average_pre.argument.avg.type                            =   squash
average_pre.argument.avg.freqstep                        =   {{ verify_freqstep }}
average_pre.argument.avg.timestep                        =   {{ verify_timestep }}

# average "old minus new" facet data (= new empty data), length = ntimes
average_post.control.type                                =   dppp
average_post.control.mapfile_in                          =   create_middle_post_mapfile.output.mapfile
average_post.control.inputkey                            =   msin
average_post.argument.numthreads                         =   {{ max_cpus_per_io_proc_ntimes }}
average_post.argument.msin.datacolumn                    =   SUBTRACTED_DATA_ALL
average_post.argument.msout.overwrite                    =   True
average_post.argument.msout.writefullresflag             =   False
average_post.argument.local_scratch_dir                  =   {{ local_dir }}
average_post.argument.steps                              =   [uv,avg]
average_post.argument.uv.type                            =   uvwflagger
average_post.argument.uv.uvmmax                          =   2500.0
average_post.argument.avg.type                           =   squash
average_post.argument.avg.freqstep                       =   {{ verify_freqstep }}
average_post.argument.avg.timestep                       =   {{ verify_timestep }}

# make compressed mapfile of old empty data, length = 1
average_pre_compressed_map.control.kind                  =   plugin
average_pre_compressed_map.control.type                  =   compressMapfile
average_pre_compressed_map.control.mapfile_in            =   average_pre.output.mapfile
average_pre_compressed_map.control.mapfile_dir           =   input.output.mapfile_dir
average_pre_compressed_map.control.filename              =   average_pre_compressed.mapfile

# image the of old empty data, length = 1
wsclean_pre.control.type                                 =   wsclean
wsclean_pre.control.mapfile_in                           =   average_pre_compressed_map.output.mapfile
wsclean_pre.control.inputkey                             =   msfile
wsclean_pre.argument.flags                               =   [-no-update-model-required,msfile]
wsclean_pre.argument.size                                =   2048 2048
wsclean_pre.argument.niter                               =   10
wsclean_pre.argument.threshold                           =   0.0
wsclean_pre.argument.pol                                 =   I
wsclean_pre.argument.weight                              =   briggs -0.5
wsclean_pre.argument.mgain                               =   0.5
wsclean_pre.argument.gain                                =   0.1
wsclean_pre.argument.cleanborder                         =   0
wsclean_pre.argument.minuv-l                             =   {{ facet_min_uv_lambda }}
wsclean_pre.argument.maxuv-l                             =   2500
wsclean_pre.argument.scale                               =   0.00833
wsclean_pre.argument.mem                                 =   {{ max_percent_memory_per_proc_single }}
wsclean_pre.argument.j                                   =   {{ max_cpus_per_proc_single }}

# make compressed mapfile of new empty data, length = 1
average_post_compressed_map.control.kind                 =   plugin
average_post_compressed_map.control.type                 =   compressMapfile
average_post_compressed_map.control.mapfile_in           =   average_post.output.mapfile
average_post_compressed_map.control.mapfile_dir          =   input.output.mapfile_dir
average_post_compressed_map.control.filename             =   average_post_compressed.mapfile

# image the of new empty data, length = 1
wsclean_post.control.type                                =   wsclean
wsclean_post.control.mapfile_in                          =   average_post_compressed_map.output.mapfile
wsclean_post.control.inputkey                            =   msfile
wsclean_post.argument.flags                              =   [-no-update-model-required,msfile]
wsclean_post.argument.size                               =   2048 2048
wsclean_post.argument.niter                              =   10
wsclean_post.argument.threshold                          =   0.0
wsclean_post.argument.pol                                =   I
wsclean_post.argument.weight                             =   briggs -0.5
wsclean_post.argument.mgain                              =   0.5
wsclean_post.argument.gain                               =   0.1
wsclean_post.argument.cleanborder                        =   0
wsclean_post.argument.minuv-l                            =   {{ facet_min_uv_lambda }}
wsclean_post.argument.maxuv-l                            =   2500
wsclean_post.argument.scale                              =   0.00833
wsclean_post.argument.mem                                =   {{ max_percent_memory_per_proc_single }}
wsclean_post.argument.j                                  =   {{ max_cpus_per_proc_single }}

# do a "verify_subtract" on the two "empty" images, length = 1
verify_subtract.control.type                             =   verify_subtract
verify_subtract.control.mapfiles_in                      =   [wsclean_pre.output.wsclean_pre-image.fits.mapfile,wsclean_post.output.wsclean_post-image.fits.mapfile]
verify_subtract.control.inputkeys                        =   [image_pre,image_post]
verify_subtract.argument.flags                           =   [image_pre,image_post,0.75]

# expand the verify_subtract results so that there is one entry for every file, length = nfiles
expand_verify_subtract_map.control.kind                  =   plugin
expand_verify_subtract_map.control.type                  =   expandMapfile
expand_verify_subtract_map.control.mapfile_in            =   verify_subtract.output.break.mapfile
expand_verify_subtract_map.control.mapfile_to_match      =   create_ms_map.output.mapfile
expand_verify_subtract_map.control.mapfile_dir           =   input.output.mapfile_dir
expand_verify_subtract_map.control.filename              =   expand_verify_subtract_map.mapfile

# if verify_subtract returns "True" subtract model difference from outlier-cal to original data, length = nfiles
copy_to_empty_data.control.type                          =   copy_column
copy_to_empty_data.control.mapfiles_in                   =   [add_all_facet_sources.output.mapfile,create_ms_map.output.mapfile,expand_verify_subtract_map.output.mapfile]
copy_to_empty_data.control.inputkeys                     =   [file1,file2,do_copy]
copy_to_empty_data.argument.flags                        =   [file1,file2,SUBTRACTED_DATA_ALL,SUBTRACTED_DATA_ALL_NEW]
copy_to_empty_data.argument.do_copy                      =   do_copy
