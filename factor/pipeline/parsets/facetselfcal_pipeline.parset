pipeline.steps = [update_mapfile_hosts, create_ms_map, create_msmulti_map, create_parmdb_map, create_full_skymodels_map, make_facet_skymodels_all, make_sourcedb_all_facet_sources, expand_sourcedb_all_facet_sources, make_facet_skymodels_cal, make_sourcedb_cal_facet_sources, expand_sourcedb_cal_facet_sources, shift_empty, predict_all_model_data, add_all_facet_sources, {% if preapply_phase_cal %} expand_preapply_parmdb_map, {% endif %} shift_cal, {% if preapply_phase_cal %} shift_cal_dir_indep, {% endif %} create_compressed_mapfile_data, sort_into_Groups, sort_into_Groups_maps, concat_data, {% if pre_average %} regroup_shift_cal, regroup_parmdb, pre_average, make_blavg_data_mapfile, concat_blavg_data, copy_column1, copy_column2, {% endif %} {% if selfcal_local_dir is not none %} make_concat_data_sync_mapfile, adjust_concat_data_hosts, sync_concat_data_to_local, {% endif %} concat_data_compressed_mapfile, {% if not preapply_phase_cal %} average0, {% endif %} create_compressed_mapfile0, sort_average0_into_Groups, sort_average0_into_Groups_maps, concat_average0_data, create_compressed_mapfile01, premask_selfcal, wsclean_image01, create_imagebase_map01, adjust_wsclean_mapfile0, mask0, wsclean_image02, create_imagebase_map02, pad_selfcal_model0_images, regroup_concat_data_map, create_expanded_model0_mapfile, expand_selfcal_model_size_map, wsclean_ft0, {% if pre_average %} switch_data_weights_col1, {% endif %} make_fast_phase_parmdb_map, {% if peel_skymodel is not none %} create_peel_skymodel_map, make_peel_sourcedb, expand_peel_sourcedb_map, {% endif %} remove_parmdbs1, solve_phaseonly1, {% if pre_average %} switch_data_weights_col2, {% endif %} {% if selfcal_local_dir is not none %} make_apply_mapfile, {% endif %} apply_phaseonly1, create_compressed_mapfile1, wsclean_image11, create_imagebase_map11, adjust_wsclean_mapfile11, mask1, wsclean_image12, create_imagebase_map12, create_expanded_model1_mapfile, pad_selfcal_model1_images, wsclean_ft1, {% if pre_average %} switch_data_weights_col3, {% endif %} remove_parmdbs2, solve_phaseonly2, {% if pre_average %} switch_data_weights_col4, {% endif %} apply_phaseonly2, create_compressed_mapfile2, wsclean_image21, create_imagebase_map21, adjust_wsclean_mapfile21, mask2, wsclean_image22, create_imagebase_map22, create_expanded_model2_mapfile, pad_selfcal_model2_images, wsclean_ft2, {% if pre_average %} switch_data_weights_col5, {% endif %} remove_parmdbs11, solve_ampphase11, {% if pre_average %} switch_data_weights_col6, {% endif %} apply_ampphase11, make_slow_gain_parmdb_map, remove_parmdbs12, solve_ampphase12, merge_amp_parmdbs1, smooth_amp1, expand_smoothed_amp1_parmdb_map, apply_amp1, create_compressed_mapfile3, wsclean_image31, create_imagebase_map31, adjust_wsclean_mapfile31, mask3, wsclean_image32, loop_ampcal, {% if local_dir is not none %} remove_concat_data, {% endif %} merge_selfcal_parmdbs, {% if create_preapply_parmdb %} create_preapply_parmdb, {% endif %} make_selfcal_plots, create_selfcal_images_mapfile, make_selfcal_images, expand_merged_parmdb_map, {% if is_patch or skip_facet_imaging %} create_model4_map, blank_model, {% else %} apply_dir_dep, create_compressed_mapfile5, sort_averaged, sort_averaged_maps, create_compressed_mapfile6, premask, wsclean_image_full1, create_imagebase_map, adjust_wsclean_mapfile1, mask5, wsclean_image_full2, create_model4_map, adjust_wsclean_mapfile2, {% endif %} pad_model_images, create_compressed_mapfile_shift_empty, sort_shift_empty_into_Groups, sort_shift_empty_into_Groups_maps, create_expanded_model_mapfile, expand_facet_model_size_map, wsclean_ft, corrupt_final_model, subtract_initial_final, shift_diff_model_to_field, create_middle_band_mapfile, subtract_single, average_pre, average_post, average_pre_compressed_map, wsclean_pre, average_post_compressed_map, wsclean_post, verify_subtract]

pipeline.pluginpath                                        =   {{ pipeline_dir }}/plugins

update_mapfile_hosts.control.kind                          =   plugin
update_mapfile_hosts.control.type                          =   updateHosts
update_mapfile_hosts.control.mapfile_dir                   =   input.output.mapfile_dir
update_mapfile_hosts.control.hosts                         =   {{ hosts }}

# create a mapfile with all single MSs from supplied list, length = nfiles
create_ms_map.control.kind                                 =   plugin
create_ms_map.control.type                                 =   addListMapfile
create_ms_map.control.hosts                                =   {{ hosts }}
create_ms_map.control.files                                =   {{ ms_files_single }}
create_ms_map.control.mapfile_dir                          =   input.output.mapfile_dir
create_ms_map.control.filename                             =   input_files_single.mapfile

# create a multi-mapfile with the groups of MSs from supplied list, length = nbands
create_msmulti_map.control.kind                            =   plugin
create_msmulti_map.control.type                            =   addListMultiMapfile
create_msmulti_map.control.hosts                           =   {{ hosts }}
create_msmulti_map.control.files                           =   {{ ms_files_grouped }}
create_msmulti_map.control.mapfile_dir                     =   input.output.mapfile_dir
create_msmulti_map.control.filename                        =   input_files_grouped.mapfile

# create a mapfile with the direction-independent parmDBs from supplied list, length = nfiles
create_parmdb_map.control.kind                             =   plugin
create_parmdb_map.control.type                             =   addListMapfile
create_parmdb_map.control.hosts                            =   {{ hosts }}
create_parmdb_map.control.files                            =   {{ dir_indep_parmDBs }}
create_parmdb_map.control.mapfile_dir                      =   input.output.mapfile_dir
create_parmdb_map.control.filename                         =   dir_indep_instrument_parmdbs.mapfile

# create a mapfile with the current skymodels from supplied list, length = nbands
create_full_skymodels_map.control.kind                     =   plugin
create_full_skymodels_map.control.type                     =   addListMapfile
create_full_skymodels_map.control.hosts                    =   {{ hosts }}
create_full_skymodels_map.control.files                    =   {{ skymodels }}
create_full_skymodels_map.control.mapfile_dir              =   input.output.mapfile_dir
create_full_skymodels_map.control.filename                 =   full_skymodels.mapfile

# extract the skymodel for this facet from global skymodel, length = nbands
make_facet_skymodels_all.control.type                      =   make_facet_skymodel
make_facet_skymodels_all.control.mapfile_in                =   create_full_skymodels_map.output.mapfile
make_facet_skymodels_all.control.inputkey                  =   fullmodelfile
make_facet_skymodels_all.control.outputkey                 =   outfile
make_facet_skymodels_all.argument.flags                    =   [fullmodelfile,outfile,{{ vertices_file }}]
make_facet_skymodels_all.argument.cal_only                 =   False

# convert the facet skymodel into a sourcedb, length = nbands
make_sourcedb_all_facet_sources.control.type               =   make_sourcedb
make_sourcedb_all_facet_sources.control.opts.mapfile_in    =   make_facet_skymodels_all.output.mapfile
make_sourcedb_all_facet_sources.control.opts.inputkey      =   in
make_sourcedb_all_facet_sources.argument.format            =   <
make_sourcedb_all_facet_sources.argument.outtype           =   blob

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_all_facet_sources.control.kind             =   plugin
expand_sourcedb_all_facet_sources.control.type             =   mapfileSingleToGroup
expand_sourcedb_all_facet_sources.control.mapfile_in       =   make_sourcedb_all_facet_sources.output.mapfile
expand_sourcedb_all_facet_sources.control.mapfile_groups   =   create_msmulti_map.output.mapfile
expand_sourcedb_all_facet_sources.control.mapfile_dir      =   input.output.mapfile_dir
expand_sourcedb_all_facet_sources.control.filename         =   expand_sourcedb_all_facet_sources.mapfile

# extract the skymodel for the calibrator of this facet from global skymodel, length = nbands
make_facet_skymodels_cal.control.type                      =   make_facet_skymodel
make_facet_skymodels_cal.control.mapfile_in                =   create_full_skymodels_map.output.mapfile
make_facet_skymodels_cal.control.inputkey                  =   fullmodelfile
make_facet_skymodels_cal.control.outputkey                 =   outfile
make_facet_skymodels_cal.argument.flags                    =   [fullmodelfile,outfile,{{ vertices_file }}]
make_facet_skymodels_cal.argument.cal_only                 =   True

# convert the facet skymodel into a sourcedb, length = nbands
make_sourcedb_cal_facet_sources.control.type               =   make_sourcedb
make_sourcedb_cal_facet_sources.control.opts.mapfile_in    =   make_facet_skymodels_cal.output.mapfile
make_sourcedb_cal_facet_sources.control.opts.inputkey      =   in
make_sourcedb_cal_facet_sources.argument.format            =   <
make_sourcedb_cal_facet_sources.argument.outtype           =   blob

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_cal_facet_sources.control.kind             =   plugin
expand_sourcedb_cal_facet_sources.control.type             =   mapfileSingleToGroup
expand_sourcedb_cal_facet_sources.control.mapfile_in       =   make_sourcedb_cal_facet_sources.output.mapfile
expand_sourcedb_cal_facet_sources.control.mapfile_groups   =   create_msmulti_map.output.mapfile
expand_sourcedb_cal_facet_sources.control.mapfile_dir      =   input.output.mapfile_dir
expand_sourcedb_cal_facet_sources.control.filename         =   expand_sourcedb_cal_facet_sources.mapfile

# shift full-res data to facet position to accept result of ft step below, length = nfiles
# Compress both data and weights
shift_empty.control.type                                   =   dppp
shift_empty.control.opts.mapfile_in                        =   create_ms_map.output.mapfile
shift_empty.control.opts.inputkey                          =   msin
shift_empty.argument.numthreads                            =   {{ max_cpus_per_io_proc_nfiles }}
shift_empty.argument.msin.datacolumn                       =   {{ subtracted_data_colname }}
shift_empty.argument.msout.overwrite                       =   True
shift_empty.argument.msout.writefullresflag                =   False
{% if local_dir is not none %}
shift_empty.argument.local_scratch_dir                     =   {{ local_dir }}
{% endif %}
shift_empty.argument.steps                                 =   [shift]
shift_empty.argument.shift.type                            =   phaseshifter
{% if is_patch or skip_facet_imaging %}
shift_empty.argument.shift.phasecenter                     =   [{{ ra }}deg, {{ dec }}deg]
{% else %}
shift_empty.argument.shift.phasecenter                     =   [{{ facet_ra }}deg, {{ facet_dec }}deg]
{% endif %}
{% if use_compression %}
shift_empty.argument.msout.storagemanager                  =   "Dysco"
shift_empty.argument.msout.storagemanager.databitrate      =   16
shift_empty.argument.msout.storagemanager.weightbitrate    =   12
shift_empty.argument.msout.storagemanager.distribution     =   "TruncatedGaussian"
shift_empty.argument.msout.storagemanager.disttruncation   =   1.5
shift_empty.argument.msout.storagemanager.normalization    =   "AF"
{% endif %}

# predict the skymodel data for the full facet, length = nfiles
# No compression since we do not want to add noise to the model data (weights
# are already compressed)
predict_all_model_data.control.type                        =   dppp_inplace
{% if is_patch or skip_facet_imaging %}
predict_all_model_data.control.opts.mapfiles_in            =   [shift_empty.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
{% else %}
predict_all_model_data.control.opts.mapfiles_in            =   [shift_empty.output.mapfile,expand_sourcedb_all_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
{% endif %}
predict_all_model_data.control.opts.inputkeys              =   [msin,sourcedb,parmdb]
predict_all_model_data.argument.numthreads                 =   {{ max_cpus_per_proc_nfiles }}
predict_all_model_data.argument.msout                      =   .
predict_all_model_data.argument.msout.datacolumn           =   MODEL_DATA_ORIG
predict_all_model_data.argument.steps                      =   [pred]
predict_all_model_data.argument.pred.type                  =   predict
predict_all_model_data.argument.pred.sourcedb              =   sourcedb
predict_all_model_data.argument.pred.operation             =   replace
predict_all_model_data.argument.pred.applycal.parmdb       =   parmdb

# add predicted facet data to phase-shifted empty data, length = nfiles
# Compress data only (weights are already compressed)
add_all_facet_sources.control.type                         =   add_subtract_columns
add_all_facet_sources.control.opts.mapfiles_in             =   [shift_empty.output.mapfile,shift_empty.output.mapfile]
add_all_facet_sources.control.opts.inputkeys               =   [file1,file2]
add_all_facet_sources.argument.flags                       =   [file1,file2,DATA,MODEL_DATA_ORIG,CORRECTED_DATA,add,True,{{ use_compression }}]

{% if preapply_phase_cal %}
# expand mapfile of the dir-dependent parmDB to all files, length = nfiles
expand_preapply_parmdb_map.control.kind                    =   plugin
expand_preapply_parmdb_map.control.type                    =   expandMapfile
expand_preapply_parmdb_map.control.mapfile_in              =   {{ preapply_parmdb_mapfile }}
expand_preapply_parmdb_map.control.mapfile_to_match        =   create_ms_map.output.mapfile
expand_preapply_parmdb_map.control.mapfile_dir             =   input.output.mapfile_dir
expand_preapply_parmdb_map.control.filename                =   expand_preapply_parmdbs.mapfile
{% endif %}

{% if not is_patch and not skip_facet_imaging %}
# For normal (non-patch) facets, we need to phase shift the empty data, add the
# calibrator source, and average

# shift full-res data to calibrator position and average in frequency, length = nfiles
# Compress both data and weights
shift_cal.control.type                                     =   dppp
{% if preapply_phase_cal %}
shift_cal.control.opts.mapfiles_in                         =   [create_ms_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,create_parmdb_map.output.mapfile,expand_preapply_parmdb_map.output.mapfile]
shift_cal.control.opts.inputkeys                           =   [msin,sourcedb,dir_indep_parmdb,preapply_parmdb]
{% else %}
shift_cal.control.opts.mapfiles_in                         =   [create_ms_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
shift_cal.control.opts.inputkeys                           =   [msin,sourcedb,dir_indep_parmdb]
{% endif %}
shift_cal.argument.numthreads                              =   {{ max_cpus_per_io_proc_nfiles }}
shift_cal.argument.msin.datacolumn                         =   {{ subtracted_data_colname }}
shift_cal.argument.msout.overwrite                         =   True
shift_cal.argument.msout.writefullresflag                  =   False
{% if local_dir is not none %}
shift_cal.argument.local_scratch_dir                       =   {{ local_dir }}
{% endif %}
{% if preapply_phase_cal %}
shift_cal.argument.steps                                   =   [shift,add,correct_fast1,correct_fast2,correct_slow,avg]
shift_cal.argument.correct_fast1.type                      =   applycal
shift_cal.argument.correct_fast1.parmdb                    =   preapply_parmdb
shift_cal.argument.correct_fast1.correction                =   tec
shift_cal.argument.correct_fast1.invert                    =   True
shift_cal.argument.correct_fast2.type                      =   applycal
shift_cal.argument.correct_fast2.parmdb                    =   preapply_parmdb
shift_cal.argument.correct_fast2.correction                =   commonscalarphase
shift_cal.argument.correct_fast2.invert                    =   True
shift_cal.argument.correct_slow.type                       =   applycal
shift_cal.argument.correct_slow.parmdb                     =   preapply_parmdb
shift_cal.argument.correct_slow.invert                     =   True
{% else %}
shift_cal.argument.steps                                   =   [shift,add,avg]
{% endif %}
shift_cal.argument.shift.type                              =   phaseshifter
shift_cal.argument.shift.phasecenter                       =   [{{ ra }}deg, {{ dec }}deg]
shift_cal.argument.add.type                                =   predict
shift_cal.argument.add.sourcedb                            =   sourcedb
shift_cal.argument.add.operation                           =   add
shift_cal.argument.add.applycal.parmdb                     =   dir_indep_parmdb
shift_cal.argument.avg.type                                =   squash
shift_cal.argument.avg.freqstep                            =   {{ facetselfcal_freqstep }}
shift_cal.argument.avg.timestep                            =   1
{% if use_compression %}
shift_cal.argument.msout.storagemanager                    =   "Dysco"
shift_cal.argument.msout.storagemanager.databitrate        =   16
shift_cal.argument.msout.storagemanager.weightbitrate      =   12
shift_cal.argument.msout.storagemanager.distribution       =   "TruncatedGaussian"
shift_cal.argument.msout.storagemanager.disttruncation     =   1.5
shift_cal.argument.msout.storagemanager.normalization      =   "AF"
{% endif %}

{% if preapply_phase_cal %}
# If we preapplied solutions above, we also need a dir-indep corrected   // length = nfiles
# version of the shift_cal data for the initial selfcal image
# Compress both data and weights
shift_cal_dir_indep.control.type                                 =   dppp
shift_cal_dir_indep.control.opts.mapfiles_in                     =   [create_ms_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
shift_cal_dir_indep.control.opts.inputkeys                       =   [msin,sourcedb,dir_indep_parmdb]
shift_cal_dir_indep.argument.numthreads                          =   {{ max_cpus_per_io_proc_nfiles }}
shift_cal_dir_indep.argument.msin.datacolumn                     =   {{ subtracted_data_colname }}
shift_cal_dir_indep.argument.msout.overwrite                     =   True
shift_cal_dir_indep.argument.msout.writefullresflag              =   False
{% if local_dir is not none %}
shift_cal_dir_indep.argument.local_scratch_dir                   =   {{ local_dir }}
{% endif %}
shift_cal_dir_indep.argument.steps                               =   [shift,add,correct,avg]
shift_cal_dir_indep.argument.shift.type                          =   phaseshifter
shift_cal_dir_indep.argument.shift.phasecenter                   =   [{{ ra }}deg, {{ dec }}deg]
shift_cal_dir_indep.argument.add.type                            =   predict
shift_cal_dir_indep.argument.add.sourcedb                        =   sourcedb
shift_cal_dir_indep.argument.add.operation                       =   add
shift_cal_dir_indep.argument.add.applycal.parmdb                 =   dir_indep_parmdb
shift_cal_dir_indep.argument.correct.type                        =   applycal
shift_cal_dir_indep.argument.correct.parmdb                      =   dir_indep_parmdb
shift_cal_dir_indep.argument.correct.correction                  =   gain
shift_cal_dir_indep.argument.correct.invert                      =   True
shift_cal_dir_indep.argument.avg.type                            =   squash
shift_cal_dir_indep.argument.avg.freqstep                        =   {{ facetselfcal_freqstep }}
shift_cal_dir_indep.argument.avg.timestep                        =   {{ facetselfcal_timestep }}
{% if use_compression %}
shift_cal_dir_indep.argument.msout.storagemanager                =   "Dysco"
shift_cal_dir_indep.argument.msout.storagemanager.databitrate    =   16
shift_cal_dir_indep.argument.msout.storagemanager.weightbitrate  =   12
shift_cal_dir_indep.argument.msout.storagemanager.distribution   =   "TruncatedGaussian"
shift_cal_dir_indep.argument.msout.storagemanager.disttruncation =   1.5
shift_cal_dir_indep.argument.msout.storagemanager.normalization  =   "AF"
{% endif %}
{% endif %}

{% else %}

# For patches, we simply need to average the CORRECTED_DATA column of the        // length = nfiles
# shift_empty datasets (since a patch has the same region for all sources as for
# the calibrator). Even though we don't phase shift here, we reuse the step name
# for simplicity
# Compress both data and weights
shift_cal.control.type                                     =   dppp
{% if preapply_phase_cal %}
shift_cal.control.opts.mapfiles_in                         =   [shift_empty.output.mapfile,expand_preapply_parmdb_map.output.mapfile]
shift_cal.control.opts.inputkeys                           =   [msin,preapply_parmdb]
{% else %}
shift_cal.control.opts.mapfile_in                          =   shift_empty.output.mapfile
shift_cal.control.opts.inputkey                            =   msin
{% endif %}
shift_cal.argument.numthreads                              =   {{ max_cpus_per_io_proc_nfiles }}
shift_cal.argument.msin.datacolumn                         =   CORRECTED_DATA
shift_cal.argument.msout.overwrite                         =   True
shift_cal.argument.msout.writefullresflag                  =   False
{% if local_dir is not none %}
shift_cal.argument.local_scratch_dir                       =   {{ local_dir }}
{% endif %}
{% if preapply_phase_cal %}
shift_cal.argument.steps                                   =   [correct_fast1,correct_fast2,correct_slow,avg]
shift_cal.argument.correct_fast1.type                      =   applycal
shift_cal.argument.correct_fast1.parmdb                    =   preapply_parmdb
shift_cal.argument.correct_fast1.correction                =   tec
shift_cal.argument.correct_fast1.invert                    =   True
shift_cal.argument.correct_fast2.type                      =   applycal
shift_cal.argument.correct_fast2.parmdb                    =   preapply_parmdb
shift_cal.argument.correct_fast2.correction                =   commonscalarphase
shift_cal.argument.correct_fast2.invert                    =   True
shift_cal.argument.correct_slow.type                       =   applycal
shift_cal.argument.correct_slow.parmdb                     =   preapply_parmdb
shift_cal.argument.correct_slow.invert                     =   True
{% else %}
shift_cal.argument.steps                                   =   [avg]
{% endif %}
shift_cal.argument.avg.type                                =   squash
shift_cal.argument.avg.freqstep                            =   {{ facetselfcal_freqstep }}
shift_cal.argument.avg.timestep                            =   1
{% if use_compression %}
shift_cal.argument.msout.storagemanager                    =   "Dysco"
shift_cal.argument.msout.storagemanager.databitrate        =   16
shift_cal.argument.msout.storagemanager.weightbitrate      =   12
shift_cal.argument.msout.storagemanager.distribution       =   "TruncatedGaussian"
shift_cal.argument.msout.storagemanager.disttruncation     =   1.5
shift_cal.argument.msout.storagemanager.normalization      =   "AF"
{% endif %}

{% if preapply_phase_cal %}
# If we preapplied solutions above, we also need a dir-indep corrected     // length = nfiles
# version of the shift_cal data for the initial selfcal image
# Compress both data and weights
shift_cal_dir_indep.control.type                                 =   dppp
shift_cal_dir_indep.control.opts.mapfiles_in                     =   [shift_empty.output.mapfile,create_parmdb_map.output.mapfile]
shift_cal_dir_indep.control.opts.inputkeys                       =   [msin,dir_indep_parmdb]
shift_cal_dir_indep.argument.numthreads                          =   {{ max_cpus_per_io_proc_nfiles }}
shift_cal_dir_indep.argument.msin.datacolumn                     =   CORRECTED_DATA
shift_cal_dir_indep.argument.msout.overwrite                     =   True
shift_cal_dir_indep.argument.msout.writefullresflag              =   False
{% if local_dir is not none %}
shift_cal_dir_indep.argument.local_scratch_dir                   =   {{ local_dir }}
{% endif %}
shift_cal_dir_indep.argument.steps                               =   [correct,avg]
shift_cal_dir_indep.argument.correct.type                        =   applycal
shift_cal_dir_indep.argument.correct.parmdb                      =   dir_indep_parmdb
shift_cal_dir_indep.argument.correct.correction                  =   gain
shift_cal_dir_indep.argument.correct.invert                      =   True
shift_cal_dir_indep.argument.avg.type                            =   squash
shift_cal_dir_indep.argument.avg.freqstep                        =   {{ facetselfcal_freqstep }}
shift_cal_dir_indep.argument.avg.timestep                        =   {{ facetselfcal_timestep }}
{% if use_compression %}
shift_cal_dir_indep.argument.msout.storagemanager                =   "Dysco"
shift_cal_dir_indep.argument.msout.storagemanager.databitrate    =   16
shift_cal_dir_indep.argument.msout.storagemanager.weightbitrate  =   12
shift_cal_dir_indep.argument.msout.storagemanager.distribution   =   "TruncatedGaussian"
shift_cal_dir_indep.argument.msout.storagemanager.disttruncation =   1.5
shift_cal_dir_indep.argument.msout.storagemanager.normalization  =   "AF"
{% endif %}
{% endif %}

# end of patch/skip-facet-imaging block
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile_data.control.kind                =   plugin
create_compressed_mapfile_data.control.type                =   compressMapfile
create_compressed_mapfile_data.control.mapfile_in          =   shift_cal.output.mapfile
create_compressed_mapfile_data.control.mapfile_dir         =   input.output.mapfile_dir
create_compressed_mapfile_data.control.filename            =   concat_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes * num_cal_blocks
# we make dummy data here so that there will always be MS files for wsclean
# predict, even if a cal block is completely flagged (which otherwise would get
# skipped and cause problems with predict)
sort_into_Groups.control.type                              =   sort_times_into_freqGroups
sort_into_Groups.argument.flags                            =   [create_compressed_mapfile_data.output.mapfile]
sort_into_Groups.argument.filename                         =   sorted_groups.mapfile
sort_into_Groups.argument.mapfile_dir                      =   input.output.mapfile_dir
sort_into_Groups.argument.hosts                            =   {{ hosts }}
sort_into_Groups.argument.stepname                         =   sort_into_Groups
sort_into_Groups.argument.enforce_numSB                    =   False
{% if num_cal_blocks > 1 %}
sort_into_Groups.argument.numSB                            =   {{ num_bands_per_cal_block }}
{% endif %}
sort_into_Groups.argument.nband_pad                        =   {{ nband_pad_selfcal }}
sort_into_Groups.argument.make_dummy_files                 =   True
sort_into_Groups.argument.skip_flagged_groups              =   False

# convert the output of sort_into_Groups into usable mapfiles, len = 1 / (ntimes * num_cal_blocks)
sort_into_Groups_maps.control.kind                         =   plugin
sort_into_Groups_maps.control.type                         =   mapfilenamesFromMapfiles
sort_into_Groups_maps.control.mapfile_groupmap             =   sort_into_Groups.output.groupmapfile.mapfile
sort_into_Groups_maps.control.mapfile_filesmap             =   sort_into_Groups.output.mapfile.mapfile

# concat data in frequency, length = ntimes * num_cal_blocks
# Note, this step is done because DPPP cannot handle datasets with multiple spectral
# windows, as occurs when MSs at several frequencies are virtually concatenated
# Compress both data and weights
concat_data.control.type                                   =   dppp_concat
concat_data.control.mapfile_out                            =   sort_into_Groups_maps.output.groupmap
concat_data.control.mapfile_in                             =   sort_into_Groups_maps.output.filesmap
concat_data.control.inputkey                               =   msin
concat_data.argument.numthreads                            =   {{ max_cpus_per_io_proc_ntimes }}
concat_data.argument.msin.datacolumn                       =   DATA
concat_data.argument.msin.missingdata                      =   True
concat_data.argument.msin.orderms                          =   False
concat_data.argument.msout.overwrite                       =   True
concat_data.argument.msout.writefullresflag                =   False
{% if local_dir is not none %}
concat_data.argument.local_scratch_dir                     =   {{ local_dir }}
{% endif %}
concat_data.argument.steps                                 =   []
{% if use_compression %}
concat_data.argument.msout.storagemanager                  =   "Dysco"
concat_data.argument.msout.storagemanager.databitrate      =   16
concat_data.argument.msout.storagemanager.weightbitrate    =   12
concat_data.argument.msout.storagemanager.distribution     =   "TruncatedGaussian"
concat_data.argument.msout.storagemanager.disttruncation   =   1.5
concat_data.argument.msout.storagemanager.normalization    =   "AF"
{% endif %}

{% if pre_average %}
# re-group shift_cal mapfile to have one group per band, length = nbands
regroup_shift_cal.control.kind                             =   plugin
regroup_shift_cal.control.type                             =   reGroupMapfile
regroup_shift_cal.control.mapfile_in                       =   shift_cal.output.mapfile
regroup_shift_cal.control.mapfile_groups                   =   create_msmulti_map.output.mapfile
regroup_shift_cal.control.mapfile_dir                      =   input.output.mapfile_dir
regroup_shift_cal.control.filename                         =   regroup_shift_cal.mapfile

# re-group dir-independent parmdb mapfile to have one group per band, length = nbands
regroup_parmdb.control.kind                                =   plugin
regroup_parmdb.control.type                                =   reGroupMapfile
regroup_parmdb.control.mapfile_in                          =   create_parmdb_map.output.mapfile
regroup_parmdb.control.mapfile_groups                      =   create_msmulti_map.output.mapfile
regroup_parmdb.control.check_basename                      =   False
regroup_parmdb.control.mapfile_dir                         =   input.output.mapfile_dir
regroup_parmdb.control.filename                            =   re_grouped_parmdb.mapfile

# Do the baseline-dependent preaveraging, length = nbands
# This step makes new columns named BLAVG_DATA and BLAVG_WEIGHT_SPECTRUM
pre_average.control.type                                   =   pre_average
pre_average.control.mapfiles_in                            =   [regroup_shift_cal.output.mapfile,regroup_parmdb.output.mapfile]
pre_average.control.inputkeys                              =   [datafiles,parmdbs]
pre_average.argument.flags                                 =   [datafiles,parmdbs,DATA,DATA,WEIGHT_SPECTRUM,{{ target_rms_rad }}]

# make mapfile for concatenated preaveraged data, length = ntimes * num_cal_blocks
make_blavg_data_mapfile.control.kind                       =   plugin
make_blavg_data_mapfile.control.type                       =   createMapfile
make_blavg_data_mapfile.control.method                     =   add_suffix_to_file
make_blavg_data_mapfile.control.mapfile_in                 =   sort_into_Groups_maps.output.groupmap
make_blavg_data_mapfile.control.add_suffix_to_file         =   "_blavg.ms"
make_blavg_data_mapfile.control.mapfile_dir                =   input.output.mapfile_dir
make_blavg_data_mapfile.control.filename                   =   make_blavg_data.mapfile

# Concat the preaveraged data (and weights), length = ntimes * num_cal_blocks
# Compress both data and weights
concat_blavg_data.control.type                                 =   dppp_concat
concat_blavg_data.control.mapfile_out                          =   make_blavg_data_mapfile.output.mapfile
concat_blavg_data.control.mapfile_in                           =   sort_into_Groups_maps.output.filesmap
concat_blavg_data.control.inputkey                             =   msin
concat_blavg_data.argument.numthreads                          =   {{ max_cpus_per_io_proc_ntimes }}
concat_blavg_data.argument.msin.datacolumn                     =   DATA
concat_blavg_data.argument.msin.missingdata                    =   True
concat_blavg_data.argument.msin.orderms                        =   False
concat_blavg_data.argument.msout.overwrite                     =   True
concat_blavg_data.argument.msout.writefullresflag              =   False
{% if local_dir is not none %}
concat_blavg_data.argument.local_scratch_dir                   =   {{ local_dir }}
{% endif %}
concat_blavg_data.argument.steps                               =   []
{% if use_compression %}
concat_blavg_data.argument.msout.storagemanager                =   "Dysco"
concat_blavg_data.argument.msout.storagemanager.databitrate    =   16
concat_blavg_data.argument.msout.storagemanager.weightbitrate  =   12
concat_blavg_data.argument.msout.storagemanager.distribution   =   "TruncatedGaussian"
concat_blavg_data.argument.msout.storagemanager.disttruncation =   1.5
concat_blavg_data.argument.msout.storagemanager.normalization  =   "AF"
{% endif %}

# Copy BLAVG_DATA, length = ntimes * num_cal_blocks
# Compress data only (weights are already compressed)
copy_column1.control.type                                  =   copy_column
copy_column1.control.mapfiles_in                           =   [concat_blavg_data.output.mapfile,concat_data.output.mapfile]
copy_column1.control.inputkeys                             =   [blavgfile,datafile]
copy_column1.argument.flags                                =   [blavgfile,datafile,DATA,BLAVG_DATA,True,{{ use_compression }}]

# Copy BLAVG_WEIGHT_SPECTRUM, length = ntimes * num_cal_blocks
# Compress data only (weights are already compressed)
copy_column2.control.type                                  =   copy_column
copy_column2.control.mapfiles_in                           =   [concat_blavg_data.output.mapfile,concat_data.output.mapfile]
copy_column2.control.inputkeys                             =   [blavgfile,datafile]
copy_column2.argument.flags                                =   [blavgfile,datafile,WEIGHT_SPECTRUM,BLAVG_WEIGHT_SPECTRUM,True,False]
{% endif %}

{% if selfcal_local_dir is not none %}
# make a mapfile for syncing of concat_data to selfcal_local_dir, len = ntimes * num_cal_blocks
make_concat_data_sync_mapfile.control.kind                 =   plugin
make_concat_data_sync_mapfile.control.type                 =   changeDirectory
make_concat_data_sync_mapfile.control.mapfile_in           =   concat_data.output.mapfile
make_concat_data_sync_mapfile.control.new_dir              =   {{ selfcal_local_dir }}
make_concat_data_sync_mapfile.control.make_tempdir         =   True
make_concat_data_sync_mapfile.control.mapfile_dir          =   input.output.mapfile_dir
make_concat_data_sync_mapfile.control.filename             =   concat_data_local.mapfile
make_concat_data_sync_mapfile.control.nitems_per_host      =   {{ num_cal_blocks }}

# adjust the concat_data hosts to match the ones for syncing, len = ntimes * num_cal_blocks
# this is needed so that the mapfiles used in sync_files step will validate
adjust_concat_data_hosts.control.kind                      =   plugin
adjust_concat_data_hosts.control.type                      =   matchHosts
adjust_concat_data_hosts.control.mapfile_in                =   concat_data.output.mapfile
adjust_concat_data_hosts.control.mapfile_to_match          =   make_concat_data_sync_mapfile.output.mapfile
adjust_concat_data_hosts.control.mapfile_dir               =   input.output.mapfile_dir
adjust_concat_data_hosts.control.filename                  =   concat_data_adjusted_hosts.mapfile

# copy the output of concat_data to selfcal_local_dir, len = ntimes * num_cal_blocks
sync_concat_data_to_local.control.type                     =   sync_files
sync_concat_data_to_local.control.mapfile_in               =   adjust_concat_data_hosts.output.mapfile
sync_concat_data_to_local.control.mapfile_out              =   make_concat_data_sync_mapfile.output.mapfile
sync_concat_data_to_local.control.inputkey                 =   msin
sync_concat_data_to_local.control.outputkey                =   msout
sync_concat_data_to_local.argument.flags                   =   [msin,msout]
{% endif %}

# make compressed mapfile for (non-local) concatenated data MSs, length = 1
concat_data_compressed_mapfile.control.kind                =   plugin
concat_data_compressed_mapfile.control.type                =   compressMapfile
concat_data_compressed_mapfile.control.mapfile_in          =   concat_data.output.mapfile
concat_data_compressed_mapfile.control.mapfile_dir         =   input.output.mapfile_dir
concat_data_compressed_mapfile.control.filename            =   concat_chunks_input.mapfile

########## start of first round of selfcal

# apply dir-independent calibration and average, length = nfiles
# this step must be done band-by-band, as each band has its own parmdb.
# if we preapply solutions, we don't need to do this step as we already have
# averaged MSs from the shift_cal_dir_indep step
# Compress both data and weights
{% if not preapply_phase_cal %}
average0.control.type                                      =   dppp
average0.control.opts.mapfiles_in                          =   [shift_cal.output.mapfile,create_parmdb_map.output.mapfile]
average0.control.opts.inputkeys                            =   [msin,parmdb]
average0.argument.numthreads                               =   {{ max_cpus_per_io_proc_nfiles }}
average0.argument.msin.datacolumn                          =   DATA
average0.argument.msout.overwrite                          =   True
average0.argument.msout.writefullresflag                   =   False
{% if local_dir is not none %}
average0.argument.local_scratch_dir                        =   {{ local_dir }}
{% endif %}
average0.argument.steps                                    =   [correct,avg]
average0.argument.correct.type                             =   applycal
average0.argument.correct.parmdb                           =   parmdb
average0.argument.correct.correction                       =   gain
average0.argument.correct.invert                           =   True
average0.argument.avg.type                                 =   squash
average0.argument.avg.freqstep                             =   1
average0.argument.avg.timestep                             =   {{ facetselfcal_timestep }}
{% if use_compression %}
average0.argument.msout.storagemanager                     =   "Dysco"
average0.argument.msout.storagemanager.databitrate         =   16
average0.argument.msout.storagemanager.weightbitrate       =   12
average0.argument.msout.storagemanager.distribution        =   "TruncatedGaussian"
average0.argument.msout.storagemanager.disttruncation      =   1.5
average0.argument.msout.storagemanager.normalization       =   "AF"
{% endif %}
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile0.control.kind                    =   plugin
create_compressed_mapfile0.control.type                    =   compressMapfile
{% if preapply_phase_cal %}
create_compressed_mapfile0.control.mapfile_in              =   shift_cal_dir_indep.output.mapfile
{% else %}
create_compressed_mapfile0.control.mapfile_in              =   average0.output.mapfile
{% endif %}
create_compressed_mapfile0.control.mapfile_dir             =   input.output.mapfile_dir
create_compressed_mapfile0.control.filename                =   concat_average0_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes
sort_average0_into_Groups.control.type                     =   sort_times_into_freqGroups
sort_average0_into_Groups.argument.flags                   =   [create_compressed_mapfile0.output.mapfile]
sort_average0_into_Groups.argument.filename                =   sorted_average0_groups.mapfile
sort_average0_into_Groups.argument.mapfile_dir             =   input.output.mapfile_dir
sort_average0_into_Groups.argument.hosts                   =   {{ hosts }}
sort_average0_into_Groups.argument.stepname                =   sort_average0_into_Groups
sort_average0_into_Groups.argument.enforce_numSB           =   False
sort_average0_into_Groups.argument.nband_pad               =   {{ nband_pad_selfcal }}

# convert the output of sort_average0_into_Groups into usable mapfiles, len = 1 / ntimes
sort_average0_into_Groups_maps.control.kind                =   plugin
sort_average0_into_Groups_maps.control.type                =   mapfilenamesFromMapfiles
sort_average0_into_Groups_maps.control.mapfile_groupmap    =   sort_average0_into_Groups.output.groupmapfile.mapfile
sort_average0_into_Groups_maps.control.mapfile_filesmap    =   sort_average0_into_Groups.output.mapfile.mapfile

# concat averaged data in frequency, length = ntimes
# Note, this step is done to ensure that we get WSClean channel images that match
# the datasets used for selfcal so that predict will work properly
# Compress both data and weights
concat_average0_data.control.type                                 =   dppp_concat
concat_average0_data.control.mapfile_out                          =   sort_average0_into_Groups_maps.output.groupmap
concat_average0_data.control.mapfile_in                           =   sort_average0_into_Groups_maps.output.filesmap
concat_average0_data.control.inputkey                             =   msin
concat_average0_data.argument.numthreads                          =   {{ max_cpus_per_io_proc_ntimes }}
concat_average0_data.argument.msin.datacolumn                     =   DATA
concat_average0_data.argument.msin.missingdata                    =   True
concat_average0_data.argument.msin.orderms                        =   False
concat_average0_data.argument.msout.overwrite                     =   True
concat_average0_data.argument.msout.writefullresflag              =   False
{% if local_dir is not none %}
concat_average0_data.argument.local_scratch_dir                   =   {{ local_dir }}
{% endif %}
concat_average0_data.argument.steps                               =   []
{% if use_compression %}
concat_average0_data.argument.msout.storagemanager                =   "Dysco"
concat_average0_data.argument.msout.storagemanager.databitrate    =   16
concat_average0_data.argument.msout.storagemanager.weightbitrate  =   12
concat_average0_data.argument.msout.storagemanager.distribution   =   "TruncatedGaussian"
concat_average0_data.argument.msout.storagemanager.disttruncation =   1.5
concat_average0_data.argument.msout.storagemanager.normalization  =   "AF"
{% endif %}

# make compressed mapfile for concatenated averaged data MSs, length = 1
create_compressed_mapfile01.control.kind                   =   plugin
create_compressed_mapfile01.control.type                   =   compressMapfile
create_compressed_mapfile01.control.mapfile_in             =   concat_average0_data.output.mapfile
create_compressed_mapfile01.control.mapfile_dir            =   input.output.mapfile_dir
create_compressed_mapfile01.control.filename               =   image0_input.mapfile

# make a mask using user-supplied region (if any), length = 1
premask_selfcal.control.type                               =   make_clean_mask
premask_selfcal.control.mapfile_in                         =   create_compressed_mapfile01.output.mapfile
premask_selfcal.control.inputkey                           =   imagefile
premask_selfcal.control.outputkey                          =   maskfile
premask_selfcal.argument.flags                             =   [imagefile,maskfile]
premask_selfcal.argument.img_format                        =   fits
premask_selfcal.argument.pad_to_size                       =   {{ cal_imsize }}
premask_selfcal.argument.skip_source_detection             =   True
premask_selfcal.argument.vertices_file                     =   {{ vertices_file }}
premask_selfcal.argument.reference_ra_deg                  =   {{ ra }}
premask_selfcal.argument.reference_dec_deg                 =   {{ dec }}
premask_selfcal.argument.cellsize_deg                      =   {{ cellsize_selfcal_deg }}
premask_selfcal.argument.region_file                       =   {{ region_selfcal }}
premask_selfcal.argument.make_blank_image                  =   True
premask_selfcal.argument.trim_by                           =   0.4

# image the virtual concatenated data with wsclean, length = 1
wsclean_image01.control.type                               =   wsclean
wsclean_image01.control.mapfiles_in                        =   [create_compressed_mapfile01.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image01.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image01.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image01.argument.fitsmask                          =   fitsmask
wsclean_image01.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image01.argument.niter                             =   1000
wsclean_image01.argument.threshold                         =   0.0
wsclean_image01.argument.pol                               =   I
wsclean_image01.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image01.argument.mgain                             =   0.6
wsclean_image01.argument.cleanborder                       =   0
wsclean_image01.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image01.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image01.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image01.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image01.argument.j                                 =   {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image01.argument.tempdir                           =   {{ local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image01.argument.multiscale-scales                 =   0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image01.argument.deconvolution-channels            =   3
wsclean_image01.argument.fit-spectral-pol                  =   3
{% endif %}
wsclean_image01.argument.weighting-rank-filter             =   3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image01.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map01.control.kind                         =   plugin
create_imagebase_map01.control.type                         =   trimMapfile
create_imagebase_map01.control.mapfile_in                   =   wsclean_image01.output.wsclean_image01-image.fits.mapfile
create_imagebase_map01.control.trim                         =   -
create_imagebase_map01.control.mapfile_dir                  =   input.output.mapfile_dir
create_imagebase_map01.control.filename                     =   wsclean_image01_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile0.control.kind                       =   plugin
adjust_wsclean_mapfile0.control.type                       =   appendMapfile
adjust_wsclean_mapfile0.control.mapfile_in                 =   create_imagebase_map01.output.mapfile
adjust_wsclean_mapfile0.control.append                     =   {{ wsclean_suffix }}
adjust_wsclean_mapfile0.control.mapfile_dir                =   input.output.mapfile_dir
adjust_wsclean_mapfile0.control.filename                   =   wsclean_image01_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask0.control.type                                         =   make_clean_mask
mask0.control.mapfile_in                                   =   adjust_wsclean_mapfile0.output.mapfile
mask0.control.inputkey                                     =   imagefile
mask0.control.outputkey                                    =   maskfile
mask0.argument.flags                                       =   [imagefile,maskfile]
mask0.argument.region_file                                 =   {{ region_selfcal }}
mask0.argument.threshpix                                   =   10
mask0.argument.threshisl                                   =   6
mask0.argument.iterate_threshold                           =   True
mask0.argument.atrous_do                                   =   {{ atrous_do }}
mask0.argument.rmsbox                                      =   (80,20)
mask0.argument.adaptive_rmsbox                             =   True
mask0.argument.trim_by                                     =   0.4
mask0.argument.img_format                                  =   fits
mask0.argument.threshold_format                            =   float
mask0.argument.use_adaptive_threshold                      =   {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image02.control.type                               =   wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image02.control.mapfiles_in                        =   [create_compressed_mapfile01.output.mapfile,mask0.output.mapfile,mask0.output.threshold_5sig.mapfile]
wsclean_image02.control.inputkeys                          =   [msfile,fitsmask,threshold]
wsclean_image02.argument.threshold                         =   threshold
wsclean_image02.argument.niter                             =   10000
{% else %}
wsclean_image02.control.mapfiles_in                        =   [create_compressed_mapfile01.output.mapfile,mask0.output.mapfile]
wsclean_image02.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image02.argument.threshold                         =   0.0
wsclean_image02.argument.niter                             =   1000
{% endif %}
wsclean_image02.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image02.argument.fitsmask                          =   fitsmask
wsclean_image02.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image02.argument.pol                               =   I
wsclean_image02.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image02.argument.mgain                             =   0.6
wsclean_image02.argument.cleanborder                       =   0
wsclean_image02.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image02.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image02.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image02.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image02.argument.j                                 =   {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image02.argument.tempdir                           =   {{ local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image02.argument.multiscale-scales                 =   0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image02.argument.deconvolution-channels            =   3
wsclean_image02.argument.fit-spectral-pol                  =   3
{% endif %}
wsclean_image02.argument.weighting-rank-filter             =   3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image02.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map02.control.kind                        =   plugin
create_imagebase_map02.control.type                        =   trimMapfile
create_imagebase_map02.control.mapfile_in                  =   wsclean_image02.output.wsclean_image02-image.fits.mapfile
create_imagebase_map02.control.trim                        =   -
create_imagebase_map02.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map02.control.filename                    =   image02_rootname.mapfile

# pad the model image with zeros, length = 1
pad_selfcal_model0_images.control.type                     =   pad_image
pad_selfcal_model0_images.control.mapfile_in               =   create_imagebase_map02.output.mapfile
pad_selfcal_model0_images.control.inputkey                 =   imagefile
pad_selfcal_model0_images.argument.flags                   =   [imagefile,{{ wsclean_patch_model_padding }}]

# make compressed mapfile of concatenated data, length = ntimes
# needed for the wsclean_ft steps to get full frequency coverage per group
regroup_concat_data_map.control.kind                       =   plugin
regroup_concat_data_map.control.type                       =   compressMapfile
regroup_concat_data_map.control.mapfile_in                 =   {{ concat_data_mapfile }}
regroup_concat_data_map.control.nitems_to_compress         =   {{ num_cal_blocks }}
regroup_concat_data_map.control.mapfile_dir                =   input.output.mapfile_dir
regroup_concat_data_map.control.filename                   =   regroup_concat_data.mapfile

# expand the mapfile of the model image to match ft files, length = ntimes
create_expanded_model0_mapfile.control.kind                =   plugin
create_expanded_model0_mapfile.control.type                =   expandMapfile
create_expanded_model0_mapfile.control.mapfile_in          =   create_imagebase_map02.output.mapfile
create_expanded_model0_mapfile.control.mapfile_to_match    =   regroup_concat_data_map.output.mapfile
create_expanded_model0_mapfile.control.mapfile_dir         =   input.output.mapfile_dir
create_expanded_model0_mapfile.control.filename            =   expand_model0.mapfile

# expand mapfile of the model image sizes to all groups, length = ntimes
expand_selfcal_model_size_map.control.kind                 =   plugin
expand_selfcal_model_size_map.control.type                 =   expandMapfile
expand_selfcal_model_size_map.control.mapfile_in           =   pad_selfcal_model0_images.output.padsize.mapfile
expand_selfcal_model_size_map.control.mapfile_to_match     =   regroup_concat_data_map.output.mapfile
expand_selfcal_model_size_map.control.mapfile_dir          =   input.output.mapfile_dir
expand_selfcal_model_size_map.control.filename             =   expand_selfcal_model_size.mapfile

# predict model visibilities, length = ntimes
wsclean_ft0.control.type                                   =   wsclean_ft
wsclean_ft0.control.mapfiles_in                            =   [regroup_concat_data_map.output.mapfile,create_expanded_model0_mapfile.output.mapfile,expand_selfcal_model_size_map.output.mapfile]
wsclean_ft0.control.inputkeys                              =   [msfile,name,size]
wsclean_ft0.argument.flags                                 =   [-predict,msfile]
wsclean_ft0.argument.scale                                 =   {{ cellsize_selfcal_deg }}
wsclean_ft0.argument.mem                                   =   {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft0.argument.channelsout                           =   {{ wsclean_nchannels_selfcal }}
wsclean_ft0.argument.j                                     =   {{ max_cpus_per_io_proc_ntimes }}
{% if local_dir is not none %}
wsclean_ft0.argument.tempdir                               =   {{ local_dir }}
{% endif %}

# switch "normal" data and weights with BL-averaged ones, length = ntimes * num_cal_blocks
switch_data_weights_col1.control.type                      =   switch_columns
switch_data_weights_col1.control.mapfile_in                =   {{ concat_data_mapfile }}
switch_data_weights_col1.control.inputkey                  =   msfile
switch_data_weights_col1.argument.flags                    =   [msfile]

# generate mapfile for the fast-phase parmDBs generated in the solve_phaseonly steps, length = ntimes * num_cal_blocks
make_fast_phase_parmdb_map.control.kind                    =  plugin
make_fast_phase_parmdb_map.control.type                    =  createMapfile
make_fast_phase_parmdb_map.control.method                  =  add_suffix_to_file
make_fast_phase_parmdb_map.control.mapfile_in              =  concat_data.output.mapfile
make_fast_phase_parmdb_map.control.add_suffix_to_file      =  /instrument
make_fast_phase_parmdb_map.control.mapfile_dir             =  input.output.mapfile_dir
make_fast_phase_parmdb_map.control.filename                =  fast_parmdb.mapfile

{% if peel_skymodel is not none %}
# create a mapfile with the outlier skymodel from supplied list, length = 1
create_peel_skymodel_map.control.kind                      =   plugin
create_peel_skymodel_map.control.type                      =   addListMapfile
create_peel_skymodel_map.control.hosts                     =   {{ hosts }}
create_peel_skymodel_map.control.files                     =   [{{ peel_skymodel }}]
create_peel_skymodel_map.control.mapfile_dir               =   input.output.mapfile_dir
create_peel_skymodel_map.control.filename                  =   peel_skymodel.mapfile

# convert the outlier skymodel into a sourcedb, length = 1
make_peel_sourcedb.control.type                            =   make_sourcedb
make_peel_sourcedb.control.opts.mapfile_in                 =   create_peel_skymodel_map.output.mapfile
make_peel_sourcedb.control.opts.inputkey                   =   in
make_peel_sourcedb.argument.format                         =   <
make_peel_sourcedb.argument.outtype                        =   blob

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_peel_sourcedb_map.control.kind                      =   plugin
expand_peel_sourcedb_map.control.type                      =   expandMapfile
expand_peel_sourcedb_map.control.mapfile_in                =   make_peel_sourcedb.output.mapfile
expand_peel_sourcedb_map.control.mapfile_to_match          =   concat_data.output.mapfile
expand_peel_sourcedb_map.control.mapfile_dir               =   input.output.mapfile_dir
expand_peel_sourcedb_map.control.filename                  =   expand_peel_sourcedb.mapfile
{% endif %}

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs1.control.type                               =   remove_file
remove_parmdbs1.control.mapfile_in                         =   make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs1.control.inputkey                           =   parmdb
remove_parmdbs1.argument.flags                             =   [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_phaseonly1.control.type                              =   dppp_inplace
{% if peel_skymodel is not none %}
solve_phaseonly1.control.mapfiles_in                       =   [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile,expand_peel_sourcedb_map.output.mapfile]
solve_phaseonly1.control.inputkeys                         =   [msin,parmdb,sourcedb]
{% else %}
solve_phaseonly1.control.mapfiles_in                       =   [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
solve_phaseonly1.control.inputkeys                         =   [msin,parmdb]
{% endif %}
solve_phaseonly1.argument.numthreads                       =   {{ max_cpus_per_proc_ntimes }}
solve_phaseonly1.argument.msin.datacolumn                  =   DATA
solve_phaseonly1.argument.msout                            =   .
solve_phaseonly1.argument.steps                            =   [uvcut,solvetec]
solve_phaseonly1.argument.uvcut.type                       =   uvwflagger
solve_phaseonly1.argument.uvcut.uvlambdamin                =   {{ solve_min_uv_lambda }}
solve_phaseonly1.argument.solvetec.type                    =   gaincal
{% if preapply_solve_tec_only %}
solve_phaseonly1.argument.solvetec.caltype                 =   tec
{% else %}
solve_phaseonly1.argument.solvetec.caltype                 =   tecandphase
{% endif %}
solve_phaseonly1.argument.solvetec.parmdb                  =   parmdb
{% if peel_skymodel is not none %}
solve_phaseonly1.argument.solvetec.usemodelcolumn          =   False
solve_phaseonly1.argument.solvetec.sourcedb                =   sourcedb
{% else %}
solve_phaseonly1.argument.solvetec.usemodelcolumn          =   True
{% endif %}
solve_phaseonly1.argument.solvetec.solint                  =   {{ solint_time_p }}
solve_phaseonly1.argument.solvetec.nchan                   =   {{ solint_freq_a }}

# switch "normal" data and weights with BL-averaged ones, length = ntimes * num_cal_blocks
switch_data_weights_col2.control.type                      =   switch_columns
switch_data_weights_col2.control.mapfile_in                =   {{ concat_data_mapfile }}
switch_data_weights_col2.control.inputkey                  =   msfile
switch_data_weights_col2.argument.flags                    =   [msfile]

########## end of first round of selfcal
########## start of second round of selfcal

{% if selfcal_local_dir is not none %}
# make mapfile for the output of apply steps, len = ntimes * num_cal_blocks
# this step is needed to direct the output to the non-local (shared) disk
make_apply_mapfile.control.kind                            =   plugin
make_apply_mapfile.control.type                            =   changeDirectory
make_apply_mapfile.control.mapfile_in                      =   make_concat_data_sync_mapfile.output.mapfile
make_apply_mapfile.control.new_dir                         =   {{ pipeline_parset_dir }}
make_apply_mapfile.control.make_tempdir                    =   False
make_apply_mapfile.control.append                          =   _apply_output
make_apply_mapfile.control.mapfile_dir                     =   input.output.mapfile_dir
make_apply_mapfile.control.filename                        =   apply_output.mapfile
{% endif %}

# apply the previous calibration and average, length = ntimes * num_cal_blocks
apply_phaseonly1.control.type                                 =   dppp
apply_phaseonly1.control.opts.mapfiles_in                     =   [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_phaseonly1.control.opts.inputkeys                       =   [msin,parmdb]
{% if selfcal_local_dir is not none %}
apply_phaseonly1.control.opts.mapfile_out                     =   make_apply_mapfile.output.mapfile
apply_phaseonly1.control.opts.outputkey                       =   msout
apply_phaseonly1.argument.local_scratch_dir                   =   {{ selfcal_local_dir }}
{% endif %}
apply_phaseonly1.argument.numthreads                          =   {{ max_cpus_per_io_proc_ntimes }}
apply_phaseonly1.argument.msin.datacolumn                     =   DATA
apply_phaseonly1.argument.msout.overwrite                     =   True
apply_phaseonly1.argument.msout.writefullresflag              =   False
{% if preapply_solve_tec_only %}
apply_phaseonly1.argument.steps                               =   [correct_fast1,avg]
{% else %}
apply_phaseonly1.argument.steps                               =   [correct_fast1,correct_fast2,avg]
{% endif %}
apply_phaseonly1.argument.correct_fast1.type                  =   applycal
apply_phaseonly1.argument.correct_fast1.parmdb                =   parmdb
apply_phaseonly1.argument.correct_fast1.correction            =   tec
apply_phaseonly1.argument.correct_fast1.invert                =   True
{% if not preapply_solve_tec_only %}
apply_phaseonly1.argument.correct_fast2.type                  =   applycal
apply_phaseonly1.argument.correct_fast2.parmdb                =   parmdb
apply_phaseonly1.argument.correct_fast2.correction            =   commonscalarphase
apply_phaseonly1.argument.correct_fast2.invert                =   True
{% endif %}
apply_phaseonly1.argument.avg.type                            =   squash
apply_phaseonly1.argument.avg.freqstep                        =   1
apply_phaseonly1.argument.avg.timestep                        =   {{ facetselfcal_timestep }}
{% if use_compression %}
apply_phaseonly1.argument.msout.storagemanager                =   "Dysco"
apply_phaseonly1.argument.msout.storagemanager.databitrate    =   16
apply_phaseonly1.argument.msout.storagemanager.weightbitrate  =   12
apply_phaseonly1.argument.msout.storagemanager.distribution   =   "TruncatedGaussian"
apply_phaseonly1.argument.msout.storagemanager.disttruncation =   1.5
apply_phaseonly1.argument.msout.storagemanager.normalization  =   "AF"
{% endif %}

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile1.control.kind                    =   plugin
create_compressed_mapfile1.control.type                    =   compressMapfile
create_compressed_mapfile1.control.mapfile_in              =   apply_phaseonly1.output.mapfile
create_compressed_mapfile1.control.mapfile_dir             =   input.output.mapfile_dir
create_compressed_mapfile1.control.filename                =   image1_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image11.control.type                               =   wsclean
wsclean_image11.control.mapfiles_in                        =   [create_compressed_mapfile1.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image11.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image11.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image11.argument.fitsmask                          =   fitsmask
wsclean_image11.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image11.argument.niter                             =   1000
wsclean_image11.argument.threshold                         =   0.0
wsclean_image11.argument.pol                               =   I
wsclean_image11.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image11.argument.mgain                             =   0.6
wsclean_image11.argument.cleanborder                       =   0
wsclean_image11.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image11.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image11.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image11.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image11.argument.j                                 =   {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image11.argument.tempdir                           =   {{ local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image11.argument.multiscale-scales                 =   0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image11.argument.deconvolution-channels            =   3
wsclean_image11.argument.fit-spectral-pol                  =   3
{% endif %}
wsclean_image11.argument.weighting-rank-filter             =   3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image11.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map11.control.kind                        =   plugin
create_imagebase_map11.control.type                        =   trimMapfile
create_imagebase_map11.control.mapfile_in                  =   wsclean_image11.output.wsclean_image11-image.fits.mapfile
create_imagebase_map11.control.trim                        =   -
create_imagebase_map11.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map11.control.filename                    =   wsclean_image11_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile11.control.kind                      =   plugin
adjust_wsclean_mapfile11.control.type                      =   appendMapfile
adjust_wsclean_mapfile11.control.mapfile_in                =   create_imagebase_map11.output.mapfile
adjust_wsclean_mapfile11.control.append                    =   {{ wsclean_suffix }}
adjust_wsclean_mapfile11.control.mapfile_dir               =   input.output.mapfile_dir
adjust_wsclean_mapfile11.control.filename                  =   wsclean_image11_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask1.control.type                                         =   make_clean_mask
mask1.control.mapfile_in                                   =   adjust_wsclean_mapfile11.output.mapfile
mask1.control.inputkey                                     =   imagefile
mask1.control.outputkey                                    =   maskfile
mask1.argument.flags                                       =   [imagefile,maskfile]
mask1.argument.region_file                                 =   {{ region_selfcal }}
mask1.argument.threshpix                                   =   8
mask1.argument.threshisl                                   =   7
mask1.argument.iterate_threshold                           =   True
mask1.argument.atrous_do                                   =   {{ atrous_do }}
mask1.argument.rmsbox                                      =   (80,20)
mask1.argument.adaptive_rmsbox                             =   True
mask1.argument.trim_by                                     =   0.4
mask1.argument.img_format                                  =   fits
mask1.argument.threshold_format                            =   float
mask1.argument.use_adaptive_threshold                      =   {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image12.control.type                               =   wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image12.control.mapfiles_in                        =   [create_compressed_mapfile1.output.mapfile,mask1.output.mapfile,mask1.output.threshold_5sig.mapfile]
wsclean_image12.control.inputkeys                          =   [msfile,fitsmask,threshold]
wsclean_image12.argument.threshold                         =   threshold
wsclean_image12.argument.niter                             =   10000
{% else %}
wsclean_image12.control.mapfiles_in                        =   [create_compressed_mapfile1.output.mapfile,mask1.output.mapfile]
wsclean_image12.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image12.argument.threshold                         =   0.0
wsclean_image12.argument.niter                             =   1000
{% endif %}
wsclean_image12.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image12.argument.fitsmask                          =   fitsmask
wsclean_image12.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image12.argument.pol                               =   I
wsclean_image12.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image12.argument.mgain                             =   0.6
wsclean_image12.argument.cleanborder                       =   0
wsclean_image12.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image12.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image12.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image12.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image12.argument.j                                 =   {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image12.argument.tempdir                           =   {{ local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image12.argument.multiscale-scales                 =   0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image12.argument.deconvolution-channels            =   3
wsclean_image12.argument.fit-spectral-pol                  =   3
{% endif %}
wsclean_image12.argument.weighting-rank-filter             =   3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image12.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map12.control.kind                        =   plugin
create_imagebase_map12.control.type                        =   trimMapfile
create_imagebase_map12.control.mapfile_in                  =   wsclean_image12.output.wsclean_image12-image.fits.mapfile
create_imagebase_map12.control.trim                        =   -
create_imagebase_map12.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map12.control.filename                    =   wsclean_image12_image_rootname.mapfile

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model1_mapfile.control.kind                =   plugin
create_expanded_model1_mapfile.control.type                =   expandMapfile
create_expanded_model1_mapfile.control.mapfile_in          =   create_imagebase_map12.output.mapfile
create_expanded_model1_mapfile.control.mapfile_to_match    =   regroup_concat_data_map.output.mapfile
create_expanded_model1_mapfile.control.mapfile_dir         =   input.output.mapfile_dir
create_expanded_model1_mapfile.control.filename            =   expand_wsclean_model1.mapfile

## pad the model image with zeros, length = 1
pad_selfcal_model1_images.control.type                     =   pad_image
pad_selfcal_model1_images.control.mapfile_in               =   create_imagebase_map12.output.mapfile
pad_selfcal_model1_images.control.inputkey                 =   imagefile
pad_selfcal_model1_images.argument.flags                   =   [imagefile,{{ wsclean_patch_model_padding }}]

# predict model visibilities, length = ntimes
wsclean_ft1.control.type                                   =   wsclean_ft
wsclean_ft1.control.mapfiles_in                            =   [regroup_concat_data_map.output.mapfile,create_expanded_model1_mapfile.output.mapfile,expand_selfcal_model_size_map.output.mapfile]
wsclean_ft1.control.inputkeys                              =   [msfile,name,size]
wsclean_ft1.argument.flags                                 =   [-predict,msfile]
wsclean_ft1.argument.scale                                 =   {{ cellsize_selfcal_deg }}
wsclean_ft1.argument.mem                                   =   {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft1.argument.channelsout                           =   {{ wsclean_nchannels_selfcal }}
wsclean_ft1.argument.j                                     =   {{ max_cpus_per_io_proc_ntimes }}
{% if local_dir is not none %}
wsclean_ft1.argument.tempdir                               =   {{ local_dir }}
{% endif %}

# switch "normal" data and weights with BL-averaged ones, length = ntimes * num_cal_blocks
switch_data_weights_col3.control.type                      =   switch_columns
switch_data_weights_col3.control.mapfile_in                =   {{ concat_data_mapfile }}
switch_data_weights_col3.control.inputkey                  =   msfile
switch_data_weights_col3.argument.flags                    =   [msfile]

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs2.control.type                               =   remove_file
remove_parmdbs2.control.mapfile_in                         =   make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs2.control.inputkey                           =   parmdb
remove_parmdbs2.argument.flags                             =   [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_phaseonly2.control.type                              =   dppp_inplace
solve_phaseonly2.control.mapfiles_in                       =   [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
solve_phaseonly2.control.inputkeys                         =   [msin,parmdb]
solve_phaseonly2.argument.numthreads                       =   {{ max_cpus_per_proc_ntimes }}
solve_phaseonly2.argument.msin.datacolumn                  =   DATA
solve_phaseonly2.argument.msout                            =   .
solve_phaseonly2.argument.steps                            =   [uvcut,solvetec]
solve_phaseonly2.argument.uvcut.type                       =   uvwflagger
solve_phaseonly2.argument.uvcut.uvlambdamin                =   {{ solve_min_uv_lambda }}
solve_phaseonly2.argument.solvetec.type                    =   gaincal
{% if preapply_solve_tec_only %}
solve_phaseonly2.argument.solvetec.caltype                 =   tec
{% else %}
solve_phaseonly2.argument.solvetec.caltype                 =   tecandphase
{% endif %}
solve_phaseonly2.argument.solvetec.parmdb                  =   parmdb
solve_phaseonly2.argument.solvetec.usemodelcolumn          =   True
solve_phaseonly2.argument.solvetec.solint                  =   {{ solint_time_p }}
solve_phaseonly2.argument.solvetec.nchan                   =   {{ solint_freq_a }}

# switch "normal" data and weights with BL-averaged ones, length = ntimes * num_cal_blocks
switch_data_weights_col4.control.type                      =   switch_columns
switch_data_weights_col4.control.mapfile_in                =   {{ concat_data_mapfile }}
switch_data_weights_col4.control.inputkey                  =   msfile
switch_data_weights_col4.argument.flags                    =   [msfile]

########## end of second round of selfcal
########## start of third round of selfcal

# apply the previous calibration and average, length = ntimes * num_cal_blocks
apply_phaseonly2.control.type                                 =   dppp
apply_phaseonly2.control.opts.mapfiles_in                     =   [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_phaseonly2.control.opts.inputkeys                       =   [msin,parmdb]
{% if selfcal_local_dir is not none %}
apply_phaseonly2.control.opts.mapfile_out                     =   make_apply_mapfile.output.mapfile
apply_phaseonly2.control.opts.outputkey                       =   msout
apply_phaseonly2.argument.local_scratch_dir                   =   {{ selfcal_local_dir }}
{% endif %}
apply_phaseonly2.argument.numthreads                          =   {{ max_cpus_per_io_proc_ntimes }}
apply_phaseonly2.argument.msin.datacolumn                     =   DATA
apply_phaseonly2.argument.msout.overwrite                     =   True
apply_phaseonly2.argument.msout.writefullresflag              =   False
{% if preapply_solve_tec_only %}
apply_phaseonly2.argument.steps                               =   [correct_fast1,avg]
{% else %}
apply_phaseonly2.argument.steps                               =   [correct_fast1,correct_fast2,avg]
{% endif %}
apply_phaseonly2.argument.correct_fast1.type                  =   applycal
apply_phaseonly2.argument.correct_fast1.parmdb                =   parmdb
apply_phaseonly2.argument.correct_fast1.correction            =   tec
apply_phaseonly2.argument.correct_fast1.invert                =   True
{% if not preapply_solve_tec_only %}
apply_phaseonly2.argument.correct_fast2.type                  =   applycal
apply_phaseonly2.argument.correct_fast2.parmdb                =   parmdb
apply_phaseonly2.argument.correct_fast2.correction            =   commonscalarphase
apply_phaseonly2.argument.correct_fast2.invert                =   True
{% endif %}
apply_phaseonly2.argument.avg.type                            =   squash
apply_phaseonly2.argument.avg.freqstep                        =   1
apply_phaseonly2.argument.avg.timestep                        =   {{ facetselfcal_timestep }}
{% if use_compression %}
apply_phaseonly2.argument.msout.storagemanager                =   "Dysco"
apply_phaseonly2.argument.msout.storagemanager.databitrate    =   16
apply_phaseonly2.argument.msout.storagemanager.weightbitrate  =   12
apply_phaseonly2.argument.msout.storagemanager.distribution   =   "TruncatedGaussian"
apply_phaseonly2.argument.msout.storagemanager.disttruncation =   1.5
apply_phaseonly2.argument.msout.storagemanager.normalization  =   "AF"
{% endif %}

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile2.control.kind                    =   plugin
create_compressed_mapfile2.control.type                    =   compressMapfile
create_compressed_mapfile2.control.mapfile_in              =   apply_phaseonly2.output.mapfile
create_compressed_mapfile2.control.mapfile_dir             =   input.output.mapfile_dir
create_compressed_mapfile2.control.filename                =   image2_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image21.control.type                               =   wsclean
wsclean_image21.control.mapfiles_in                        =   [create_compressed_mapfile2.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image21.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image21.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image21.argument.fitsmask                          =   fitsmask
wsclean_image21.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image21.argument.niter                             =   1000
wsclean_image21.argument.threshold                         =   0.0
wsclean_image21.argument.pol                               =   I
wsclean_image21.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image21.argument.mgain                             =   0.6
wsclean_image21.argument.cleanborder                       =   0
wsclean_image21.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image21.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image21.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image21.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image21.argument.j                                 =   {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image21.argument.tempdir                           =   {{ local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image21.argument.multiscale-scales                 =   0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image21.argument.deconvolution-channels            =   3
wsclean_image21.argument.fit-spectral-pol                  =   3
{% endif %}
wsclean_image21.argument.weighting-rank-filter             =   3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image21.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map21.control.kind                        =   plugin
create_imagebase_map21.control.type                        =   trimMapfile
create_imagebase_map21.control.mapfile_in                  =   wsclean_image21.output.wsclean_image21-image.fits.mapfile
create_imagebase_map21.control.trim                        =   -
create_imagebase_map21.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map21.control.filename                    =   wsclean_image21_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile21.control.kind                      =   plugin
adjust_wsclean_mapfile21.control.type                      =   appendMapfile
adjust_wsclean_mapfile21.control.mapfile_in                =   create_imagebase_map21.output.mapfile
adjust_wsclean_mapfile21.control.append                    =   {{ wsclean_suffix }}
adjust_wsclean_mapfile21.control.mapfile_dir               =   input.output.mapfile_dir
adjust_wsclean_mapfile21.control.filename                  =   wsclean_image21_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask2.control.type                                         =   make_clean_mask
mask2.control.mapfile_in                                   =   adjust_wsclean_mapfile21.output.mapfile
mask2.control.inputkey                                     =   imagefile
mask2.control.outputkey                                    =   maskfile
mask2.argument.flags                                       =   [imagefile,maskfile]
mask2.argument.region_file                                 =   {{ region_selfcal }}
mask2.argument.threshpix                                   =   8
mask2.argument.threshisl                                   =   7
mask2.argument.iterate_threshold                           =   True
mask2.argument.atrous_do                                   =   {{ atrous_do }}
mask2.argument.rmsbox                                      =   (80,20)
mask2.argument.adaptive_rmsbox                             =   True
mask2.argument.trim_by                                     =   0.4
mask2.argument.img_format                                  =   fits
mask2.argument.threshold_format                            =   float
mask2.argument.use_adaptive_threshold                      =   {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image22.control.type                               =   wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image22.control.mapfiles_in                        =   [create_compressed_mapfile2.output.mapfile,mask2.output.mapfile,mask2.output.threshold_5sig.mapfile]
wsclean_image22.control.inputkeys                          =   [msfile,fitsmask,threshold]
wsclean_image22.argument.threshold                         =   threshold
wsclean_image22.argument.niter                             =   10000
{% else %}
wsclean_image22.control.mapfiles_in                        =   [create_compressed_mapfile2.output.mapfile,mask2.output.mapfile]
wsclean_image22.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image22.argument.threshold                         =   0.0
wsclean_image22.argument.niter                             =   1000
{% endif %}
wsclean_image22.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image22.argument.fitsmask                          =   fitsmask
wsclean_image22.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image22.argument.pol                               =   I
wsclean_image22.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image22.argument.mgain                             =   0.6
wsclean_image22.argument.cleanborder                       =   0
wsclean_image22.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image22.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image22.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image22.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image22.argument.j                                 =   {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image22.argument.tempdir                           =   {{ local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image22.argument.multiscale-scales                 =   0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image22.argument.deconvolution-channels            =   3
wsclean_image22.argument.fit-spectral-pol                  =   3
{% endif %}
wsclean_image22.argument.weighting-rank-filter             =   3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image22.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map22.control.kind                        =   plugin
create_imagebase_map22.control.type                        =   trimMapfile
create_imagebase_map22.control.mapfile_in                  =   wsclean_image22.output.wsclean_image22-image.fits.mapfile
create_imagebase_map22.control.trim                        =   -
create_imagebase_map22.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map22.control.filename                    =   wsclean_image22_image_rootname.mapfile

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model2_mapfile.control.kind                =   plugin
create_expanded_model2_mapfile.control.type                =   expandMapfile
create_expanded_model2_mapfile.control.mapfile_in          =   create_imagebase_map22.output.mapfile
create_expanded_model2_mapfile.control.mapfile_to_match    =   regroup_concat_data_map.output.mapfile
create_expanded_model2_mapfile.control.mapfile_dir         =   input.output.mapfile_dir
create_expanded_model2_mapfile.control.filename            =   expand_wsclean_model1.mapfile

# pad the model image with zeros, length = 1
pad_selfcal_model2_images.control.type                     =   pad_image
pad_selfcal_model2_images.control.mapfile_in               =   create_imagebase_map22.output.mapfile
pad_selfcal_model2_images.control.inputkey                 =   imagefile
pad_selfcal_model2_images.argument.flags                   =   [imagefile,{{ wsclean_patch_model_padding }}]

# predict model visibilities, length = ntimes
wsclean_ft2.control.type                                   =   wsclean_ft
wsclean_ft2.control.mapfiles_in                            =   [regroup_concat_data_map.output.mapfile,create_expanded_model2_mapfile.output.mapfile,expand_selfcal_model_size_map.output.mapfile]
wsclean_ft2.control.inputkeys                              =   [msfile,name,size]
wsclean_ft2.argument.flags                                 =   [-predict,msfile]
wsclean_ft2.argument.scale                                 =   {{ cellsize_selfcal_deg }}
wsclean_ft2.argument.mem                                   =   {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft2.argument.channelsout                           =   {{ wsclean_nchannels_selfcal }}
wsclean_ft2.argument.j                                     =   {{ max_cpus_per_io_proc_ntimes }}
{% if local_dir is not none %}
wsclean_ft2.argument.tempdir                               =   {{ local_dir }}
{% endif %}

# switch "normal" data and weights with BL-averaged ones, length = ntimes * num_cal_blocks
switch_data_weights_col5.control.type                      =   switch_columns
switch_data_weights_col5.control.mapfile_in                =   {{ concat_data_mapfile }}
switch_data_weights_col5.control.inputkey                  =   msfile
switch_data_weights_col5.argument.flags                    =   [msfile]

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs11.control.type                              =   remove_file
remove_parmdbs11.control.mapfile_in                        =   make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs11.control.inputkey                          =   parmdb
remove_parmdbs11.argument.flags                            =   [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase11.control.type                              =   dppp_inplace
solve_ampphase11.control.mapfiles_in                       =   [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
solve_ampphase11.control.inputkeys                         =   [msin,parmdb]
solve_ampphase11.argument.numthreads                       =   {{ max_cpus_per_proc_ntimes }}
solve_ampphase11.argument.msin.datacolumn                  =   DATA
solve_ampphase11.argument.msout                            =   .
solve_ampphase11.argument.steps                            =   [uvcut,solvetec]
solve_ampphase11.argument.uvcut.type                       =   uvwflagger
solve_ampphase11.argument.uvcut.uvlambdamin                =   {{ solve_min_uv_lambda }}
solve_ampphase11.argument.solvetec.type                    =   gaincal
{% if preapply_solve_tec_only %}
solve_ampphase11.argument.solvetec.caltype                 =   tec
{% else %}
solve_ampphase11.argument.solvetec.caltype                 =   tecandphase
{% endif %}
solve_ampphase11.argument.solvetec.parmdb                  =   parmdb
solve_ampphase11.argument.solvetec.usemodelcolumn          =   True
solve_ampphase11.argument.solvetec.solint                  =   {{ solint_time_p }}
solve_ampphase11.argument.solvetec.nchan                   =   {{ solint_freq_a }}

# switch "normal" data and weights with BL-averaged ones, length = ntimes * num_cal_blocks
switch_data_weights_col6.control.type                      =   switch_columns
switch_data_weights_col6.control.mapfile_in                =   {{ concat_data_mapfile }}
switch_data_weights_col6.control.inputkey                  =   msfile
switch_data_weights_col6.argument.flags                    =   [msfile]

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase11.control.type                                 =   dppp_inplace
apply_ampphase11.control.opts.mapfiles_in                     =   [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_ampphase11.control.opts.inputkeys                       =   [msin,parmdb]
apply_ampphase11.argument.numthreads                          =   {{ max_cpus_per_proc_ntimes }}
apply_ampphase11.argument.msin.datacolumn                     =   DATA
apply_ampphase11.argument.msout                               =   .
apply_ampphase11.argument.msout.datacolumn                    =   CORRECTED_DATA
{% if preapply_solve_tec_only %}
apply_ampphase11.argument.steps                               =   [correct_fast1]
{% else %}
apply_ampphase11.argument.steps                               =   [correct_fast1,correct_fast2]
{% endif %}
apply_ampphase11.argument.correct_fast1.type                  =   applycal
apply_ampphase11.argument.correct_fast1.parmdb                =   parmdb
apply_ampphase11.argument.correct_fast1.correction            =   tec
apply_ampphase11.argument.correct_fast1.invert                =   True
{% if not preapply_solve_tec_only %}
apply_ampphase11.argument.correct_fast2.type                  =   applycal
apply_ampphase11.argument.correct_fast2.parmdb                =   parmdb
apply_ampphase11.argument.correct_fast2.correction            =   commonscalarphase
apply_ampphase11.argument.correct_fast2.invert                =   True
{% endif %}
{% if use_compression %}
apply_ampphase11.argument.msout.storagemanager                =   "Dysco"
apply_ampphase11.argument.msout.storagemanager.databitrate    =   16
apply_ampphase11.argument.msout.storagemanager.weightbitrate  =   12
apply_ampphase11.argument.msout.storagemanager.distribution   =   "TruncatedGaussian"
apply_ampphase11.argument.msout.storagemanager.disttruncation =   1.5
apply_ampphase11.argument.msout.storagemanager.normalization  =   "AF"
{% endif %}

# generate mapfile for the slow-gain parmDBs generated in the solve_ampphase12 step
make_slow_gain_parmdb_map.control.kind                     =  plugin
make_slow_gain_parmdb_map.control.type                     =  createMapfile
make_slow_gain_parmdb_map.control.method                   =  add_suffix_to_file
make_slow_gain_parmdb_map.control.mapfile_in               =  concat_data.output.mapfile
make_slow_gain_parmdb_map.control.add_suffix_to_file       =  /instrument_slow
make_slow_gain_parmdb_map.control.mapfile_dir              =  input.output.mapfile_dir
make_slow_gain_parmdb_map.control.filename                 =  slow_parmdb.mapfile

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs12.control.type                              =   remove_file
remove_parmdbs12.control.mapfile_in                        =   make_slow_gain_parmdb_map.output.mapfile
remove_parmdbs12.control.inputkey                          =   parmdb
remove_parmdbs12.argument.flags                            =   [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase12.control.type                              =   dppp_inplace
solve_ampphase12.control.mapfiles_in                       =   [{{ concat_data_mapfile }},make_slow_gain_parmdb_map.output.mapfile]
solve_ampphase12.control.inputkeys                         =   [msin,parmdb]
solve_ampphase12.argument.numthreads                       =   {{ max_cpus_per_proc_ntimes }}
solve_ampphase12.argument.msin.datacolumn                  =   CORRECTED_DATA
solve_ampphase12.argument.msout                            =   .
solve_ampphase12.argument.steps                            =   [uvcut,solvegain]
solve_ampphase12.argument.uvcut.type                       =   uvwflagger
solve_ampphase12.argument.uvcut.uvlambdamin                =   {{ solve_min_uv_lambda }}
solve_ampphase12.argument.solvegain.type                   =   gaincal
solve_ampphase12.argument.solvegain.caltype                =   {{ selfcal_caltype }}
solve_ampphase12.argument.solvegain.parmdb                 =   parmdb
solve_ampphase12.argument.solvegain.usemodelcolumn         =   True
solve_ampphase12.argument.solvegain.solint                 =   {{ solint_time_a }}
solve_ampphase12.argument.solvegain.nchan                  =   {{ solint_freq_a }}

# merge the parmDBs with the amplitude solutions into one, length = 1
merge_amp_parmdbs1.control.type                            =   merge_parmdbs_in_time
merge_amp_parmdbs1.control.mapfile_in                      =   concat_data_compressed_mapfile.output.mapfile
merge_amp_parmdbs1.control.inputkey                        =   mslist
merge_amp_parmdbs1.control.outputkey                       =   outparmdb
merge_amp_parmdbs1.argument.flags                          =   [mslist,instrument_slow,outparmdb]

# smooth the amplitues in the merged parmDB, length = 1
# smooth_amps uses only ANTENNA subtable of inputms, so it should work on virtual concatenated MS
smooth_amp1.control.type                                   =   {{ smooth_amps_task }}
smooth_amp1.control.mapfile_in                             =   merge_amp_parmdbs1.output.mapfile
smooth_amp1.control.inputkey                               =   ampparmdb
smooth_amp1.control.outputkey                              =   outparmdb
smooth_amp1.control.arguments                              =   [ampparmdb,outparmdb]

# expand the mapfile with the smoothd parmDB to all time-steps, length = ntimes * num_cal_blocks
expand_smoothed_amp1_parmdb_map.control.kind               =   plugin
expand_smoothed_amp1_parmdb_map.control.type               =   expandMapfile
expand_smoothed_amp1_parmdb_map.control.mapfile_in         =   smooth_amp1.output.mapfile
expand_smoothed_amp1_parmdb_map.control.mapfile_to_match   =   concat_data.output.mapfile
expand_smoothed_amp1_parmdb_map.control.mapfile_dir        =   input.output.mapfile_dir
expand_smoothed_amp1_parmdb_map.control.filename           =   expand_amp1_smoothed_parmdbs.mapfile

# apply the smoothed amplitudes and average, length = ntimes * num_cal_blocks
apply_amp1.control.type                                    =   dppp
apply_amp1.control.opts.mapfiles_in                        =   [{{ concat_data_mapfile }},expand_smoothed_amp1_parmdb_map.output.mapfile]
apply_amp1.control.opts.inputkeys                          =   [msin,parmdb]
{% if selfcal_local_dir is not none %}
apply_amp1.control.opts.mapfile_out                        =   make_apply_mapfile.output.mapfile
apply_amp1.control.opts.outputkey                          =   msout
apply_amp1.argument.local_scratch_dir                      =   {{ selfcal_local_dir }}
{% endif %}
apply_amp1.argument.numthreads                             =   {{ max_cpus_per_io_proc_ntimes }}
apply_amp1.argument.msin.datacolumn                        =   CORRECTED_DATA
apply_amp1.argument.msout.overwrite                        =   True
apply_amp1.argument.msout.writefullresflag                 =   False
apply_amp1.argument.steps                                  =   [correct_slow,avg]
apply_amp1.argument.correct_slow.type                      =   applycal
apply_amp1.argument.correct_slow.parmdb                    =   parmdb
apply_amp1.argument.correct_slow.invert                    =   True
apply_amp1.argument.avg.type                               =   squash
apply_amp1.argument.avg.freqstep                           =   1
apply_amp1.argument.avg.timestep                           =   {{ facetselfcal_timestep }}
{% if use_compression %}
apply_amp1.argument.msout.storagemanager                   =   "Dysco"
apply_amp1.argument.msout.storagemanager.databitrate       =   16
apply_amp1.argument.msout.storagemanager.weightbitrate     =   12
apply_amp1.argument.msout.storagemanager.distribution      =   "TruncatedGaussian"
apply_amp1.argument.msout.storagemanager.disttruncation    =   1.5
apply_amp1.argument.msout.storagemanager.normalization     =   "AF"
{% endif %}

########## end of third round of selfcal
########## start of fourth round of selfcal

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile3.control.kind                    =   plugin
create_compressed_mapfile3.control.type                    =   compressMapfile
create_compressed_mapfile3.control.mapfile_in              =   apply_amp1.output.mapfile
create_compressed_mapfile3.control.mapfile_dir             =   input.output.mapfile_dir
create_compressed_mapfile3.control.filename                =   image3_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image31.control.type                               =   wsclean
wsclean_image31.control.mapfiles_in                        =   [create_compressed_mapfile3.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image31.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image31.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image31.argument.fitsmask                          =   fitsmask
wsclean_image31.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image31.argument.niter                             =   1000
wsclean_image31.argument.threshold                         =   0.0
wsclean_image31.argument.pol                               =   I
wsclean_image31.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image31.argument.mgain                             =   0.6
wsclean_image31.argument.cleanborder                       =   0
wsclean_image31.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image31.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image31.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image31.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image31.argument.j                                 =   {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image31.argument.tempdir                           =   {{ local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image31.argument.multiscale-scales                 =   0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image21.argument.deconvolution-channels            =   3
wsclean_image21.argument.fit-spectral-pol                  =   3
{% endif %}
wsclean_image31.argument.weighting-rank-filter             =   3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image31.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map31.control.kind                        =   plugin
create_imagebase_map31.control.type                        =   trimMapfile
create_imagebase_map31.control.mapfile_in                  =   wsclean_image31.output.wsclean_image31-image.fits.mapfile
create_imagebase_map31.control.trim                        =   -
create_imagebase_map31.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map31.control.filename                    =   wsclean_image31_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile31.control.kind                      =   plugin
adjust_wsclean_mapfile31.control.type                      =   appendMapfile
adjust_wsclean_mapfile31.control.mapfile_in                =   create_imagebase_map31.output.mapfile
adjust_wsclean_mapfile31.control.append                    =   {{ wsclean_suffix }}
adjust_wsclean_mapfile31.control.mapfile_dir               =   input.output.mapfile_dir
adjust_wsclean_mapfile31.control.filename                  =   wsclean_image31_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask3.control.type                                         =   make_clean_mask
mask3.control.mapfile_in                                   =   adjust_wsclean_mapfile31.output.mapfile
mask3.control.inputkey                                     =   imagefile
mask3.control.outputkey                                    =   maskfile
mask3.argument.flags                                       =   [imagefile,maskfile]
mask3.argument.region_file                                 =   {{ region_selfcal }}
mask3.argument.threshpix                                   =   10
mask3.argument.threshisl                                   =   10
mask3.argument.iterate_threshold                           =   True
mask3.argument.atrous_do                                   =   {{ atrous_do }}
mask3.argument.rmsbox                                      =   (80,20)
mask3.argument.adaptive_rmsbox                             =   True
mask3.argument.trim_by                                     =   0.4
mask3.argument.img_format                                  =   fits
mask3.argument.adaptive_thresh                             =   180
mask3.argument.threshold_format                            =   float
mask3.argument.use_adaptive_threshold                      =   {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image32.control.type                               =   wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image32.control.mapfiles_in                        =   [create_compressed_mapfile3.output.mapfile,mask3.output.mapfile,mask3.output.threshold_5sig.mapfile]
wsclean_image32.control.inputkeys                          =   [msfile,fitsmask,threshold]
wsclean_image32.argument.threshold                         =   threshold
wsclean_image32.argument.niter                             =   10000
{% else %}
wsclean_image32.control.mapfiles_in                        =   [create_compressed_mapfile3.output.mapfile,mask3.output.mapfile]
wsclean_image32.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image32.argument.threshold                         =   0.0
wsclean_image32.argument.niter                             =   1000
{% endif %}
wsclean_image32.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image32.argument.fitsmask                          =   fitsmask
wsclean_image32.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image32.argument.pol                               =   I
wsclean_image32.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image32.argument.mgain                             =   0.6
wsclean_image32.argument.cleanborder                       =   0
wsclean_image32.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image32.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image32.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image32.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image32.argument.j                                 =   {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image32.argument.tempdir                           =   {{ local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image32.argument.multiscale-scales                 =   0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image32.argument.deconvolution-channels            =   3
wsclean_image32.argument.fit-spectral-pol                  =   3
{% endif %}
wsclean_image32.argument.weighting-rank-filter             =   3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image32.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

########## start of selfcal loop

# loop step
loop_ampcal.control.kind                                   =   loop
loop_ampcal.control.type                                   =   conditional
loop_ampcal.control.loopcount                              =   {{ loopcount }}
loop_ampcal.control.loopsteps                              =   [create_imagebase_map32,create_expanded_model3_mapfile,pad_selfcal_model3_images,wsclean_ft3,{% if pre_average %}switch_data_weights_col7,{% endif %}remove_parmdbs21,solve_ampphase21,{% if pre_average %}switch_data_weights_col8,{% endif %}apply_ampphase21,merge_phase_parmdbs,remove_parmdbs22,solve_ampphase22,merge_amp_parmdbs2,smooth_amp2,expand_smoothed_amp2_parmdb_map,apply_amp2,create_compressed_mapfile4,wsclean_image41,create_imagebase_map41,adjust_wsclean_mapfile41,mask4,wsclean_image42,create_imagebase_map42,adjust_wsclean_mapfile42,copy_image,check_image]

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map32.control.kind                        =   plugin
create_imagebase_map32.control.type                        =   trimMapfile
create_imagebase_map32.control.mapfile_in                  =   wsclean_image32.output.wsclean_image32-image.fits.mapfile
create_imagebase_map32.control.trim                        =   -
create_imagebase_map32.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map32.control.filename                    =   model3_rootnames.mapfile
create_imagebase_map32.control.counter                     =   loop_ampcal.output.counter

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model3_mapfile.control.kind                =   plugin
create_expanded_model3_mapfile.control.type                =   expandMapfile
create_expanded_model3_mapfile.control.mapfile_in          =   create_imagebase_map32.output.mapfile
create_expanded_model3_mapfile.control.mapfile_to_match    =   regroup_concat_data_map.output.mapfile
create_expanded_model3_mapfile.control.mapfile_dir         =   input.output.mapfile_dir
create_expanded_model3_mapfile.control.filename            =   expand_wsclean_model1.mapfile

# pad the model image with zeros, length = 1
pad_selfcal_model3_images.control.type                     =   pad_image
pad_selfcal_model3_images.control.mapfile_in               =   create_imagebase_map32.output.mapfile
pad_selfcal_model3_images.control.inputkey                 =   imagefile
pad_selfcal_model3_images.argument.flags                   =   [imagefile,{{ wsclean_patch_model_padding }}]

# predict model visibilities, length =  times
wsclean_ft3.control.type                                   =   wsclean_ft
wsclean_ft3.control.mapfiles_in                            =   [regroup_concat_data_map.output.mapfile,create_expanded_model3_mapfile.output.mapfile,expand_selfcal_model_size_map.output.mapfile]
wsclean_ft3.control.inputkeys                              =   [msfile,name,size]
wsclean_ft3.argument.flags                                 =   [-predict,msfile]
wsclean_ft3.argument.scale                                 =   {{ cellsize_selfcal_deg }}
wsclean_ft3.argument.mem                                   =   {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft3.argument.channelsout                           =   {{ wsclean_nchannels_selfcal }}
wsclean_ft3.argument.j                                     =   {{ max_cpus_per_io_proc_ntimes }}
{% if local_dir is not none %}
wsclean_ft3.argument.tempdir                               =   {{ local_dir }}
{% endif %}

# switch "normal" data and weights with BL-averaged ones, length = ntimes * num_cal_blocks
switch_data_weights_col7.control.type                      =   switch_columns
switch_data_weights_col7.control.mapfile_in                =   {{ concat_data_mapfile }}
switch_data_weights_col7.control.inputkey                  =   msfile
switch_data_weights_col7.argument.flags                    =   [msfile]

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs21.control.type                              =   remove_file
remove_parmdbs21.control.mapfile_in                        =   make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs21.control.inputkey                          =   parmdb
remove_parmdbs21.argument.flags                            =   [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase21.control.type                              =   dppp_inplace
solve_ampphase21.control.mapfiles_in                       =   [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
solve_ampphase21.control.inputkeys                         =   [msin,parmdb]
solve_ampphase21.argument.numthreads                       =   {{ max_cpus_per_proc_ntimes }}
solve_ampphase21.argument.msin.datacolumn                  =   DATA
solve_ampphase21.argument.msout                            =   .
solve_ampphase21.argument.steps                            =   [uvcut,solvetec]
solve_ampphase21.argument.uvcut.type                       =   uvwflagger
solve_ampphase21.argument.uvcut.uvlambdamin                =   {{ solve_min_uv_lambda }}
solve_ampphase21.argument.solvetec.type                    =   gaincal
{% if preapply_solve_tec_only %}
solve_ampphase21.argument.solvetec.caltype                 =   tec
{% else %}
solve_ampphase21.argument.solvetec.caltype                 =   tecandphase
{% endif %}
solve_ampphase21.argument.solvetec.parmdb                  =   parmdb
solve_ampphase21.argument.solvetec.usemodelcolumn          =   True
solve_ampphase21.argument.solvetec.solint                  =   {{ solint_time_p }}
solve_ampphase21.argument.solvetec.nchan                   =   {{ solint_freq_a }}

# switch "normal" data and weights with BL-averaged ones, length = ntimes * num_cal_blocks
switch_data_weights_col8.control.type                      =   switch_columns
switch_data_weights_col8.control.mapfile_in                =   {{ concat_data_mapfile }}
switch_data_weights_col8.control.inputkey                  =   msfile
switch_data_weights_col8.argument.flags                    =   [msfile]

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase21.control.type                                 =   dppp_inplace
apply_ampphase21.control.opts.mapfiles_in                     =   [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_ampphase21.control.opts.inputkeys                       =   [msin,parmdb]
apply_ampphase21.argument.numthreads                          =   {{ max_cpus_per_proc_ntimes }}
apply_ampphase21.argument.msin.datacolumn                     =   DATA
apply_ampphase21.argument.msout                               =   .
apply_ampphase21.argument.msout.datacolumn                    =   CORRECTED_DATA
{% if preapply_solve_tec_only %}
apply_ampphase21.argument.steps                               =   [correct_fast1]
{% else %}
apply_ampphase21.argument.steps                               =   [correct_fast1,correct_fast2]
{% endif %}
apply_ampphase21.argument.correct_fast1.type                  =   applycal
apply_ampphase21.argument.correct_fast1.parmdb                =   parmdb
apply_ampphase21.argument.correct_fast1.correction            =   tec
apply_ampphase21.argument.correct_fast1.invert                =   True
{% if not preapply_solve_tec_only %}
apply_ampphase21.argument.correct_fast2.type                  =   applycal
apply_ampphase21.argument.correct_fast2.parmdb                =   parmdb
apply_ampphase21.argument.correct_fast2.correction            =   commonscalarphase
apply_ampphase21.argument.correct_fast2.invert                =   True
{% endif %}
{% if use_compression %}
apply_ampphase21.argument.msout.storagemanager                =   "Dysco"
apply_ampphase21.argument.msout.storagemanager.databitrate    =   16
apply_ampphase21.argument.msout.storagemanager.weightbitrate  =   12
apply_ampphase21.argument.msout.storagemanager.distribution   =   "TruncatedGaussian"
apply_ampphase21.argument.msout.storagemanager.disttruncation =   1.5
apply_ampphase21.argument.msout.storagemanager.normalization  =   "AF"
{% endif %}

# merge the parmDBs with the phase solutions into one, length = 1
# This is needed later when the loop is done and we want to apply the solutions to the original data
merge_phase_parmdbs.control.type                           =   merge_parmdbs_in_time
merge_phase_parmdbs.control.mapfile_in                     =   concat_data_compressed_mapfile.output.mapfile
merge_phase_parmdbs.control.inputkey                       =   mslist
merge_phase_parmdbs.control.outputkey                      =   outparmdb
merge_phase_parmdbs.argument.flags                         =   [mslist,instrument,outparmdb]

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs22.control.type                              =   remove_file
remove_parmdbs22.control.mapfile_in                        =   make_slow_gain_parmdb_map.output.mapfile
remove_parmdbs22.control.inputkey                          =   parmdb
remove_parmdbs22.argument.flags                            =   [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase22.control.type                              =   dppp_inplace
solve_ampphase22.control.mapfiles_in                       =   [{{ concat_data_mapfile }},make_slow_gain_parmdb_map.output.mapfile]
solve_ampphase22.control.inputkeys                         =   [msin,parmdb]
solve_ampphase22.argument.numthreads                       =   {{ max_cpus_per_proc_ntimes }}
solve_ampphase22.argument.msin.datacolumn                  =   CORRECTED_DATA
solve_ampphase22.argument.msout                            =   .
solve_ampphase22.argument.steps                            =   [uvcut,solvegain]
solve_ampphase22.argument.uvcut.type                       =   uvwflagger
solve_ampphase22.argument.uvcut.uvlambdamin                =   {{ solve_min_uv_lambda }}
solve_ampphase22.argument.solvegain.type                   =   gaincal
solve_ampphase22.argument.solvegain.caltype                =   {{ selfcal_caltype }}
solve_ampphase22.argument.solvegain.parmdb                 =   parmdb
solve_ampphase22.argument.solvegain.usemodelcolumn         =   True
solve_ampphase22.argument.solvegain.solint                 =   {{ solint_time_a }}
solve_ampphase22.argument.solvegain.nchan                  =   {{ solint_freq_a }}

# merge the parmDBs with the amplitude solutions into one, length = 1
# This is also used after the loop, but also now for smoothing the amplitudes
merge_amp_parmdbs2.control.type                            =   merge_parmdbs_in_time
merge_amp_parmdbs2.control.mapfile_in                      =   concat_data_compressed_mapfile.output.mapfile
merge_amp_parmdbs2.control.inputkey                        =   mslist
merge_amp_parmdbs2.control.outputkey                       =   outparmdb
merge_amp_parmdbs2.argument.flags                          =   [mslist,instrument_slow,outparmdb]

# smooth the amplitudes in the merged parmDB, length = 1
# smooth_amps uses only ANTENNA subtable of inputms, so it should work on virtual concatenated MS
smooth_amp2.control.type                                   =   {{ smooth_amps_task }}
smooth_amp2.control.mapfile_in                             =   merge_amp_parmdbs2.output.mapfile
smooth_amp2.control.inputkey                               =   ampparmdb
smooth_amp2.control.outputkey                              =   outparmdb
smooth_amp2.control.arguments                              =   [ampparmdb,outparmdb]

# expand the mapfile with the smoothd parmDB to all time-steps, length = ntimes * num_cal_blocks
expand_smoothed_amp2_parmdb_map.control.kind               =   plugin
expand_smoothed_amp2_parmdb_map.control.type               =   expandMapfile
expand_smoothed_amp2_parmdb_map.control.mapfile_in         =   smooth_amp2.output.mapfile
expand_smoothed_amp2_parmdb_map.control.mapfile_to_match   =   concat_data.output.mapfile
expand_smoothed_amp2_parmdb_map.control.mapfile_dir        =   input.output.mapfile_dir
expand_smoothed_amp2_parmdb_map.control.filename           =   expand_amp2_smoothed_parmdbs.mapfile

# apply the smoothed amplitudes and average, length = ntimes * num_cal_blocks
apply_amp2.control.type                                    =   dppp
apply_amp2.control.opts.mapfiles_in                        =   [{{ concat_data_mapfile }},expand_smoothed_amp2_parmdb_map.output.mapfile]
apply_amp2.control.opts.inputkeys                          =   [msin,parmdb]
{% if selfcal_local_dir is not none %}
apply_amp2.control.opts.mapfile_out                        =   make_apply_mapfile.output.mapfile
apply_amp2.control.opts.outputkey                          =   msout
apply_amp2.argument.local_scratch_dir                      =   {{ selfcal_local_dir }}
{% endif %}
apply_amp2.argument.numthreads                             =   {{ max_cpus_per_io_proc_ntimes }}
apply_amp2.argument.msin.datacolumn                        =   CORRECTED_DATA
apply_amp2.argument.msout.overwrite                        =   True
apply_amp2.argument.msout.writefullresflag                 =   False
apply_amp2.argument.steps                                  =   [correct_slow,avg]
apply_amp2.argument.correct_slow.type                      =   applycal
apply_amp2.argument.correct_slow.parmdb                    =   parmdb
apply_amp2.argument.correct_slow.invert                    =   True
apply_amp2.argument.avg.type                               =   squash
apply_amp2.argument.avg.freqstep                           =   1
apply_amp2.argument.avg.timestep                           =   {{ facetselfcal_timestep }}
{% if use_compression %}
apply_amp2.argument.msout.storagemanager                   =   "Dysco"
apply_amp2.argument.msout.storagemanager.databitrate       =   16
apply_amp2.argument.msout.storagemanager.weightbitrate     =   12
apply_amp2.argument.msout.storagemanager.distribution      =   "TruncatedGaussian"
apply_amp2.argument.msout.storagemanager.disttruncation    =   1.5
apply_amp2.argument.msout.storagemanager.normalization     =   "AF"
{% endif %}

########## end of fourth or of the looped round of selfcal

########## start of looped round of selfcal
########## make image to check if we can stop the loop, or as new model

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile4.control.kind                    =   plugin
create_compressed_mapfile4.control.type                    =   compressMapfile
create_compressed_mapfile4.control.mapfile_in              =   apply_amp2.output.mapfile
create_compressed_mapfile4.control.mapfile_dir             =   input.output.mapfile_dir
create_compressed_mapfile4.control.filename                =   image4_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image41.control.type                               =   wsclean
wsclean_image41.control.mapfiles_in                        =   [create_compressed_mapfile4.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image41.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image41.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image41.argument.fitsmask                          =   fitsmask
wsclean_image41.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image41.argument.niter                             =   1000
wsclean_image41.argument.threshold                         =   0.0
wsclean_image41.argument.pol                               =   I
wsclean_image41.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image41.argument.mgain                             =   0.6
wsclean_image41.argument.cleanborder                       =   0
wsclean_image41.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image41.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image41.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image41.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image41.argument.j                                 =   {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image41.argument.tempdir                           =   {{ local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image41.argument.multiscale-scales                 =   0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image41.argument.deconvolution-channels            =   3
wsclean_image41.argument.fit-spectral-pol                  =   3
{% endif %}
wsclean_image41.argument.weighting-rank-filter             =   3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image41.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map41.control.kind                        =   plugin
create_imagebase_map41.control.type                        =   trimMapfile
create_imagebase_map41.control.mapfile_in                  =   wsclean_image41.output.wsclean_image41-image.fits.mapfile
create_imagebase_map41.control.trim                        =   -
create_imagebase_map41.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map41.control.filename                    =   wsclean_image41_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile41.control.kind                      =   plugin
adjust_wsclean_mapfile41.control.type                      =   appendMapfile
adjust_wsclean_mapfile41.control.mapfile_in                =   create_imagebase_map41.output.mapfile
adjust_wsclean_mapfile41.control.append                    =   {{ wsclean_suffix }}
adjust_wsclean_mapfile41.control.mapfile_dir               =   input.output.mapfile_dir
adjust_wsclean_mapfile41.control.filename                  =   wsclean_image41_imagename.mapfile

# generate a clean-mask from first image, length = 1
mask4.control.type                                         =   make_clean_mask
mask4.control.mapfile_in                                   =   adjust_wsclean_mapfile41.output.mapfile
mask4.control.inputkey                                     =   imagefile
mask4.control.outputkey                                    =   maskfile
mask4.argument.flags                                       =   [imagefile,maskfile]
mask4.argument.region_file                                 =   {{ region_selfcal }}
mask4.argument.threshpix                                   =   8
mask4.argument.threshisl                                   =   8
mask4.argument.iterate_threshold                           =   True
mask4.argument.atrous_do                                   =   {{ atrous_do }}
mask4.argument.rmsbox                                      =   (80,20)
mask4.argument.adaptive_rmsbox                             =   True
mask4.argument.trim_by                                     =   0.4
mask4.argument.img_format                                  =   fits
mask4.argument.adaptive_thresh                             =   200
mask4.argument.threshold_format                            =   float
mask4.argument.use_adaptive_threshold                      =   {{ use_selfcal_adaptive_threshold }}

# image the virtual concatenated data again with wsclean, length = 1
wsclean_image42.control.type                               =   wsclean
{% if use_selfcal_clean_threshold %}
wsclean_image42.control.mapfiles_in                        =   [create_compressed_mapfile4.output.mapfile,mask4.output.mapfile,mask4.output.threshold_5sig.mapfile]
wsclean_image42.control.inputkeys                          =   [msfile,fitsmask,threshold]
wsclean_image42.argument.threshold                         =   threshold
wsclean_image42.argument.niter                             =   10000
{% else %}
wsclean_image42.control.mapfiles_in                        =   [create_compressed_mapfile4.output.mapfile,mask4.output.mapfile]
wsclean_image42.control.inputkeys                          =   [msfile,fitsmask]
wsclean_image42.argument.threshold                         =   0.0
wsclean_image42.argument.niter                             =   1000
{% endif %}
wsclean_image42.argument.flags                             =   [-no-update-model-required,-multiscale,-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image42.argument.fitsmask                          =   fitsmask
wsclean_image42.argument.size                              =   {{ cal_imsize }} {{ cal_imsize }}
wsclean_image42.argument.pol                               =   I
wsclean_image42.argument.weight                            =   briggs {{ robust_selfcal }}
wsclean_image42.argument.mgain                             =   0.6
wsclean_image42.argument.cleanborder                       =   0
wsclean_image42.argument.minuv-l                           =   {{ selfcal_min_uv_lambda }}
wsclean_image42.argument.scale                             =   {{ cellsize_selfcal_deg }}
wsclean_image42.argument.channelsout                       =   {{ wsclean_nchannels_selfcal }}
wsclean_image42.argument.mem                               =   {{ max_percent_memory_per_proc_single }}
wsclean_image42.argument.j                                 =   {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image42.argument.tempdir                           =   {{ local_dir }}
{% endif %}
{% if not wsclean_selfcal_multiscale %}
wsclean_image42.argument.multiscale-scales                 =   0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 and fit_spectral_pol %}
wsclean_image42.argument.deconvolution-channels            =   3
wsclean_image42.argument.fit-spectral-pol                  =   3
{% endif %}
wsclean_image42.argument.weighting-rank-filter             =   3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image42.argument.baseline-averaging                =   {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map42.control.kind                        =   plugin
create_imagebase_map42.control.type                        =   trimMapfile
create_imagebase_map42.control.mapfile_in                  =   wsclean_image42.output.wsclean_image42-image.fits.mapfile
create_imagebase_map42.control.trim                        =   -
create_imagebase_map42.control.mapfile_dir                 =   input.output.mapfile_dir
create_imagebase_map42.control.filename                    =   wsclean_image41_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile42.control.kind                      =   plugin
adjust_wsclean_mapfile42.control.type                      =   appendMapfile
adjust_wsclean_mapfile42.control.mapfile_in                =   create_imagebase_map42.output.mapfile
adjust_wsclean_mapfile42.control.append                    =   {{ wsclean_suffix }}
adjust_wsclean_mapfile42.control.mapfile_dir               =   input.output.mapfile_dir
adjust_wsclean_mapfile42.control.filename                  =   compare_image_input_new.mapfile

# copy the output image so that we can compare it later, length = 1
copy_image.control.type                                    =   copy_image
copy_image.control.mapfile_in                              =   adjust_wsclean_mapfile42.output.mapfile
copy_image.control.inputkey                                =   image
copy_image.argument.flags                                  =   [image,loop_ampcal.output.counter,4]

# compare the current and the previous image to see if we can stop the loop, length = 1
check_image.control.type                                   =   compare_image_stats
check_image.control.mapfiles_in                            =   [adjust_wsclean_mapfile42.output.mapfile,copy_image.output.previous_image.mapfile]
check_image.control.inputkeys                              =   [image_new,image_prev]
check_image.argument.flags                                 =   [image_new,image_prev]

########## end of selfcal loop

{% if selfcal_local_dir is not none %}
# remove concat_data files, length = ntimes * num_cal_blocks
remove_concat_data.control.type                            =   remove_file
remove_concat_data.control.mapfile_in                      =   make_concat_data_sync_mapfile.output.mapfile
remove_concat_data.control.inputkey                        =   msfile
remove_concat_data.argument.flags                          =   [-rf,msfile]
{% endif %}

# merge the phases and amplitudes parmDBs, length = 1
merge_selfcal_parmdbs.control.type                         =   merge_parmdbs_selfcal
merge_selfcal_parmdbs.control.mapfiles_in                  =   [merge_phase_parmdbs.output.mapfile,smooth_amp2.output.mapfile]
merge_selfcal_parmdbs.control.inputkeys                    =   [parmdb_p,parmdb_a]
merge_selfcal_parmdbs.control.outputkey                    =   parmdb_out
merge_selfcal_parmdbs.argument.flags                       =   [parmdb_p,parmdb_a,parmdb_out]

{% if create_preapply_parmdb %}
# make a phase-only parmDB suitable for preapplication, length = 1
create_preapply_parmdb.control.type                        =   reset_amps
create_preapply_parmdb.control.mapfile_in                  =   merge_selfcal_parmdbs.output.mapfile
create_preapply_parmdb.control.inputkey                    =   inparmdb
create_preapply_parmdb.control.outputkey                   =   outparmdb
create_preapply_parmdb.control.arguments                   =   [inparmdb,outparmdb]
{% endif %}

# make plots of the selfcal solutions from the marged parmDB, length = 1
make_selfcal_plots.control.type                            =   make_selfcal_plots
make_selfcal_plots.control.mapfile_in                      =   merge_selfcal_parmdbs.output.mapfile
make_selfcal_plots.control.inputkeys                       =   parmdb
make_selfcal_plots.control.outputkey                       =   plots_root
make_selfcal_plots.argument.flags                          =   [parmdb,plots_root]
make_selfcal_plots.argument.fourpol                        =   {{ fourpol }}
{% if preapply_solve_tec_only %}
make_selfcal_plots.argument.plot_tec_scalarphase           =   False
{% endif %}

# create a mapfile with the selfcal images, length = 1
create_selfcal_images_mapfile.control.kind                 =   plugin
create_selfcal_images_mapfile.control.type                 =   addSelfcalImagesMapfile
create_selfcal_images_mapfile.control.selfcal_dir          =   {{ pipeline_parset_dir }}
create_selfcal_images_mapfile.control.mapfile_dir          =   input.output.mapfile_dir
create_selfcal_images_mapfile.control.hosts                =   {{ hosts }}
create_selfcal_images_mapfile.control.filename             =   selfcal_images.mapfile

# make plots of the selfcal images, length = 1
make_selfcal_images.control.type                           =   make_selfcal_images
make_selfcal_images.control.mapfile_in                     =   create_selfcal_images_mapfile.output.mapfile
make_selfcal_images.control.inputkeys                      =   imagefiles
make_selfcal_images.argument.flags                         =   [imagefiles]

# expand the merged parmDB to all files, length = nfiles
expand_merged_parmdb_map.control.kind                      =   plugin
expand_merged_parmdb_map.control.type                      =   expandMapfile
expand_merged_parmdb_map.control.mapfile_in                =   merge_selfcal_parmdbs.output.mapfile
expand_merged_parmdb_map.control.mapfile_to_match          =   shift_empty.output.mapfile
expand_merged_parmdb_map.control.mapfile_dir               =   input.output.mapfile_dir
expand_merged_parmdb_map.control.filename                  =   expand_merged_parmdbs.mapfile

{% if is_patch or skip_facet_imaging %}
# The calibrator is the full patch. (No need to re-image the facet.)

# create a mapfile for the model image, length = 1
create_model4_map.control.kind                             =   plugin
create_model4_map.control.type                             =   trimMapfile
create_model4_map.control.mapfile_in                       =   wsclean_image42.output.wsclean_image42-model.fits.mapfile
create_model4_map.control.trim                             =   -
create_model4_map.control.mapfile_dir                      =   input.output.mapfile_dir
create_model4_map.control.filename                         =   final_model_rootnames.mapfile

# Blank (with zeros) regions of the model image that lie outside of the patch region, length = 1
blank_model.control.type                                   =   blank_image
blank_model.control.mapfile_in                             =   create_model4_map.output.mapfile
blank_model.control.inputkey                               =   infile
blank_model.control.outputkey                              =   outfile
blank_model.argument.flags                                 =   [infile,{{ vertices_file }},outfile]
blank_model.argument.blank_value                           =   zero
blank_model.argument.img_format                            =   fits
blank_model.argument.image_is_wsclean_model                =   True

{% else %}

# apply the direction-dependent solutions and average, length = nfiles
apply_dir_dep.control.type                                 =   dppp
{% if preapply_phase_cal %}
apply_dir_dep.control.opts.mapfiles_in                     =   [shift_empty.output.mapfile,expand_merged_parmdb_map.output.mapfile,expand_preapply_parmdb_map.output.mapfile]
apply_dir_dep.control.opts.inputkeys                       =   [msin,dir_dep_parmdb,preapply_parmdb]
{% else %}
apply_dir_dep.control.opts.mapfiles_in                     =   [shift_empty.output.mapfile,expand_merged_parmdb_map.output.mapfile]
apply_dir_dep.control.opts.inputkeys                       =   [msin,dir_dep_parmdb]
{% endif %}
apply_dir_dep.argument.numthreads                          =   {{ max_cpus_per_io_proc_nfiles }}
apply_dir_dep.argument.msin.datacolumn                     =   CORRECTED_DATA
apply_dir_dep.argument.msout.overwrite                     =   True
apply_dir_dep.argument.msout.writefullresflag              =   False
{% if local_dir is not none %}
apply_dir_dep.argument.local_scratch_dir                   =   {{ local_dir }}
{% endif %}
{% if preapply_phase_cal %}
{% if preapply_solve_tec_only %}
apply_dir_dep.argument.steps                               =   [preapply_fast1,preapply_fast2,preapply_slow,correct_fast1,correct_slow,flagzero,avg]
{% else %}
apply_dir_dep.argument.steps                               =   [preapply_fast1,preapply_fast2,preapply_slow,correct_fast1,correct_fast2,correct_slow,flagzero,avg]
{% endif %}
apply_dir_dep.argument.preapply_fast1.type                 =   applycal
apply_dir_dep.argument.preapply_fast1.parmdb               =   preapply_parmdb
apply_dir_dep.argument.preapply_fast1.correction           =   tec
apply_dir_dep.argument.preapply_fast1.invert               =   True
apply_dir_dep.argument.preapply_fast2.type                 =   applycal
apply_dir_dep.argument.preapply_fast2.parmdb               =   preapply_parmdb
apply_dir_dep.argument.preapply_fast2.correction           =   commonscalarphase
apply_dir_dep.argument.preapply_fast2.invert               =   True
apply_dir_dep.argument.preapply_slow.type                  =   applycal
apply_dir_dep.argument.preapply_slow.parmdb                =   preapply_parmdb
apply_dir_dep.argument.preapply_slow.invert                =   True
{% else %}
apply_dir_dep.argument.steps                               =   [correct_fast1,correct_fast2,correct_slow,flagzero,avg]
{% endif %}
apply_dir_dep.argument.correct_fast1.type                  =   applycal
apply_dir_dep.argument.correct_fast1.parmdb                =   dir_dep_parmdb
apply_dir_dep.argument.correct_fast1.correction            =   tec
apply_dir_dep.argument.correct_fast1.invert                =   True
{% if not preapply_solve_tec_only %}
apply_dir_dep.argument.correct_fast2.type                  =   applycal
apply_dir_dep.argument.correct_fast2.parmdb                =   dir_dep_parmdb
apply_dir_dep.argument.correct_fast2.correction            =   commonscalarphase
apply_dir_dep.argument.correct_fast2.invert                =   True
{% endif %}
apply_dir_dep.argument.correct_slow.type                   =   applycal
apply_dir_dep.argument.correct_slow.parmdb                 =   dir_dep_parmdb
apply_dir_dep.argument.correct_slow.invert                 =   True
apply_dir_dep.argument.flagzero.type                       =   preflagger
apply_dir_dep.argument.flagzero.amplmin                    =   1e-20
apply_dir_dep.argument.avg.type                            =   squash
apply_dir_dep.argument.avg.freqstep                        =   {{ facetimage_freqstep }}
apply_dir_dep.argument.avg.timestep                        =   {{ facetimage_timestep }}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile5.control.kind                    =   plugin
create_compressed_mapfile5.control.type                    =   compressMapfile
create_compressed_mapfile5.control.mapfile_in              =   apply_dir_dep.output.mapfile
create_compressed_mapfile5.control.mapfile_dir             =   input.output.mapfile_dir
create_compressed_mapfile5.control.filename                =   concat_averaged_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes
# we also make dummy data to fill gaps and pad as needed
sort_averaged.control.type                                 =   sort_times_into_freqGroups
sort_averaged.argument.flags                               =   [create_compressed_mapfile5.output.mapfile]
sort_averaged.argument.filename                            =   apply_dir_dep_sorted_groups.mapfile
sort_averaged.argument.mapfile_dir                         =   input.output.mapfile_dir
sort_averaged.argument.hosts                               =   {{ hosts }}
sort_averaged.argument.stepname                            =   sort_averaged
sort_averaged.argument.nband_pad                           =   {{ nband_pad }}
sort_averaged.argument.make_dummy_files                    =   True

# convert the output of sort_averaged into usable mapfiles, len = 1 / ntimes
sort_averaged_maps.control.kind                            =   plugin
sort_averaged_maps.control.type                            =   mapfilenamesFromMapfiles
sort_averaged_maps.control.mapfile_groupmap                =   sort_averaged.output.groupmapfile.mapfile
sort_averaged_maps.control.mapfile_filesmap                =   sort_averaged.output.mapfile.mapfile

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile6.control.kind                    =   plugin
create_compressed_mapfile6.control.type                    =   compressMapfile
create_compressed_mapfile6.control.mapfile_in              =   sort_averaged_maps.output.filesmap
create_compressed_mapfile6.control.mapfile_dir             =   input.output.mapfile_dir
create_compressed_mapfile6.control.filename                =   full_image_input.mapfile

# make a mask from the last selfcal image, length = 1
premask.control.type                                       =   make_clean_mask
premask.control.mapfile_in                                 =   create_imagebase_map42.output.mapfile
premask.control.inputkey                                   =   imagefile
premask.control.outputkey                                  =   maskfile
premask.argument.flags                                     =   [imagefile,maskfile]
premask.argument.img_format                                =   fits
premask.argument.pad_to_size                               =   {{ facet_imsize }}
premask.argument.skip_source_detection                     =   True
premask.argument.vertices_file                             =   {{ vertices_file }}
premask.argument.reference_ra_deg                          =   {{ facet_ra }}
premask.argument.reference_dec_deg                         =   {{ facet_dec }}

# image the concatenated data with the preliminary mask, length = 1
wsclean_image_full1.control.type                           =   wsclean
wsclean_image_full1.control.mapfiles_in                    =   [create_compressed_mapfile6.output.mapfile,premask.output.mapfile]
wsclean_image_full1.control.inputkeys                      =   [msfile,fitsmask]
wsclean_image_full1.argument.flags                         =   [-no-update-model-required,{{ wsclean_multiscale }}-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image_full1.argument.fitsmask                      =   fitsmask
wsclean_image_full1.argument.size                          =   {{ facet_imsize }} {{ facet_imsize }}
wsclean_image_full1.argument.niter                         =   {{ wsclean_full1_image_niter }}
wsclean_image_full1.argument.threshold                     =   {{ wsclean_full1_image_threshold_jy }}
wsclean_image_full1.argument.pol                           =   I
wsclean_image_full1.argument.weight                        =   briggs {{ robust_selfcal }}
wsclean_image_full1.argument.mgain                         =   0.6
wsclean_image_full1.argument.cleanborder                   =   0
wsclean_image_full1.argument.minuv-l                       =   {{ facet_min_uv_lambda }}
wsclean_image_full1.argument.scale                         =   {{ cellsize_selfcal_deg }}
wsclean_image_full1.argument.channelsout                   =   {{ wsclean_nchannels }}
wsclean_image_full1.argument.mem                           =   {{ max_percent_memory_per_proc_single }}
wsclean_image_full1.argument.j                             =   {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image_full1.argument.tempdir                       =   {{ local_dir }}
{% endif %}
wsclean_image_full1.argument.weighting-rank-filter         =   3
{% if facetimage_wsclean_nwavelengths > 0.0 %}
wsclean_image_full1.argument.baseline-averaging            =   {{ facetimage_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the WSClean images, length = 1
create_imagebase_map.control.kind                          =   plugin
create_imagebase_map.control.type                          =   trimMapfile
create_imagebase_map.control.mapfile_in                    =   wsclean_image_full1.output.wsclean_image_full1-image.fits.mapfile
create_imagebase_map.control.trim                          =   -
create_imagebase_map.control.mapfile_dir                   =   input.output.mapfile_dir
create_imagebase_map.control.filename                      =   wsclean_image_full1_image_rootnames.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile1.control.kind                       =   plugin
adjust_wsclean_mapfile1.control.type                       =   appendMapfile
adjust_wsclean_mapfile1.control.mapfile_in                 =   create_imagebase_map.output.mapfile
adjust_wsclean_mapfile1.control.append                     =   {{ wsclean_suffix }}
adjust_wsclean_mapfile1.control.mapfile_dir                =   input.output.mapfile_dir
adjust_wsclean_mapfile1.control.filename                   =   final_image1.mapfile

# make a mask from the updated image, length = 1
mask5.control.type                                         =   make_clean_mask
mask5.control.mapfile_in                                   =   adjust_wsclean_mapfile1.output.mapfile
mask5.control.inputkey                                     =   imagefile
mask5.control.outputkey                                    =   maskfile
mask5.argument.flags                                       =   [imagefile,maskfile]
mask5.argument.region_file                                 =   {{ region_field }}
mask5.argument.threshisl                                   =   3
mask5.argument.threshpix                                   =   5
mask5.argument.rmsbox                                      =   (300,100)
mask5.argument.rmsbox_bright                               =   (70,10)
mask5.argument.atrous_jmax                                 =   3
mask5.argument.adaptive_rmsbox                             =   True
mask5.argument.atrous_do                                   =   True
mask5.argument.img_format                                  =   fits
mask5.argument.vertices_file                               =   {{ vertices_file }}

# image the concatenated data with the updated mask, length = 1
wsclean_image_full2.control.type                           =   wsclean
wsclean_image_full2.control.mapfiles_in                    =   [create_compressed_mapfile6.output.mapfile,mask5.output.mapfile,mask5.output.threshold_5sig.mapfile]
wsclean_image_full2.control.inputkeys                      =   [msfile,fitsmask,threshold]
wsclean_image_full2.argument.flags                         =   [-no-update-model-required,{{ wsclean_multiscale }}-fitbeam,-reorder,-joinchannels,msfile]
wsclean_image_full2.argument.fitsmask                      =   fitsmask
wsclean_image_full2.argument.size                          =   {{ facet_imsize }} {{ facet_imsize }}
wsclean_image_full2.argument.niter                         =   {{ wsclean_full2_image_niter }}
wsclean_image_full2.argument.threshold                     =   threshold
wsclean_image_full2.argument.pol                           =   I
wsclean_image_full2.argument.weight                        =   briggs {{ robust_selfcal }}
wsclean_image_full2.argument.mgain                         =   0.6
wsclean_image_full2.argument.cleanborder                   =   0
wsclean_image_full2.argument.minuv-l                       =   {{ facet_min_uv_lambda }}
wsclean_image_full2.argument.scale                         =   {{ cellsize_selfcal_deg }}
wsclean_image_full2.argument.channelsout                   =   {{ wsclean_nchannels }}
wsclean_image_full2.argument.mem                           =   {{ max_percent_memory_per_proc_single }}
wsclean_image_full2.argument.j                             =   {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image_full2.argument.tempdir                       =   {{ local_dir }}
{% endif %}
wsclean_image_full2.argument.weighting-rank-filter         =   3
{% if facetimage_wsclean_nwavelengths > 0.0 %}
wsclean_image_full2.argument.baseline-averaging            =   {{ facetimage_wsclean_nwavelengths }}
{% endif %}

# make a mapfile with the root-name of the final WSClean images, length = 1
create_model4_map.control.kind                             =   plugin
create_model4_map.control.type                             =   trimMapfile
create_model4_map.control.mapfile_in                       =   wsclean_image_full2.output.wsclean_image_full2-model.fits.mapfile
create_model4_map.control.trim                             =   -
create_model4_map.control.mapfile_dir                      =   input.output.mapfile_dir
create_model4_map.control.filename                         =   final_model_rootnames.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile2.control.kind                       =   plugin
adjust_wsclean_mapfile2.control.type                       =   appendMapfile
adjust_wsclean_mapfile2.control.mapfile_in                 =   create_model4_map.output.mapfile
adjust_wsclean_mapfile2.control.append                     =   {{ wsclean_suffix }}
adjust_wsclean_mapfile2.control.mapfile_dir                =   input.output.mapfile_dir
adjust_wsclean_mapfile2.control.filename                   =   final_image.mapfile

{% endif %}
########## end of the "is the calibrator the full facet" if-clause

# pad the model image with zeros, length = 1
pad_model_images.control.type                              =   pad_image
{% if is_patch or skip_facet_imaging %}
pad_model_images.control.mapfile_in                        =   blank_model.output.mapfile
{% else %}
pad_model_images.control.mapfile_in                        =   create_model4_map.output.mapfile
{% endif %}
pad_model_images.control.inputkey                          =   imagefile
pad_model_images.argument.flags                            =   [imagefile,{{ wsclean_facet_model_padding }}]

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile_shift_empty.control.kind         =   plugin
create_compressed_mapfile_shift_empty.control.type         =   compressMapfile
create_compressed_mapfile_shift_empty.control.mapfile_in   =   shift_empty.output.mapfile
create_compressed_mapfile_shift_empty.control.mapfile_dir  =   input.output.mapfile_dir
create_compressed_mapfile_shift_empty.control.filename     =   concat_shift_empty_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes
sort_shift_empty_into_Groups.control.type                  =   sort_times_into_freqGroups
sort_shift_empty_into_Groups.argument.flags                =   [create_compressed_mapfile_shift_empty.output.mapfile]
sort_shift_empty_into_Groups.argument.filename             =   sorted_groups_shift_empty.mapfile
sort_shift_empty_into_Groups.argument.mapfile_dir          =   input.output.mapfile_dir
sort_shift_empty_into_Groups.argument.hosts                =   {{ hosts }}
sort_shift_empty_into_Groups.argument.stepname             =   sort_shift_empty_into_Groups
{% if is_patch or skip_facet_imaging %}
sort_shift_empty_into_Groups.argument.nband_pad            =   {{ nband_pad_selfcal }}
{% else %}
sort_shift_empty_into_Groups.argument.nband_pad            =   {{ nband_pad }}
{% endif %}
sort_shift_empty_into_Groups.argument.make_dummy_files     =   True

# convert the output of sort_into_Groups into usable mapfiles, len = 1 / ntimes
sort_shift_empty_into_Groups_maps.control.kind             =   plugin
sort_shift_empty_into_Groups_maps.control.type             =   mapfilenamesFromMapfiles
sort_shift_empty_into_Groups_maps.control.mapfile_groupmap =   sort_shift_empty_into_Groups.output.groupmapfile.mapfile
sort_shift_empty_into_Groups_maps.control.mapfile_filesmap =   sort_shift_empty_into_Groups.output.mapfile.mapfile

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model_mapfile.control.kind                 =   plugin
create_expanded_model_mapfile.control.type                 =   expandMapfile
{% if is_patch or skip_facet_imaging %}
create_expanded_model_mapfile.control.mapfile_in           =   blank_model.output.mapfile
{% else %}
create_expanded_model_mapfile.control.mapfile_in           =   create_model4_map.output.mapfile
{% endif %}
create_expanded_model_mapfile.control.mapfile_to_match     =   sort_shift_empty_into_Groups_maps.output.groupmap
create_expanded_model_mapfile.control.mapfile_dir          =   input.output.mapfile_dir
create_expanded_model_mapfile.control.filename             =   expand_wsclean_model.mapfile

# expand mapfile of the model image sizes to all groups, length = ntimes
expand_facet_model_size_map.control.kind                   =   plugin
expand_facet_model_size_map.control.type                   =   expandMapfile
expand_facet_model_size_map.control.mapfile_in             =   pad_model_images.output.padsize.mapfile
expand_facet_model_size_map.control.mapfile_to_match       =   sort_shift_empty_into_Groups_maps.output.groupmap
expand_facet_model_size_map.control.mapfile_dir            =   input.output.mapfile_dir
expand_facet_model_size_map.control.filename               =   expand_facet_model_size.mapfile

# make model visibilities, length = ntimes
# For WSClean predict, we need to increase the number of wplanes so that the
# effective model image size is larger than the FOV (to prevent aliasing issues).
wsclean_ft.control.type                                    =   wsclean_ft
wsclean_ft.control.mapfiles_in                             =   [sort_shift_empty_into_Groups_maps.output.filesmap,create_expanded_model_mapfile.output.mapfile,expand_facet_model_size_map.output.mapfile]
wsclean_ft.control.inputkeys                               =   [msfile,name,size]
wsclean_ft.argument.flags                                  =   [-predict,msfile]
wsclean_ft.argument.scale                                  =   {{ cellsize_selfcal_deg }}
wsclean_ft.argument.mem                                    =   {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft.argument.j                                      =   {{ max_cpus_per_io_proc_ntimes }}
{% if is_patch or skip_facet_imaging %}
wsclean_ft.argument.channelsout                            =   {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_ft.argument.channelsout                            =   {{ wsclean_nchannels }}
{% endif %}
{% if local_dir is not none %}
wsclean_ft.argument.tempdir                                =   {{ local_dir }}
{% endif %}
wsclean_ft.argument.nwlayers-for-size                      =   12288 12288

# corrupt the model visibilities, length = nfiles
corrupt_final_model.control.type                           =   dppp_inplace
{% if preapply_phase_cal %}
corrupt_final_model.control.opts.mapfiles_in               =   [shift_empty.output.mapfile,expand_merged_parmdb_map.output.mapfile,expand_preapply_parmdb_map.output.mapfile]
corrupt_final_model.control.opts.inputkeys                 =   [msin,dir_dep_parmdb,preapply_parmdb]
{% else %}
corrupt_final_model.control.opts.mapfiles_in               =   [shift_empty.output.mapfile,expand_merged_parmdb_map.output.mapfile]
corrupt_final_model.control.opts.inputkeys                 =   [msin,dir_dep_parmdb]
{% endif %}
corrupt_final_model.argument.numthreads                    =   {{ max_cpus_per_proc_nfiles }}
corrupt_final_model.argument.msin.datacolumn               =   MODEL_DATA
corrupt_final_model.argument.msout                         =   .
corrupt_final_model.argument.msout.datacolumn              =   MODEL_DATA_NEW
{% if preapply_phase_cal %}
{% if preapply_solve_tec_only %}
corrupt_final_model.argument.steps                         =   [preapply_fast1,preapply_fast2,preapply_slow,corrupt_fast1,corrupt_slow]
{% else %}
corrupt_final_model.argument.steps                         =   [preapply_fast1,preapply_fast2,preapply_slow,corrupt_fast1,corrupt_fast2,corrupt_slow]
{% endif %}
corrupt_final_model.argument.preapply_fast1.type           =   applycal
corrupt_final_model.argument.preapply_fast1.parmdb         =   preapply_parmdb
corrupt_final_model.argument.preapply_fast1.correction     =   tec
corrupt_final_model.argument.preapply_fast1.invert         =   False
corrupt_final_model.argument.preapply_fast2.type           =   applycal
corrupt_final_model.argument.preapply_fast2.parmdb         =   preapply_parmdb
corrupt_final_model.argument.preapply_fast2.correction     =   commonscalarphase
corrupt_final_model.argument.preapply_fast2.invert         =   False
corrupt_final_model.argument.preapply_slow.type            =   applycal
corrupt_final_model.argument.preapply_slow.parmdb          =   preapply_parmdb
corrupt_final_model.argument.preapply_slow.invert          =   False
{% else %}
corrupt_final_model.argument.steps                         =   [corrupt_fast1,corrupt_fast2,corrupt_slow]
{% endif %}
corrupt_final_model.argument.corrupt_fast1.type            =   applycal
corrupt_final_model.argument.corrupt_fast1.parmdb          =   dir_dep_parmdb
corrupt_final_model.argument.corrupt_fast1.correction      =   tec
corrupt_final_model.argument.corrupt_fast1.invert          =   False
{% if not preapply_solve_tec_only %}
corrupt_final_model.argument.corrupt_fast2.type            =   applycal
corrupt_final_model.argument.corrupt_fast2.parmdb          =   dir_dep_parmdb
corrupt_final_model.argument.corrupt_fast2.correction      =   commonscalarphase
corrupt_final_model.argument.corrupt_fast2.invert          =   False
{% endif %}
corrupt_final_model.argument.corrupt_slow.type             =   applycal
corrupt_final_model.argument.corrupt_slow.parmdb           =   dir_dep_parmdb
corrupt_final_model.argument.corrupt_slow.correction       =   gain
corrupt_final_model.argument.corrupt_slow.invert           =   False

# subtract new model vis from original model, length = nfiles
# No compression
subtract_initial_final.control.type                        =   add_subtract_columns
subtract_initial_final.control.opts.mapfiles_in            =   [shift_empty.output.mapfile,shift_empty.output.mapfile]
subtract_initial_final.control.opts.inputkeys              =   [file1,file2]
subtract_initial_final.argument.flags                      =   [file1,file2,MODEL_DATA_ORIG,MODEL_DATA_NEW,MODEL_DATA,subtract,True,False]

# shift model difference to field center, length = nfiles
# Compress weights only
shift_diff_model_to_field.control.type                                 =   dppp
shift_diff_model_to_field.control.opts.mapfile_in                      =   shift_empty.output.mapfile
shift_diff_model_to_field.control.opts.inputkey                        =   msin
shift_diff_model_to_field.argument.numthreads                          =   {{ max_cpus_per_io_proc_nfiles }}
shift_diff_model_to_field.argument.msin.datacolumn                     =   MODEL_DATA
shift_diff_model_to_field.argument.msout.overwrite                     =   True
shift_diff_model_to_field.argument.msout.writefullresflag              =   False
{% if local_dir is not none %}
shift_diff_model_to_field.argument.local_scratch_dir                   =   {{ local_dir }}
{% endif %}
shift_diff_model_to_field.argument.steps                               =   [shift]
shift_diff_model_to_field.argument.shift.type                          =   phaseshifter
shift_diff_model_to_field.argument.shift.phasecenter                   =   [{{ field_ra }}deg, {{ field_dec }}deg]
{% if use_compression %}
shift_diff_model_to_field.argument.msout.storagemanager                =   "Dysco"
shift_diff_model_to_field.argument.msout.storagemanager.databitrate    =   0
shift_diff_model_to_field.argument.msout.storagemanager.weightbitrate  =   12
shift_diff_model_to_field.argument.msout.storagemanager.distribution   =   "TruncatedGaussian"
shift_diff_model_to_field.argument.msout.storagemanager.disttruncation =   1.5
shift_diff_model_to_field.argument.msout.storagemanager.normalization  =   "AF"
{% endif %}

#
# Verify the the quality of the selfcal on the middle band
#

# make a map with original facet data of only the central frequency band, length = ntimes
create_middle_band_mapfile.control.kind                    =   plugin
create_middle_band_mapfile.control.type                    =   selectMiddleFreq
create_middle_band_mapfile.control.mapfile_in              =   shift_empty.output.mapfile
create_middle_band_mapfile.control.mapfile_dir             =   input.output.mapfile_dir
create_middle_band_mapfile.control.filename                =   single_band.mapfile

# subtract new facet data from original full facet data, length = ntimes
subtract_single.control.type                               =   add_subtract_columns
subtract_single.control.opts.mapfiles_in                   =   [create_middle_band_mapfile.output.mapfile,create_middle_band_mapfile.output.mapfile]
subtract_single.control.opts.inputkeys                     =   [file1,file2]
subtract_single.argument.flags                             =   [file1,file2,CORRECTED_DATA,MODEL_DATA_NEW,MODEL_DATA,subtract,True,False]

# average old empty data, length = ntimes
average_pre.control.type                                   =   dppp
average_pre.control.mapfile_in                             =   create_middle_band_mapfile.output.mapfile
average_pre.control.inputkey                               =   msin
average_pre.argument.numthreads                            =   {{ max_cpus_per_io_proc_ntimes }}
average_pre.argument.msin.datacolumn                       =   DATA
average_pre.argument.msout.overwrite                       =   True
average_pre.argument.msout.writefullresflag                =   False
{% if local_dir is not none %}
average_pre.argument.local_scratch_dir                     =   {{ local_dir }}
{% endif %}
average_pre.argument.steps                                 =   [uv,avg]
average_pre.argument.uv.type                               =   uvwflagger
average_pre.argument.uv.uvmmax                             =   2500.0
average_pre.argument.avg.type                              =   squash
average_pre.argument.avg.freqstep                          =   {{ verify_freqstep }}
average_pre.argument.avg.timestep                          =   {{ verify_timestep }}
{% if use_compression %}
average_pre.argument.msout.storagemanager                  =   "Dysco"
average_pre.argument.msout.storagemanager.databitrate      =   16
average_pre.argument.msout.storagemanager.weightbitrate    =   12
average_pre.argument.msout.storagemanager.distribution     =   "TruncatedGaussian"
average_pre.argument.msout.storagemanager.disttruncation   =   1.5
average_pre.argument.msout.storagemanager.normalization    =   "AF"
{% endif %}

# average "old minus new" facet data (= new empty data), length = ntimes
average_post.control.type                                  =   dppp
average_post.control.mapfile_in                            =   create_middle_band_mapfile.output.mapfile
average_post.control.inputkey                              =   msin
average_post.argument.numthreads                           =   {{ max_cpus_per_io_proc_ntimes }}
average_post.argument.msin.datacolumn                      =   MODEL_DATA
average_post.argument.msout.overwrite                      =   True
average_post.argument.msout.writefullresflag               =   False
{% if local_dir is not none %}
average_post.argument.local_scratch_dir                    =   {{ local_dir }}
{% endif %}
average_post.argument.steps                                =   [uv,avg]
average_post.argument.uv.type                              =   uvwflagger
average_post.argument.uv.uvmmax                            =   2500.0
average_post.argument.avg.type                             =   squash
average_post.argument.avg.freqstep                         =   {{ verify_freqstep }}
average_post.argument.avg.timestep                         =   {{ verify_timestep }}
{% if use_compression %}
average_post.argument.msout.storagemanager                 =   "Dysco"
average_post.argument.msout.storagemanager.databitrate     =   16
average_post.argument.msout.storagemanager.weightbitrate   =   12
average_post.argument.msout.storagemanager.distribution    =   "TruncatedGaussian"
average_post.argument.msout.storagemanager.disttruncation  =   1.5
average_post.argument.msout.storagemanager.normalization   =   "AF"
{% endif %}

# make compressed mapfile of old empty data, length = 1
average_pre_compressed_map.control.kind                    =   plugin
average_pre_compressed_map.control.type                    =   compressMapfile
average_pre_compressed_map.control.mapfile_in              =   average_pre.output.mapfile
average_pre_compressed_map.control.mapfile_dir             =   input.output.mapfile_dir
average_pre_compressed_map.control.filename                =   average_pre_compressed.mapfile

# image the old empty data, length = 1
wsclean_pre.control.type                                   =   wsclean
wsclean_pre.control.mapfile_in                             =   average_pre_compressed_map.output.mapfile
wsclean_pre.control.inputkey                               =   msfiles
wsclean_pre.argument.flags                                 =   [-no-update-model-required,msfiles]
wsclean_pre.argument.size                                  =   2048 2048
wsclean_pre.argument.niter                                 =   10
wsclean_pre.argument.threshold                             =   0.0
wsclean_pre.argument.pol                                   =   I
wsclean_pre.argument.weight                                =   briggs -0.5
wsclean_pre.argument.mgain                                 =   0.5
wsclean_pre.argument.gain                                  =   0.1
wsclean_pre.argument.cleanborder                           =   0
wsclean_pre.argument.minuv-l                               =   {{ facet_min_uv_lambda }}
wsclean_pre.argument.maxuv-l                               =   2500
wsclean_pre.argument.scale                                 =   0.00833
wsclean_pre.argument.mem                                   =   {{ max_percent_memory_per_proc_single }}
wsclean_pre.argument.j                                     =   {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_pre.argument.tempdir                               =   {{ local_dir }}
{% endif %}

# make compressed mapfile of new empty data, length = 1
average_post_compressed_map.control.kind                   =   plugin
average_post_compressed_map.control.type                   =   compressMapfile
average_post_compressed_map.control.mapfile_in             =   average_post.output.mapfile
average_post_compressed_map.control.mapfile_dir            =   input.output.mapfile_dir
average_post_compressed_map.control.filename               =   average_post_compressed.mapfile

# image the new empty data, length = 1
wsclean_post.control.type                                  =   wsclean
wsclean_post.control.mapfile_in                            =   average_post_compressed_map.output.mapfile
wsclean_post.control.inputkey                              =   msfiles
wsclean_post.argument.flags                                =   [-no-update-model-required,msfiles]
wsclean_post.argument.size                                 =   2048 2048
wsclean_post.argument.niter                                =   10
wsclean_post.argument.threshold                            =   0.0
wsclean_post.argument.pol                                  =   I
wsclean_post.argument.weight                               =   briggs -0.5
wsclean_post.argument.mgain                                =   0.5
wsclean_post.argument.gain                                 =   0.1
wsclean_post.argument.cleanborder                          =   0
wsclean_post.argument.minuv-l                              =   {{ facet_min_uv_lambda }}
wsclean_post.argument.maxuv-l                              =   2500
wsclean_post.argument.scale                                =   0.00833
wsclean_post.argument.mem                                  =   {{ max_percent_memory_per_proc_single }}
wsclean_post.argument.j                                    =   {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_post.argument.tempdir                              =   {{ local_dir }}
{% endif %}

# do a "verify_subtract" on the two "empty" images, length = 1
verify_subtract.control.type                               =   verify_subtract
verify_subtract.control.mapfiles_in                        =   [wsclean_pre.output.wsclean_pre-image.fits.mapfile,wsclean_post.output.wsclean_post-image.fits.mapfile]
verify_subtract.control.inputkeys                          =   [image_pre,image_post]
verify_subtract.argument.flags                             =   [image_pre,image_post,0.75]
