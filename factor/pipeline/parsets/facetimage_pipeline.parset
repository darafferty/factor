pipeline.steps = [update_mapfile_hosts, create_ms_map, create_msmulti_map, create_parmdb_map, expand_parmdb_map, prepare_imaging_data, create_compressed_mapfile, premask, wsclean_image_full, create_imagebase_map2, adjust_wsclean_mapfile2, make_sourcedb_new_facet_sources, expand_sourcedb_new_facet_sources, predict_models, corrupt_models]

pipeline.pluginpath = {{ pipeline_dir }}/plugins

# update host entries in all mapfiles
update_mapfile_hosts.control.kind        = plugin
update_mapfile_hosts.control.type        = updateHosts
update_mapfile_hosts.control.mapfile_dir = input.output.mapfile_dir
update_mapfile_hosts.control.hosts       = {{ hosts }}

# create a mapfile with all single MSs from supplied list, length = nfiles
create_ms_map.control.kind        = plugin
create_ms_map.control.type        = addListMapfile
create_ms_map.control.hosts       = {{ hosts }}
create_ms_map.control.files       = {{ ms_files_single }}
create_ms_map.control.mapfile_dir = input.output.mapfile_dir
create_ms_map.control.filename    = input_bands.mapfile

# create a multi-mapfile with the groups of MSs from supplied list, length = nbands
create_msmulti_map.control.kind        = plugin
create_msmulti_map.control.type        = addListMultiMapfile
create_msmulti_map.control.hosts       = {{ hosts }}
create_msmulti_map.control.files       = {{ ms_files_grouped }}
create_msmulti_map.control.mapfile_dir = input.output.mapfile_dir
create_msmulti_map.control.filename    = input_files_grouped.mapfile

# create a mapfile with the dde h5parms from supplied list, length = 1
create_parmdb_map.control.kind        = plugin
create_parmdb_map.control.type        = addListMapfile
create_parmdb_map.control.hosts       = {{ hosts }}
create_parmdb_map.control.files       = {{ dde_h5parms }}
create_parmdb_map.control.mapfile_dir = input.output.mapfile_dir
create_parmdb_map.control.filename    = dir_indep_instrument_parmdbs.mapfile

# expand mapfile of the dir-dependent parmDB to all files, length = nfiles
expand_parmdb_map.control.kind             = plugin
expand_parmdb_map.control.type             = expandMapfile
expand_parmdb_map.control.mapfile_in       = create_parmdb_map.output.mapfile
expand_parmdb_map.control.mapfile_to_match = create_ms_map.output.mapfile
expand_parmdb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_parmdb_map.control.filename         = expand_parmdbs.mapfile

# shift, apply the direction-dependent solutions, and average, length = nfiles
prepare_imaging_data.control.type                                 = dppp
prepare_imaging_data.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_parmdb_map.output.mapfile]
prepare_imaging_data.control.inputkeys                            = [msin,dde_parmdb]
prepare_imaging_data.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
prepare_imaging_data.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
prepare_imaging_data.argument.msout.overwrite                     = True
prepare_imaging_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
prepare_imaging_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
prepare_imaging_data.argument.steps                               = [flag,shift,correct1,correct2,flagzero,avg]
{% else %}
{% if use_screens %}
prepare_imaging_data.argument.steps                               = [shift,correct1,flagzero,avg]
{% else %}
prepare_imaging_data.argument.steps                               = [shift,correct1,correct2,flagzero,avg]
{% endif %}
{% endif %}
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
prepare_imaging_data.argument.flag.type                           = preflagger
prepare_imaging_data.argument.flag.expr                           = {{ flag_expr }}
{% endif %}
{% if flag_abstime is not none %}
prepare_imaging_data.argument.flag.flag_abstime.abstime           = {{ flag_abstime }}
{% endif %}
{% if flag_baseline is not none %}
prepare_imaging_data.argument.flag.flag_baseline.baseline         = {{ flag_baseline }}
{% endif %}
{% if flag_freqrange is not none %}
prepare_imaging_data.argument.flag.flag_freqrange.freqrange       = {{ flag_freqrange }}
{% endif %}
prepare_imaging_data.argument.shift.type                          = phaseshifter
prepare_imaging_data.argument.shift.phasecenter                   = [{{ facet_ra }}deg, {{ facet_dec }}deg]
{% if use_screens %}
prepare_imaging_data.argument.correct1.type                        = applycal
prepare_imaging_data.argument.correct1.parmdb                      = dde_parmdb
prepare_imaging_data.argument.correct1.correction                  = screenphases000
prepare_imaging_data.argument.correct1.direction                   = [{{ name }}]
{% else %}
prepare_imaging_data.argument.correct1.type                        = applycal
prepare_imaging_data.argument.correct1.parmdb                      = dde_parmdb
prepare_imaging_data.argument.correct1.correction                  = tec_screensols_all_000
prepare_imaging_data.argument.correct1.direction                   = [{{ name }}]
prepare_imaging_data.argument.correct2.type                        = applycal
prepare_imaging_data.argument.correct2.parmdb                      = dde_parmdb
prepare_imaging_data.argument.correct2.correction                  = scalarphase_screensols_all_000
prepare_imaging_data.argument.correct2.direction                   = [{{ name }}]
{% endif %}
prepare_imaging_data.argument.flagzero.type                       = preflagger
prepare_imaging_data.argument.flagzero.amplmin                    = 1e-20
prepare_imaging_data.argument.avg.type                            = squash
prepare_imaging_data.argument.avg.freqstep                        = {{ facetimage_freqstep }}
prepare_imaging_data.argument.avg.timestep                        = {{ facetimage_timestep }}
{% if use_compression %}
prepare_imaging_data.argument.msout.storagemanager                = "Dysco"
prepare_imaging_data.argument.msout.storagemanager.databitrate    = 0
prepare_imaging_data.argument.msout.storagemanager.weightbitrate  = 12
prepare_imaging_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
prepare_imaging_data.argument.msout.storagemanager.disttruncation = 1.5
prepare_imaging_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make the compressed mapfile, length = 1
create_compressed_mapfile.control.kind        = plugin
create_compressed_mapfile.control.type        = compressMapfile
create_compressed_mapfile.control.mapfile_in  = prepare_imaging_data.output.mapfile
create_compressed_mapfile.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile.control.filename    = imaging_input.mapfile

# Make a preliminary clean mask from the facet region, length = 1
premask.control.type                   = make_clean_mask
premask.control.mapfile_in             = {{ image_data_mapfile }}
premask.control.inputkey               = imagefile
premask.control.outputkey              = maskfile
premask.argument.flags                 = [imagefile,maskfile]
premask.argument.img_format            = fits
premask.argument.pad_to_size           = {{ facet_imsize }}
premask.argument.skip_source_detection = True
premask.argument.vertices_file         = {{ vertices_file }}
premask.argument.reference_ra_deg      = {{ facet_ra }}
premask.argument.reference_dec_deg     = {{ facet_dec }}
premask.argument.cellsize_deg          = {{ cellsize_facet_deg }}
premask.argument.region_file           = {{ region_field }}
premask.argument.make_blank_image      = True

# do the imaging, length = 1
wsclean_image_full.control.type                   = wsclean
wsclean_image_full.control.mapfiles_in            = [{{ image_data_mapfile }},premask.output.mapfile]
wsclean_image_full.control.inputkeys              = [msfile,fitsmask]
{% if wsclean_nchannels > 1 %}
wsclean_image_full.argument.flags                 = [-no-update-model-required,{{ wsclean_multiscale }}-fitbeam,-reorder,-save-source-list,-local-rms,-joinchannels,msfile]
wsclean_image_full.argument.channelsout           = {{ wsclean_nchannels }}
{% else %}
wsclean_image_full.argument.flags                 = [-no-update-model-required,{{ wsclean_multiscale }}-fitbeam,-reorder,-save-source-list,-local-rms,msfile]
{% endif %}
wsclean_image_full.argument.fitsmask              = fitsmask
wsclean_image_full.argument.size                  = {{ facet_imsize }} {{ facet_imsize }}
wsclean_image_full.argument.niter                 = 100000
wsclean_image_full.argument.pol                   = I
wsclean_image_full.argument.weight                = briggs {{ robust_facet }}
wsclean_image_full.argument.mgain                 = 0.8
wsclean_image_full.argument.minuv-l               = {{ facet_min_uv_lambda }}
wsclean_image_full.argument.scale                 = {{ cellsize_facet_deg }}
wsclean_image_full.argument.mem                   = {{ max_percent_memory_per_proc_single }}
wsclean_image_full.argument.j                     = {{ max_cpus_per_proc_single }}
{% if mscale_facet_do and facet_multiscale_scales_pixel is not none %}
wsclean_image_full.argument.multiscale-scales     = {{ facet_multiscale_scales_pixel }}
{% endif %}
{% if local_dir is not none %}
wsclean_image_full.argument.tempdir               = {{ local_dir_parent }}
{% endif %}
wsclean_image_full.argument.multiscale-shape      = gaussian
wsclean_image_full.argument.weighting-rank-filter = 3
{% if taper_facet_arcsec > 0.0 %}
wsclean_image_full.argument.taper-gaussian        =  {{ taper_facet_arcsec }}
{% endif %}
{% if facetimage_wsclean_nwavelengths > 0.0 %}
wsclean_image_full.argument.baseline-averaging    = {{ facetimage_wsclean_nwavelengths }}
{% endif %}
{% if region_field != "[]" %}
wsclean_image_full.argument.auto-mask             = 2
{% else %}
wsclean_image_full.argument.auto-mask             = 3
{% endif %}
wsclean_image_full.argument.auto-threshold        = 0.3
wsclean_image_full.argument.local-rms-window      = 50
wsclean_image_full.argument.local-rms-method      = rms-with-min

# make a mapfile with the root-name of the WSClean images, length = 1
create_imagebase_map2.control.kind        = plugin
create_imagebase_map2.control.type        = trimMapfile
create_imagebase_map2.control.mapfile_in  = wsclean_image_full.output.wsclean_image_full-image.fits.mapfile
create_imagebase_map2.control.trim        = -
create_imagebase_map2.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map2.control.filename    = wsclean_image_full_image_rootnames.mapfile

# make a mapfile with the name of the WSClean image at a known name, length = 1
adjust_wsclean_mapfile2.control.kind        = plugin
adjust_wsclean_mapfile2.control.type        = appendMapfile
adjust_wsclean_mapfile2.control.mapfile_in  = create_imagebase_map2.output.mapfile
adjust_wsclean_mapfile2.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile2.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile2.control.filename    = final_image.mapfile

# convert the new sky model into a sourcedb, length = nbands
make_sourcedb_new_facet_sources.control.type       = make_sourcedb
make_sourcedb_new_facet_sources.control.mapfile_in = wsclean_image_full.output.wsclean_image_full-sources.txt.mapfile
make_sourcedb_new_facet_sources.control.inputkey   = in
make_sourcedb_new_facet_sources.argument.format    = <
make_sourcedb_new_facet_sources.argument.outtype   = blob
make_sourcedb_new_facet_sources.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_new_facet_sources.control.kind           = plugin
expand_sourcedb_new_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_new_facet_sources.control.mapfile_in     = make_sourcedb_new_facet_sources.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_new_facet_sources.control.filename       = expand_sourcedb_new_facet_sources.mapfile

# predict the new models, length = nfiles
# compress weights only
predict_models.control.type                                 = dppp
predict_models.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_new_facet_sources.output.mapfile]
predict_models.control.inputkeys                            = [msin,dir_dep_sourcedb]
predict_models.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
predict_models.argument.msin.datacolumn                     = DATA
predict_models.argument.msout.overwrite                     = True
predict_models.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
predict_models.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
predict_models.argument.steps                               = [pred_new]
predict_models.argument.pred_new.type                       = predict
predict_models.argument.pred_new.sourcedb                   = dir_dep_sourcedb
predict_models.argument.pred_new.operation                  = replace
{% if use_compression %}
predict_models.argument.msout.storagemanager                = "Dysco"
predict_models.argument.msout.storagemanager.databitrate    = 0
predict_models.argument.msout.storagemanager.weightbitrate  = 12
predict_models.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
predict_models.argument.msout.storagemanager.disttruncation = 1.5
predict_models.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# corrupt the new model vis, length = nfiles
corrupt_models.control.type                                 = dppp_inplace
corrupt_models.control.mapfiles_in                          = [predict_models.output.mapfile,expand_parmdb_map.output.mapfile]
corrupt_models.control.inputkeys                            = [msin,dde_parmdb]
corrupt_models.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
corrupt_models.argument.msin.datacolumn                     = DATA
corrupt_models.argument.msout                               = .
{% if use_screens %}
corrupt_models.argument.steps                               = [corrupt1]
{% else %}
corrupt_models.argument.steps                               = [corrupt1,corrupt2]
{% endif %}
{% if use_screens %}
corrupt_models.argument.corrupt1.type                        = applycal
corrupt_models.argument.corrupt1.parmdb                      = dde_parmdb
corrupt_models.argument.corrupt1.correction                  = screenphases000
corrupt_models.argument.corrupt1.direction                   = [{{ name }}]
corrupt_models.argument.corrupt1.invert                      = False
{% else %}
corrupt_models.argument.corrupt1.type                        = applycal
corrupt_models.argument.corrupt1.parmdb                      = dde_parmdb
corrupt_models.argument.corrupt1.correction                  = tec_screensols_all_000
corrupt_models.argument.corrupt1.direction                   = [{{ name }}]
corrupt_models.argument.corrupt1.invert                      = False
corrupt_models.argument.corrupt2.type                        = applycal
corrupt_models.argument.corrupt2.parmdb                      = dde_parmdb
corrupt_models.argument.corrupt2.correction                  = scalarphase_screensols_all_000
corrupt_models.argument.corrupt2.direction                   = [{{ name }}]
corrupt_models.argument.corrupt2.invert                      = False
{% endif %}
